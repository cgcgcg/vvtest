#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST: trig

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
from os.path import abspath, basename
import time
import subprocess
import glob
import stat
import unittest

import trigtestutils as trigutil
import testutils as util
from testutils import print3

# this is the module we are testing
import trigger

trigfile = os.path.join( trigger.mydir, 'trigger.py' )

localpy = sys.executable


class date_and_time_utilities( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test( cleanout=False )

    def test_recurse_dow_function(self):
        ""
        assert_recurse_dow( 'Mon tue 3am', ['mon','tue'], ['3am'] )

        assert_recurse_dow( 'Mon, tue, 3am', ['mon','tue'], ['3am'] )

        assert_recurse_dow( 'Mon, WEDNESDAY, 3am, fri',
                            ['mon','wed'], ['3am','fri'] )

        assert_recurse_dow( 'Sunday', ['sun'], [] )

        assert_recurse_dow( 'Sunday Monday', ['sun','mon'], [] )

        assert_recurse_dow( 'Mon 3 am', ['mon'], ['3 am'] )

        assert_recurse_dow( 'Mon, 3 am', ['mon'], ['3 am'] )

        assert_recurse_dow( 'Mon, 3am', ['mon'], ['3am'] )

    def test_next_trigger_time_function(self):
        ""
        hr = 60*60
        curtm = time.time()
        midnight = epoch_at_midnight( curtm )
        midnight2 = epoch_at_midnight( midnight+26*60*60 )

        # some am/pm time-of-days
        tm = trigger.next_trigger_time( '1am', midnight )
        assert tm != None and tm == (midnight+hr)
        tm = trigger.next_trigger_time( '1am', midnight+hr )
        assert tm != None and tm == (midnight+hr)
        tm = trigger.next_trigger_time( '1am', midnight+2*hr )
        assert tm != None and tm == (midnight2+hr)

        #print3( time.ctime(tm), time.ctime(midnight+13*hr+hr/2) )

        # military time-of-day
        tm = trigger.next_trigger_time( '13:30', midnight+hr+hr/2 )
        assert tm != None and tm == (midnight+13*hr+hr/2)
        tm = trigger.next_trigger_time( '13:30', midnight+13*hr+hr/2 )
        assert tm != None and tm == (midnight+13*hr+hr/2)
        tm = trigger.next_trigger_time( '13:30', midnight+14*hr+hr/2 )
        assert tm != None and tm == (midnight2+13*hr+hr/2)
        
        # more than one time-of-day given
        tm = trigger.next_trigger_time( '2am, 4am', midnight+1*hr )
        assert tm != None and tm == (midnight+2*hr)
        tm = trigger.next_trigger_time( '4am, 2am', midnight+1*hr )
        assert tm != None and tm == (midnight+2*hr)
        tm = trigger.next_trigger_time( '2am, 4am', midnight+2*hr )
        assert tm != None and tm == (midnight+2*hr)
        tm = trigger.next_trigger_time( '2am, 4am', midnight+3*hr )
        assert tm != None and tm == (midnight+4*hr)
        tm = trigger.next_trigger_time( '2am, 4am', midnight+4*hr )
        assert tm != None and tm == (midnight+4*hr)
        tm = trigger.next_trigger_time( '2am, 4am', midnight+5*hr )
        assert tm != None and tm == (midnight2+2*hr)

    def test_next_trigger_time_function_using_DOW_and_plus_a_time(self):
        ""
        hr = 60*60
        curtm = time.time()
        midnight = epoch_at_midnight( curtm )
        midnight2 = epoch_at_midnight( midnight+26*60*60 )
        dow = day_of_week( curtm )

        tm = trigger.next_trigger_time( dow, midnight+0*hr )
        assert tm != None and tm == (midnight+0*hr+5)
        tm = trigger.next_trigger_time( dow[:3].lower(), midnight+0*hr )
        assert tm != None and tm == (midnight+0*hr+5)
        tm = trigger.next_trigger_time( dow[:3].lower(), midnight+1*hr )
        assert tm == None

        dow2 = day_of_week( midnight+26*60*60 )
        tm = trigger.next_trigger_time( dow2, midnight+23*hr )
        assert tm != None and tm == (midnight2+0*hr+5)
        tm = trigger.next_trigger_time( dow+' '+dow2, midnight+23*hr )
        assert tm != None and tm == (midnight2+0*hr+5)

        tm = trigger.next_trigger_time( dow+' '+dow2+' 6am', midnight+1*hr )
        assert tm != None and tm == (midnight+6*hr)
        tm = trigger.next_trigger_time( dow+' '+dow2+' 6am', midnight+10*hr )
        #print3( 'tm', time.ctime(tm) )
        assert tm != None and tm == (midnight2+6*hr)

        # more than one day plus more than one time
        midprev = epoch_at_midnight( midnight-22*60*60 )
        dowprev = day_of_week( midnight-22*60*60 )
        tm = trigger.next_trigger_time( dowprev+' '+dow+' 6am', midnight+1*hr )
        assert tm != None and tm == (midnight+6*hr)
        tm = trigger.next_trigger_time( dowprev+' '+dow+' 6am', midnight+7*hr )
        assert tm == None
        tm = trigger.next_trigger_time( dowprev+' '+dow+' 1:30, 6am', midnight+2*hr )
        assert tm != None and tm == (midnight+6*hr)
        tm = trigger.next_trigger_time( dowprev+' '+dow+' 1:30, 6am', midnight+1*hr )
        assert tm != None and tm == (midnight+1.5*hr)
        tm = trigger.next_trigger_time( dowprev+' '+dow+' 1:30, 6am', midnight+7*hr )
        assert tm == None

    def test_next_trigger_time_errors(self):
        ""
        hr = 60*60
        curtm = time.time()
        midnight = epoch_at_midnight( curtm )
        midnight2 = epoch_at_midnight( midnight+26*60*60 )
        dow = day_of_week( curtm )
        dow2 = day_of_week( midnight+26*60*60 )

        bad_next_trigger_time( '1mm', midnight )

        bad_next_trigger_time( dow+' 6am '+dow2, midnight+5*hr )

        bad_next_trigger_time( '6am '+dow, midnight+5*hr )

    def test_hourly_trigger(self):
        ""
        hr = 60*60
        curtm = time.time()
        midnight = epoch_at_midnight( curtm )
        midnight2 = epoch_at_midnight( midnight+26*60*60 )
        dow = day_of_week( curtm )

        tm = trigger.next_trigger_time( 'hourly', midnight+1*hr )
        assert tm != None and tm == (midnight+1*hr)
        tm = trigger.next_trigger_time( 'hourly', midnight+1*hr+5 )
        assert tm != None and tm == (midnight+2*hr)
        tm = trigger.next_trigger_time( 'hourly', midnight+1*hr+59*60 )
        assert tm != None and tm == (midnight+2*hr)

        tm = trigger.next_trigger_time( 'hourly', midnight+23*hr )
        assert tm != None and tm == (midnight+23*hr)
        tm = trigger.next_trigger_time( 'hourly', midnight+23*hr+10 )
        assert tm != None and tm == midnight2

        tm = trigger.next_trigger_time( 'hourly', midnight+23*hr+10 )
        assert tm != None and tm == (midnight2)

        tm = trigger.next_trigger_time( 'hourly 5', midnight+1*hr )
        assert tm != None and tm == (midnight+1*hr+5*60)
        tm = trigger.next_trigger_time( 'hourly, 5', midnight+1*hr )
        assert tm != None and tm == (midnight+1*hr+5*60)
        tm = trigger.next_trigger_time( 'hourly, 5', midnight+1*hr+10*60 )
        assert tm != None and tm == (midnight+2*hr+5*60)

        tm = trigger.next_trigger_time( 'hourly 5, 35', midnight+1*hr )
        assert tm != None and tm == (midnight+1*hr+5*60)
        tm = trigger.next_trigger_time( 'hourly 5, 35', midnight+1*hr+10*60 )
        assert tm != None and tm == (midnight+1*hr+35*60)
        tm = trigger.next_trigger_time( 'hourly 5, 35', midnight+1*hr+40*60 )
        assert tm != None and tm == (midnight+2*hr+5*60)

    def test_monthly_trigger(self):
        ""
        hr = 60*60
        curtm = time.time()
        m1 = epoch_at_month_start( curtm )
        m2 = epoch_at_month_start( m1 + 45*24*hr + 10*hr )

        tm = trigger.next_trigger_time( 'monthly', m1+10*hr )
        assert tm != None and tm == (m2+5)
        tm = trigger.next_trigger_time( 'monthly', m1+1 )
        assert tm != None and tm == (m1+5)

        tm = trigger.next_trigger_time( 'monthly 6am', m1+4*hr )
        assert tm != None and tm == (m1+6*hr)
        tm = trigger.next_trigger_time( 'monthly 6am', m1+10*hr )
        assert tm != None and tm == (m2+6*hr)

        dow1 = day_of_week( m1 + 2*hr )[:3]
        dow2 = day_of_week( m1 + 30*hr )[:3]
        midnight2 = epoch_at_midnight( m1 + 30*hr )  # midnight on dow2
        tm = trigger.next_trigger_time( 'monthly '+dow1, m1+1 )
        assert tm != None and tm == (m1+5)
        tm = trigger.next_trigger_time( 'monthly '+dow2, m1+10*hr )
        assert tm != None and tm == (midnight2+5)
        tm = trigger.next_trigger_time( 'monthly '+dow1, m1+10*hr )
        assert tm != None and tm >= (m2+5)

        tm = trigger.next_trigger_time( 'monthly '+dow1+' 6am', m1+1 )
        assert tm != None and tm == (m1+6*hr)
        tm = trigger.next_trigger_time( 'monthly '+dow2+' 6am', m1+10*hr )
        assert tm != None and tm >= (midnight2+6*hr)
        tm = trigger.next_trigger_time( 'monthly '+dow1+' 6am', m1+10*hr )
        assert tm != None and tm >= (m2+6*hr)


class logging_tests( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

    def test_log_print_and_read_functions(self):
        ""
        redir = trigger.Redirect( 'testlog.txt' )
        trigger.printlog( 'msgtype', 'arg2=value', 42 )
        redir.close()

        assert_log_lines( 'testlog.txt',
                          [ 10, 'msgtype', 'arg2=value', '42' ] )

    def test_multiple_log_print_and_read_functions(self):
        ""
        redir = trigger.Redirect( 'testlog.txt' )
        trigger.printlog( 'msgtype', 'arg2=value', 42 )
        trigger.printlog( 'foobar', 'so that happened' )
        redir.close()

        assert_log_lines( 'testlog.txt',
                          [ 10, 'msgtype', 'arg2=value', '42' ],
                          [ 10, 'foobar', 'so that happened' ] )

    def test_log_file_with_extra_lines(self):
        ""
        redir = trigger.Redirect( 'testlog.txt' )
        trigger.printlog( 'msgtype', 'arg2=value', 42 )
        print3( 'this is some\n    output to try to confuse\nthe reader\n' )
        trigger.printlog( 'foobar', 'so that happened' )
        print3( '['+time.ctime()+'] 3 this is just mean' )
        trigger.printlog( 'zigzag', 'ok then' )
        redir.close()

        assert_log_lines( 'testlog.txt',
                          [ 10, 'msgtype', 'arg2=value', '42' ],
                          [ 10, 'foobar', 'so that happened' ],
                          [ 10, 'zigzag', 'ok then' ] )

    def test_when_log_file_has_extra_lines_on_the_end(self):
        ""
        redir = trigger.Redirect( 'testlog.txt' )
        trigger.printlog( 'msgtype', 'arg2=value', 42 )
        trigger.printlog( 'foobar', 'so that happened' )
        print3( '['+time.ctime()+'] 3 this is just mean' )
        redir.close()

        assert_log_lines( 'testlog.txt',
                          [ 10, 'msgtype', 'arg2=value', '42' ],
                          [ 10, 'foobar', 'so that happened' ] )


class parsing_job_files( trigutil.trigTestCase ):

    def test_parse_job_trigger(self):
        ""
        util.writefile( 'job_foo.py', """

            # JOB TRIGGER: """+string_time( time.time() )+"""

            import os, sys
            """ )
        time.sleep(1)

        trigL,loghandling = trigger.parse_trigger_specifications( 'job_foo.py' )

        assert len( trigL ) == 1
        assert len( loghandling ) == 0

    def test_parse_job_log_expiration_by_count(self):
        ""
        util.writefile( 'job_foo.py', """

            # JOB TRIGGER: """+string_time( time.time() )+"""
            # JOB LOG HANDLING: count=10

            import os, sys
            """ )
        time.sleep(1)

        trigL,loghandling = trigger.parse_trigger_specifications( 'job_foo.py' )

        assert len( trigL ) == 1
        assert loghandling == { 'count':10 }

    def test_parse_job_log_expiration_by_age(self):
        ""
        util.writefile( 'job_foo.py', """

            # JOB TRIGGER: """+string_time( time.time() )+"""
            # JOB LOG HANDLING: age=10days

            import os, sys
            """ )
        util.writefile( 'job_bar.py', """

            # JOB TRIGGER: """+string_time( time.time() )+"""
            # JOB LOG HANDLING: age=10 months

            import os, sys
            """ )
        util.writefile( 'job_baz.py', """

            # JOB TRIGGER: """+string_time( time.time() )+"""
            # JOB LOG HANDLING: age = 1year

            import os, sys
            """ )
        time.sleep(1)

        trigL,loghandling = trigger.parse_trigger_specifications( 'job_foo.py' )
        age = loghandling['age']
        assert abs( time.time() - 10*24*60*60 - age ) < 60*60

        trigL,loghandling = trigger.parse_trigger_specifications( 'job_bar.py' )
        age = loghandling['age']
        assert abs( time.time() - 10*30*24*60*60 - age ) < 60*60

        trigL,loghandling = trigger.parse_trigger_specifications( 'job_baz.py' )
        age = loghandling['age']
        assert abs( time.time() - 365*24*60*60 - age ) < 60*60

    def test_remove_job_logs_by_count(self):
        ""
        logs = abspath('logs')
        util.writefile( 'logs/job_foo.py_1/log.txt', 'foo1' )
        util.writefile( 'logs/job_foo.py_2', 'foo2' )
        util.writefile( 'logs/job_foo.py_3/log.txt', 'foo3' )
        util.writefile( 'logs/job_bar.py_3/log.txt', 'bar3' )
        time.sleep(1)

        trigger.remove_old_job_logs( logs, 'job_foo.py', { 'count':5 } )
        assert len( glob.glob( 'logs/*' ) ) == 4

        trigger.remove_old_job_logs( logs, 'job_foo.py', { 'count':3 } )
        assert len( glob.glob( 'logs/*' ) ) == 4

        trigger.remove_old_job_logs( logs, 'job_foo.py', { 'count':2 } )
        assert len( glob.glob( 'logs/*' ) ) == 3
        assert len( glob.glob( 'logs/job_foo*' ) ) == 2

        trigger.remove_old_job_logs( logs, 'job_foo.py', { 'count':1 } )
        assert len( glob.glob( 'logs/*' ) ) == 2
        assert len( glob.glob( 'logs/job_foo*' ) ) == 1

        trigger.remove_old_job_logs( logs, 'job_foo.py', { 'count':0 } )
        assert len( glob.glob( 'logs/*' ) ) == 2
        assert len( glob.glob( 'logs/job_foo*' ) ) == 1

        trigger.remove_old_job_logs( logs, 'job_foo.py', { 'count':-5 } )
        fL = glob.glob( 'logs/*' )
        fL.sort()
        assert basename( fL[0] ) == 'job_bar.py_3'
        assert basename( fL[1] ) == 'job_foo.py_3'

    def test_remove_job_logs_by_age(self):
        ""
        tm = time.time()
        logs = abspath('logs')

        util.writefile( 'logs/job_foo.py_1/log.txt', 'foo1' )
        os.utime( 'logs/job_foo.py_1', (tm-24*60*60,tm-24*60*60) )

        util.writefile( 'logs/job_foo.py_2', 'foo2' )
        os.utime( 'logs/job_foo.py_2', (tm-12*60*60,tm-12*60*60) )

        util.writefile( 'logs/job_foo.py_3/log.txt', 'foo3' )
        os.utime( 'logs/job_foo.py_3', (tm-6*60*60,tm-6*60*60) )

        util.writefile( 'logs/job_bar.py_3/log.txt', 'bar3' )
        os.utime( 'logs/job_bar.py_3', (tm,tm) )

        time.sleep(1)

        trigger.remove_old_job_logs( logs, 'job_foo.py', { 'age':tm-48*60*60 } )
        assert len( glob.glob( 'logs/*' ) ) == 4

        trigger.remove_old_job_logs( logs, 'job_foo.py', { 'age':tm-18*60*60 } )
        assert len( glob.glob( 'logs/*' ) ) == 3

        trigger.remove_old_job_logs( logs, 'job_foo.py', { 'age':tm-8*60*60 } )
        assert len( glob.glob( 'logs/*' ) ) == 2
        assert os.path.exists( 'logs/job_foo.py_3' )
        assert os.path.exists( 'logs/job_bar.py_3' )

        trigger.remove_old_job_logs( logs, 'job_foo.py', { 'age':tm+60 } )
        assert len( glob.glob( 'logs/*' ) ) == 1
        assert os.path.exists( 'logs/job_bar.py_3' )

    def test_remove_path_function(self):
        ""
        util.writefile( 'sumpin', 'else' )
        os.symlink( 'sumpin', 'something' )
        time.sleep(1)

        assert os.path.isfile( 'sumpin' )
        assert os.path.isfile( 'something' )

        trigger.remove_path( 'something' )
        assert not os.path.exists( 'something' )
        assert os.path.isfile( 'sumpin' )

        self.assertRaises( trigger.TriggerError, trigger.remove_path, 'asdfssjdk' )

    def create_fake_log_file(self, loc, jobfile, age):
        ""
        ftm = time.time()-age
        date = time.strftime( "%a_%b_%d_%Y_%H:%M:%S_%Z", time.localtime(ftm) )
        fn = trigger.make_root_log_name( loc, jobfile )+date
        util.writefile( fn+'/log.txt', "my fake log content" )
        os.utime( fn, (ftm,ftm) )

    def test_remove_old_logs_integration(self):
        ""
        curtm = time.time()

        loc = abspath( 'logs' )

        jfile = abspath( 'job_foo.py' )
        self.create_fake_log_file( loc, jfile, 73 )
        self.create_fake_log_file( loc, jfile, 2*73 )
        util.writefile( jfile, """

            # JOB TRIGGER: """+string_time( curtm+3 )+"""
            # JOB LOG HANDLING: count=1

            import os, sys
            """ )

        jfile = abspath( 'job_bar.py' )
        self.create_fake_log_file( loc, jfile, 36*60*60 )
        util.writefile( jfile, """

            # JOB TRIGGER: """+string_time( curtm+3 )+"""
            # JOB LOG HANDLING: age=1 day

            import os, sys
            """ )
        time.sleep(1)

        cmd = localpy+' '+trigfile + ' -g 2 -Q 7 -r '+loc
        x,out = util.runcmd( cmd )
        assert not out.strip()

        fL = glob.glob( loc+'/job_foo*' )
        assert len(fL) == 2

        fL = glob.glob( loc+'/job_bar*' )
        assert len(fL) == 1

    def test_job_handling_parse_specification_errors(self):
        ""
        util.writefile( 'job_foo.py', """

            # JOB TRIGGER: """+string_time( time.time() )+"""
            # JOB LOG HANDLING: count=abc
            import os, sys
            """ )
        util.writefile( 'job_bar.py', """

            # JOB TRIGGER: """+string_time( time.time() )+"""
            # JOB LOG HANDLING: age
            import os, sys
            """ )
        util.writefile( 'job_baz.py', """

            # JOB TRIGGER: """+string_time( time.time() )+"""
            # JOB LOG HANDLING: = 1 day
            import os, sys
            """ )
        util.writefile( 'job_flop.py', """

            # JOB TRIGGER: """+string_time( time.time() )+"""
            # JOB LOG HANDLING: age=5
            import os, sys
            """ )
        util.writefile( 'job_dip.py', """

            # JOB TRIGGER: """+string_time( time.time() )+"""
            # JOB LOG HANDLING: age=5yr
            import os, sys
            """ )
        time.sleep(1)

        self.assertRaises( trigger.TriggerError,
                trigger.parse_trigger_specifications, 'job_foo.py' )

        self.assertRaises( trigger.TriggerError,
                trigger.parse_trigger_specifications, 'job_bar.py' )

        self.assertRaises( trigger.TriggerError,
                trigger.parse_trigger_specifications, 'job_baz.py' )

        self.assertRaises( trigger.TriggerError,
                trigger.parse_trigger_specifications, 'job_flop.py' )

        self.assertRaises( trigger.TriggerError,
                trigger.parse_trigger_specifications, 'job_dip.py' )


class running_jobs( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

    def test_running_a_job(self):
        ""
        curtm = time.time()

        write_job_file( 'job_foo.py', 'foo', curtm+3 )

        os.mkdir( 'logs' )
        loc = os.path.abspath( 'logs' )
        
        cmd = localpy+' '+trigfile + ' -g 2 -Q 7 -r '+loc
        x,out = util.runcmd( cmd )
        assert not out.strip()
        
        ldir,joblog = job_log_path( 'logs', 'job_foo.py' )
        loglines = readlog( 'logs/trigger.log' )

        # check startup info
        startD = log_line_dict( logfind( 'startup', loglines ) )
        assert abs( time.time() - startD.get('date') ) < 20
        assert startD['mach'] and startD['pid'] and startD['argv']

        # check launch info
        launchD = log_line_dict( logfind( 'launch', loglines ) )
        assert launchD['date'] >= startD['date']
        assert os.path.samefile( launchD['file'], 'job_foo.py' )
        assert os.path.samefile( launchD['logdir'], ldir )

        # check finish message
        finishD = log_line_dict( logfind( 'finish', loglines ) )
        assert finishD['date'] >= launchD['date']
        assert finishD['exit'] == '0'
        assert os.path.samefile( finishD['file'], 'job_foo.py' )
        assert os.path.samefile( finishD['logdir'], ldir )

        assert_job_log_content( joblog, pwd=ldir, line_value='hello foo' )

    def test_running_two_jobs_at_the_same_time(self):
        ""
        curtm = time.time()

        write_job_file( 'job_foo.py', 'foo', curtm+3 )
        write_job_file( 'job_bar.py', 'bar', curtm+3 )

        os.mkdir( 'logs' )
        loc = os.path.abspath( 'logs' )
        
        cmd = localpy+' '+trigfile + ' -g 2 -Q 7 -r '+loc
        x,out = util.runcmd( cmd )
        assert not out.strip()

        foodir,foolog = job_log_path( 'logs', 'job_foo.py' )
        bardir,barlog = job_log_path( 'logs', 'job_bar.py' )
        loglines = readlog( 'logs/trigger.log' )

        t1 = os.path.basename( foodir ).split( 'job_foo.py_', 1 )[1]
        t2 = os.path.basename( bardir ).split( 'job_bar.py_', 1 )[1]
        assert t1 != t2  # job time should not be the same

        # check launch info
        D1 = log_line_dict( logfind( 'launch', loglines, 0 ) )
        D2 = log_line_dict( logfind( 'launch', loglines, 1 ) )
        assert D1['date'] != D2['date']

        # check finish message
        D1 = log_line_dict( logfind( 'finish', loglines, 0 ) )
        D2 = log_line_dict( logfind( 'finish', loglines, 1 ) )
        assert D1['exit'] == '0' and D2['exit'] == '0'

        assert len( util.grepfiles( 'hello foo', foolog ) ) == 1
        assert len( util.grepfiles( 'hello bar', barlog ) ) == 1

    def test_that_newly_created_job_files_will_get_run(self):
        ""
        curtm = time.time()
        write_job_file( 'job_foo.py', 'foo', curtm+2,
                        extra_line='time.sleep(11)' )

        os.mkdir( 'logs' )
        loc = os.path.abspath( 'logs' )

        cmd = localpy+' '+trigfile + ' -g 3 -Q 15 -r '+loc
        bg = Background( cmd, outfile='bg1.log' )

        time.sleep(4)

        curtm = time.time()
        write_job_file( 'job_bar.py', 'bar', curtm+2 )
        
        bg.wait()
        assert not util.readfile( 'bg1.log' ).strip()

        foodir,foolog = job_log_path( 'logs', 'job_foo.py' )
        bardir,barlog = job_log_path( 'logs', 'job_bar.py' )
        loglines = readlog( 'logs/trigger.log' )

        # check launch info
        fooD = log_line_dict( logfind( 'launch', loglines, 0 ) )
        barD = log_line_dict( logfind( 'launch', loglines, 1 ) )
        assert barD['date'] - fooD['date'] >= 4
        assert os.path.basename( fooD['file'] ) == 'job_foo.py'
        assert os.path.basename( barD['file'] ) == 'job_bar.py'

        # check finish
        barD = log_line_dict( logfind( 'finish', loglines, 0 ) )
        fooD = log_line_dict( logfind( 'finish', loglines, 1 ) )
        assert barD['date'] < fooD['date']
        assert fooD['exit'] == '0' and barD['exit'] == '0'
        assert os.path.basename( fooD['file'] ) == 'job_foo.py'
        assert os.path.basename( barD['file'] ) == 'job_bar.py'

    def test_job_location_specifications(self):
        ""
        curtm = time.time()

        write_job_file( 'dir1/job_foo.py', 'foo', curtm+3 )
        write_job_file( 'dir2/bar.py', 'bar', curtm+3 )
        write_job_file( 'dir2/baz.py', 'baz', curtm+6 )

        os.mkdir( 'logs' )
        loc = os.path.abspath( 'logs' )
        
        cmd = localpy+' '+trigfile + \
                ' -g 2 -Q 10 -r logs '+os.getcwd() + \
                ' dir1 dir2/*.py'
        x,out = util.runcmd( cmd )
        assert not out.strip()

        loglines = readlog( 'logs/trigger.log' )

        D1 = log_line_dict( logfind( 'launch', loglines, 0 ) )
        D2 = log_line_dict( logfind( 'launch', loglines, 1 ) )
        D3 = log_line_dict( logfind( 'launch', loglines, 2 ) )
        assert D1['file'] != D2['file'] and D2['file'] != D3['file']

        assert os.path.basename( D3['file'] ) == 'baz.py'
        assert os.path.dirname( D3['file'] ).endswith( 'dir2' )

    def write_job_with_trigger_error(self, filename, trigtime):
        ""
        util.writefile( filename, """
            # JOB TRIGGER: junk """+string_time( trigtime )+"""
            import os, sys
            sys.stdout.write( 'PWD: ' + os.getcwd() + os.linesep )
            sys.stdout.write( 'hello foo' + os.linesep )
            sys.stdout.flush()
            """ )

    def test_how_an_error_in_JOB_TRIGGER_syntax_is_handled(self):
        ""
        curtm = time.time()

        self.write_job_with_trigger_error( 'job_foo.py', curtm+3 )

        # set the file date back a little to avoid time granularity issues
        t = time.time() - 59
        os.utime( 'job_foo.py', (t,t) )

        os.mkdir( 'logs' )
        loc = os.path.abspath( 'logs' )

        cmd = localpy+' '+trigfile + ' -g 2 -Q 7 -r '+loc
        x,out = util.runcmd( cmd )
        print3( out )
        assert not out.strip()

        lines = readlog( 'logs/trigger.log' )

        # expect exactly one exception log line
        assert logfind( 'exception', lines, 0 ) != None
        assert logfind( 'exception', lines, 1 ) == None

    def test_error_print_frequency_for_an_error_in_JOB_TRIGGER_syntax(self):
        ""
        curtm = time.time()

        self.write_job_with_trigger_error( 'job_foo.py', curtm+3 )

        # set the file date back a little to avoid time granularity issues
        t = time.time() - 59
        os.utime( 'job_foo.py', (t,t) )

        os.mkdir( 'logs' )
        loc = os.path.abspath( 'logs' )

        secs = str( 6./(60.0*60.0) )
        cmd = localpy+' '+trigfile + ' -g 2 -Q 10 -E '+secs+' -r '+loc
        x,out = util.runcmd( cmd )
        assert not out.strip()

        lines = readlog( 'logs/trigger.log' )

        # expect exactly one exception log line
        L0 = logfind( 'exception', lines, 0 )
        assert L0 != None
        L1 = logfind( 'exception', lines, 1 )
        assert L1 != None
        assert logfind( 'exception', lines, 2 ) == None
        assert L0[0] + 4 < L1[0]

    def test_multiple_job_triggers_in_the_same_file(self):
        ""
        curtm = time.time()

        write_job_file( 'job_foo.py', 'foo', curtm-10, curtm+3 )
        write_job_file( 'job_bar.py', 'bar', curtm-10, curtm-20 )

        os.mkdir( 'logs' )
        loc = os.path.abspath( 'logs' )
        
        cmd = localpy+' '+trigfile + ' -g 2 -Q 7 -r '+loc
        x,out = util.runcmd( cmd )
        assert not out.strip()
        
        lines = readlog( 'logs/trigger.log' )

        # job_foo should launch exactly once, but not job_bar
        t1,s,f1,d1 = loglaunch( lines, 0 )
        assert os.path.basename(f1).startswith( 'job_foo' )
        assert logfind( 'launch', lines, 1 ) == None
        tm,x,f,d = logfinish( lines, 0 )
        assert os.path.basename(f1).startswith( 'job_foo' )
        assert logfind( 'finish', lines, 1 ) == None

    def test_error_launching_trigger_cuz_log_directory_not_given(self):
        ""
        curtm = time.time()

        #os.mkdir( 'logs' )
        loc = os.path.abspath( 'logs' )
        
        cmd = localpy+' '+trigfile + ' -g 2 -Q 6'
        x,out = util.runcmd( cmd, raise_on_error=False )

        assert time.time() - curtm < 5
        assert len( util.greplines( 'Traceback', out ) ) > 0

    def test_error_launching_trigger_cuz_log_directory_does_not_exist(self):
        ""
        curtm = time.time()

        #os.mkdir( 'logs' )
        loc = os.path.abspath( 'logs' )

        curtm = time.time()
        cmd = localpy+' '+trigfile + ' -g 2 -Q 6 -r '+loc
        x,out = util.runcmd( cmd, raise_on_error=False )

        assert time.time() - curtm < 5
        assert len( util.greplines( 'Traceback', out ) ) > 0


class trigger_startup( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

    def test_a_second_startup_should_preserve_the_log_file(self):
        ""
        curtm = time.time()
        write_job_file( 'job_foo.py', 'foo', curtm+2 )

        jf = os.path.abspath( 'job_foo.py' )

        os.mkdir( 'logs' )
        loc = os.path.abspath( 'logs' )
        
        cmd = localpy+' '+trigfile + ' -g 2 -Q 6 -r '+loc
        x,out = util.runcmd( cmd )
        assert not out.strip()
        
        lines1 = readlog( 'logs/trigger.log' )
        
        L = logfind( 'startup', lines1, 0 ) ; assert L != None
        L = logfind( 'startup', lines1, 1 ) ; assert L == None
        L = logfind( 'launch', lines1, 0 ) ; assert L != None
        L = logfind( 'launch', lines1, 1 ) ; assert L == None
        L = logfind( 'finish', lines1, 0 ) ; assert L != None
        L = logfind( 'finish', lines1, 1 ) ; assert L == None

        curtm = time.time()
        write_job_file( 'job_bar.py', 'bar', curtm+2 )

        cmd = localpy+' '+trigfile + ' -g 2 -Q 6 -r '+loc
        x,out = util.runcmd( cmd )
        assert not out.strip()
        
        lines2 = readlog( 'logs/trigger.log' )

        # first part of the log file is the same
        assert lines1 == lines2[:len(lines1)]

        L = logfind( 'startup', lines2, 0 ) ; assert L != None
        L = logfind( 'startup', lines2, 1 ) ; assert L != None
        L = logfind( 'startup', lines2, 2 ) ; assert L == None
        L = logfind( 'launch', lines2, 0 ) ; assert L != None
        L = logfind( 'launch', lines2, 1 ) ; assert L != None
        L = logfind( 'launch', lines2, 2 ) ; assert L == None
        L = logfind( 'finish', lines2, 0 ) ; assert L != None
        L = logfind( 'finish', lines2, 1 ) ; assert L != None
        L = logfind( 'finish', lines2, 2 ) ; assert L == None

    def test_two_trigger_startups_in_different_directories_is_ok(self):
        ""
        curtm = time.time()
        write_job_file( 'jobs1/job_foo.py', 'foo', curtm+2 )

        os.mkdir( 'logs1' )
        loc1 = os.path.abspath( 'logs1' )
        os.mkdir( 'logs2' )
        loc2 = os.path.abspath( 'logs2' )

        os.chdir( 'jobs1' )    
        cmd = localpy+' '+trigfile + ' -g 2 -Q 6 -r '+loc1
        bg1 = Background( cmd, outfile='bg1.log' )

        os.chdir( '..' )
        time.sleep(1)

        curtm = time.time()
        write_job_file( 'jobs2/job_bar.py', 'bar', curtm+2 )

        os.chdir( 'jobs2' )    
        cmd = localpy+' '+trigfile + ' -g 2 -Q 6 -r '+loc2
        bg2 = Background( cmd, outfile='bg2.log' )

        x = bg1.wait() ; assert x == 0
        x = bg2.wait() ; assert x == 0

        # the two processes should run concurrently
        assert time.time() - curtm < 10

        os.chdir( '..' )

        lines1 = readlog( 'logs1/trigger.log' )
        L = logfind( 'startup', lines1, 0 ) ; assert L != None
        L = logfind( 'startup', lines1, 1 ) ; assert L == None
        L = logfind( 'launch', lines1, 0 ) ; assert L != None
        L = logfind( 'launch', lines1, 1 ) ; assert L == None
        L = logfind( 'finish', lines1, 0 ) ; assert L != None
        L = logfind( 'finish', lines1, 1 ) ; assert L == None
        tm,x,f,d = logfinish( lines1 )
        assert os.path.basename(f) == 'job_foo.py'

        lines2 = readlog( 'logs2/trigger.log' )
        L = logfind( 'startup', lines2, 0 ) ; assert L != None
        L = logfind( 'startup', lines2, 1 ) ; assert L == None
        L = logfind( 'launch', lines2, 0 ) ; assert L != None
        L = logfind( 'launch', lines2, 1 ) ; assert L == None
        L = logfind( 'finish', lines2, 0 ) ; assert L != None
        L = logfind( 'finish', lines2, 1 ) ; assert L == None
        tm,x,f,d = logfinish( lines2 )
        assert os.path.basename(f) == 'job_bar.py'

    def test_a_second_launch_should_occur_if_first_process_exits(self):
        ""
        os.mkdir( 'logs' )
        loc = os.path.abspath( 'logs' )

        cmd = localpy+' '+trigfile + ' -g 1 -Q 5 -r '+loc
        x,out = util.runcmd( cmd )
        assert not out.strip()

        time.sleep(1)

        x,out = util.runcmd( cmd )
        assert not out.strip()

        lines = readlog( 'logs/trigger.log' )

        # two startup messages should be in the log file
        L = logfind( 'startup', lines, 0 )
        assert L != None
        L = logfind( 'startup', lines, 1 )
        assert L != None


class misc_tests( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

    def test_handling_of_a_hang_when_reading_a_job_file(self):
        ""
        curtm = time.time()
        write_job_file( 'job_foo.py', 'foo', curtm+2,
                        extra_line='time.sleep(15)' )

        os.mkdir( 'logs' )
        loc = os.path.abspath( 'logs' )

        cmd = localpy+' '+trigfile + ' -g 3 -Q 60 -r '+loc
        bg = Background( cmd, outfile='bg1.log' )

        time.sleep(4)

        # add a special string to cause a hang
        util.writefile( 'job_bar.py', """
            #TRIGGER_TEST_HANG_READ=60
            # JOB TRIGGER: """+string_time( time.time()+2 )+"""
            """ )

        bg.wait()
        fp = open( 'bg1.log', 'r' )
        s = fp.read() ; fp.close()
        #print3( s )
        assert not s.strip()

        # a timeout causes trigger.py to exit
        assert time.time() - curtm < 20

        lines = readlog( 'logs/trigger.log' )

        # a timeout should still finish existing jobs
        L = logfind( 'launch', lines, 0 ) ; assert L != None
        L = logfind( 'launch', lines, 1 ) ; assert L == None
        L = logfind( 'exception', lines, 0 ) ; assert L != None
        L = logfind( 'exception', lines, 1 ) ; assert L == None
        L = logfind( 'finish', lines, 0 ) ; assert L != None
        L = logfind( 'finish', lines, 1 ) ; assert L == None

    def test_a_job_can_import_the_python_utilities(self):
        ""
        curtm = time.time()

        util.writefile( 'job_foo.py', """
            # JOB TRIGGER: """+string_time( curtm+3 )+"""
            import os, sys
            import command
            import runjob
            fp = open( 'success', 'w' ) ; fp.close()
            """ )

        os.mkdir( 'logs' )
        loc = os.path.abspath( 'logs' )

        cmd = localpy+' '+trigfile + ' -g 2 -Q 7 -r '+loc
        x,out = util.runcmd( cmd )
        #os.system( cmd )
        assert not out.strip()

        lines = readlog( 'logs/trigger.log' )

        jf = os.path.abspath( 'job_foo.py' )

        # get the log directory for the job
        ldir = util.globfile( 'logs/job_foo.py_*' )
        assert os.path.isdir( ldir )
        joblog = os.path.join( ldir, 'log.txt' )
        assert os.path.exists( joblog )

        markerfile = os.path.join( ldir, 'success' )
        assert os.path.exists( markerfile )


class permissions_tests( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

    def test_group_option_sets_the_log_dir_and_file_group_name(self):
        ""
        for grp in util.probe_for_two_different_groups():

            util.rmallfiles()

            curtm = time.time()

            util.writefile( 'job_foo.py', """
                # JOB TRIGGER: """+string_time( curtm+3 )+"""
                fp = open( 'success', 'w' ) ; fp.close()
                """ )

            os.mkdir( 'logs' )
            loc = os.path.abspath( 'logs' )
            time.sleep(1)

            cmd = localpy+' '+trigfile + ' --group '+grp+' -g 2 -Q 7 -r '+loc
            x,out = util.runcmd( cmd )
            assert not out.strip()

            dname = util.globfile( 'logs/job_foo.py_*' )
            assert util.get_file_group( dname ) == grp

            fname = util.globfile( 'logs/job_foo.py_*/log.txt' )
            assert util.get_file_group( fname ) == grp

    def test_group_option_relaxes_the_group_umask(self):
        ""
        curtm = time.time()

        util.writefile( 'job_foo.py', """
            # JOB TRIGGER: """+string_time( curtm+3 )+"""
            fp = open( 'success', 'w' ) ; fp.close()
            """ )

        os.mkdir( 'logs' )
        loc = os.path.abspath( 'logs' )
        time.sleep(1)

        grp1,grp2 = util.probe_for_two_different_groups()

        origmask = os.umask( 0o077 )
        try:
            cmd = localpy+' '+trigfile + ' --group '+grp1+' -g 2 -Q 7 -r '+loc
            x,out = util.runcmd( cmd )
            assert not out.strip()

            dname = util.globfile( 'logs/job_foo.py_*' )
            assert util.has_group_read( dname )
            assert not util.has_group_write( dname )
            assert util.has_group_execute( dname )

            fname = util.globfile( 'logs/job_foo.py_*/log.txt' )
            assert util.has_group_read( fname )
            assert not util.has_group_write( fname )
            assert not util.has_group_execute( fname )

        finally:
            os.umask( origmask )


#######################################################################

def write_job_file( filename, jobname, trigger_time,
                    trigger_time2=None,
                    extra_line=None,
                    trigger_log_lifetime=None ):
    ""
    content = """
        # JOB TRIGGER: """+string_time( trigger_time )+"""
        """
    if trigger_time2:
        content += """# JOB TRIGGER: """+string_time( trigger_time2 )+"""
        """
    if trigger_log_lifetime:
        content += """# JOB LOG LIFETIME: """+trigger_log_lifetime +"""
        """
    content += """import os, sys, time
        sys.stdout.write( 'PWD: ' + os.getcwd() + os.linesep )
        sys.stdout.write( 'hello """+jobname+"""' + os.linesep )
        """
    if extra_line:
        content += extra_line + """
        """
    content += """sys.stdout.flush()
        """

    util.writefile( filename, content )


def assert_log_lines( logfile, *line_answers ):
    ""
    lines = readlog( logfile )

    assert len( lines ) == len( line_answers ), \
            'num lines differs: '+str(lines)+' != '+str(line_answers)

    for i,line in enumerate( lines ):

        ans_line = line_answers[i]

        assert len( line ) == len( ans_line ), \
            'line length differs: '+str(line)+' != '+str(ans_line)

        for j,val in enumerate( line ):

            if type( ans_line[j] ) == type(2):
                assert abs( time.time() - val ) < ans_line[j]
            else:
                assert val == ans_line[j]


def job_log_path( log_dir, job_filename ):
    ""
    pat = os.path.join( log_dir, job_filename+'_*', 'log.txt' )
    fL = glob.glob( pat )

    assert len(fL) == 1
    logfile = fL[0]

    assert os.path.isfile( logfile )

    logdir = os.path.dirname( logfile )

    return logdir,logfile


def assert_job_log_content( logname, pwd=None, line_value=None ):
    ""
    content = util.readfile( logname )

    if pwd != None:
        lines = util.greplines( 'PWD:', content )
        assert len( lines ) == 1
        file_pwd = lines[0].split(':',1)[1].strip()
        assert os.path.samefile( pwd, file_pwd )

    if line_value != None:
        lines = util.greplines( line_value, content )
        assert len( lines ) == 1
        assert lines[0].strip() == line_value


def readlog( logname ):
    """
    """
    fp = open( logname, 'r' )
    lines = []
    try:
        i = 0
        while True:
            L = trigger.logreadline( fp )
            if L == None:
                break
            lines.append( L )
            i += 1
            assert i < 100  # avoid infinite loop
    finally:
        fp.close()

    return lines

def logfind( title, loglist, index=0 ):
    """
    Search the log file lines for 'title', which is the second field.  If
    'index' is zero, the first match is returned, if 1 the second, etc.
    """
    i = 0
    for L in loglist:
        if len(L) > 1 and L[1] == title:
            if i == index:
                return L
            i += 1
    return None


def log_line_dict( logline ):
    ""
    D = { 'date': logline[0], 'title': logline[1] }

    entry1 = logline[2]
    if entry1.startswith( 'mach=' ):
        for entry in entry1.split():
            k,v = entry.split( '=', 1 )
            D[ k.strip() ] = v.strip()
    else:
        k,v = entry1.split( '=', 1 )
        D[ k.strip() ] = v.strip()

    for entry in logline[3:]:
        k,v = entry.split( '=', 1 )
        D[ k.strip() ] = v.strip()

    return D


def loglaunch( loglist, index=0 ):
    """
    Finds a "launch" title in the log lines, then collects and returns
    the launch info.  The 'index' is the same as in logfind.
    """
    L = logfind( 'launch', loglist, index=index )
    assert L
    tm = L[0]
    assert L[2].startswith( 'trigger=' )
    trig = L[2].split( 'trigger=', 1 )[1].strip()
    assert L[3].startswith( 'file=' )
    jobfile = L[3].split( 'file=', 1 )[1].strip()
    assert L[4].startswith( 'logdir=' )
    logdir = L[4].split( 'logdir=', 1 )[1].strip()
    return tm, trig, jobfile, logdir


def logfinish( loglist, index=0 ):
    """
    Finds a "finish" title in the log lines, then collects and returns
    the finish info.  The 'index' is the same as in logfind.
    """
    L = logfind( 'finish', loglist, index=index )
    assert L
    tm = L[0]
    assert L[2].startswith( 'exit=' )
    x = L[2].split( 'exit=', 1 )[1].strip()
    assert L[3].startswith( 'file=' )
    jobfile = L[3].split( 'file=', 1 )[1].strip()
    assert L[4].startswith( 'logdir=' )
    logdir = L[4].split( 'logdir=', 1 )[1].strip()
    return tm, x, jobfile, logdir


def assert_recurse_dow( spec, dow_answer, remainder_answer ):
    ""
    sL = [ s.strip() for s in spec.split(',') ]

    dowL = []
    R = trigger.recurse_dow( sL, dowL )

    assert dowL == dow_answer
    assert R == remainder_answer


def bad_next_trigger_time( spec, curtime ):
    ""
    try:
        tm = trigger.next_trigger_time( spec, curtime )
    except Exception:
        err = str( sys.exc_info()[1] )
        print3( err )
        assert err.find('bad time syntax') >= 0
    else:
        raise Exception( "expected an exception" )


def string_time( seconds ):
    """
    For the given time in seconds since epoch, returns a string with the
    time-of-day in format hour:minute:second am/pm.
    """
    tup = time.localtime( seconds )
    return time.strftime( "%I:%M:%S %p", tup ).lower()

def epoch_at_midnight( curtm ):
    """
    Helper function to return the epoch time at midnight last night
    """
    tup = time.localtime( curtm )
    tup = ( tup[0], tup[1], tup[2], 0, 0, 0, tup[6], tup[7], tup[8] )
    return int( time.mktime( tup ) )

def day_of_week( tm ):
    """
    Helper function to return the day of the week for the given time.
    Returns the full name.
    """
    return time.strftime( '%A', time.localtime( tm ) )

def epoch_at_month_start( curtm ):
    """
    Returns the epoch time at midnight of the first of the month.
    """
    t = epoch_at_midnight( curtm )
    t += 10*60*60  # 10am
    for i in range(100):
        # day of month
        dom = int( time.strftime( '%d', time.localtime(t) ) )
        if dom == 1:
            # chop to midnight
            return epoch_at_midnight( t )
        t -= 24*60*60
    raise Exception( 'algorithm failed' )


class Background:

    def __init__(self, cmd, outfile=None):
        """
        """
        self.cmd = cmd
        if outfile != None:
            fp = open( outfile, 'w' )
            self.p = subprocess.Popen( cmd, shell=True,
                                       stdout=fp.fileno(), 
                                       stderr=fp.fileno() )
            fp.close()
        else:
            self.p = subprocess.Popen( cmd, shell=True )

    def wait(self, timeout=30):
        """
        """
        if timeout == None:
            x = self.p.wait()
            return x
        for i in range(timeout):
            x = self.p.poll()
            if x != None:
                return x
            time.sleep(1)
        self.stop()
        return None
    
    def stop(self):
        try:
            os.kill( self.p.pid, signal.SIGINT )
            self.p.wait()
        except Exception:
            if hasattr( self.p, 'terminate' ):
                try: self.p.terminate()
                except Exception: pass


#######################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
