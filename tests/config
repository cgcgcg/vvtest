#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST: vvtest

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os

import vvtestutils as vtu
import testutils as util


class config_tests( vtu.vvtestTestCase ):

    def test_using_idplatform_in_a_specified_config_directory(self):
        ""
        util.writefile( "tst.vvt", """
            import vvtest_util as vvt
            print ( "the COMPILER is "+vvt.COMPILER )
            """ )

        for batch in [False,True]:

            util.writefile( "config/idplatform.py", """
                def platform( opts ):
                    return "XBox"
                def compiler( platname, opts ):
                    return "BASIC"
                """ )
            vtu.remove_results()

            vrun = vtu.runvvtest( '--config config', batch=batch,
                                                     addplatform=False )

            platname, cplr = check_get_compiler_and_platform( vrun )
            assert platname == "XBox"
            assert cplr == "BASIC"

            util.writefile( "nonsense/idplatform.py", """
                def platform( opts ):
                    return "PlayStation"
                def compiler( platname, opts ):
                    return "Fortran"
                """ )
            vtu.remove_results()

            os.environ['VVTEST_CONFIGDIR'] = 'nonsense'
            try:
                vrun = vtu.runvvtest( batch=batch, addplatform=False )
            finally:
                del os.environ['VVTEST_CONFIGDIR']
            platname, cplr = check_get_compiler_and_platform( vrun )
            assert platname == 'PlayStation'
            assert cplr == 'Fortran'

    def test_get_max_num_processors_from_config(self):
        ""
        util.writescript( 'atest.vvt', """
            #!"""+sys.executable+"""
            #VVT: parameterize : np=1
            import vvtest_util as vvt
            print ( 'executing test, np='+str(vvt.np) )
            """ )
        util.writescript( 'btest.vvt', """
            #!"""+sys.executable+"""
            #VVT: parameterize : np=2
            import vvtest_util as vvt
            print ( 'executing test, np='+str(vvt.np) )
            """ )
        util.writescript( 'ctest.vvt', """
            #!"""+sys.executable+"""
            #VVT: parameterize : np=3
            import vvtest_util as vvt
            print ( 'executing test, np='+str(vvt.np) )
            """ )
        util.writescript( 'dtest.vvt', """
            #!"""+sys.executable+"""
            #VVT: parameterize : np=4
            import vvtest_util as vvt
            print ( 'executing test, np='+str(vvt.np) )
            """ )

        vrun = vtu.runvvtest()

        # only run this test if the number of processors is at least 4
        maxprocs = extract_maxprocs( vrun.out )

        if maxprocs >= 4:

            vrun.assertCounts( total=4, npass=4 )

            vtu.remove_results()

            util.writefile( "config/platform_plugin.py", """
                import os, sys
                def initialize( plat ):
                    plat.setattr( 'maxprocs', 2 )
                """ )

            vrun = vtu.runvvtest( '--config config' )
            vrun.assertCounts( total=2, npass=2 )

            assert extract_maxprocs( vrun.out ) == 2

            assert vrun.getTestIds() == [ 'atest.np=1', 'btest.np=2' ]

            vtu.remove_results()

            vrun = vtu.runvvtest( '--config config', batch=True )
            vrun.assertCounts( total=2, npass=2 )

            assert extract_maxprocs( vrun.out ) == None

            assert vrun.getTestIds() == [ 'atest.np=1', 'btest.np=2' ]

    def test_setting_platform_environ_vars(self):
        ""
        util.writefile( "config/platform_plugin.py", """
            import os, sys
            def initialize( plat ):
                plat.setenv( 'MY_PLATFORM_VAR', 'my platform value' )
            """ )

        util.writescript( 'pytest.vvt', """
            #!"""+sys.executable+"""
            import os, sys
            import vvtest_util as vvt
            vvt.apply_platform_variables()
            sys.stdout.write( 'plat vars = '+str(vvt.PLATFORM_VARIABLES)+'\\n' )
            sys.stdout.write( 'plat var = '+os.environ['MY_PLATFORM_VAR']+'\\n' )
            """ )
        util.writescript( 'shtest.vvt', """
            #!/bin/sh
            source ./vvtest_util.sh
            apply_platform_variables
            echo "plat vars = $PLATFORM_VARIABLES"
            echo "my var = $PLATVAR_MY_PLATFORM_VAR"
            echo "my var from env = $MY_PLATFORM_VAR"
            """ )

        vrun = vtu.runvvtest( '--config config' )
        vrun.assertCounts( total=2, npass=2 )

        assert vrun.countGrepLogs( "plat vars = *MY_PLATFORM_VAR", 'pytest' ) == 1
        assert vrun.countGrepLogs( "plat var = my platform value", 'pytest' ) == 1

        assert vrun.countGrepLogs( "plat vars = *MY_PLATFORM_VAR", 'shtest' ) == 1
        assert vrun.countGrepLogs( "my var = my platform value", 'shtest' ) == 1
        assert vrun.countGrepLogs( "my var from env = my platform value", 'shtest' ) == 1

    def test_passing_platopt_into_platform_plugin(self):
        ""
        util.writefile( "config/platform_plugin.py", """
            import os, sys
            def initialize( plat ):
                opts = plat.getOptions()
                assert '--platopt' in opts
                assert opts['--platopt']['account'] == 'foo'
                print ( 'initialize successFUL' )
            """ )
        util.writefile( 'atest.vvt', 'pass' )

        vrun = vtu.runvvtest( '--config config --platopt account=foo' )
        vrun.assertCounts( total=1, npass=1 )
        assert 'initialize successFUL' in vrun.out

    def test_default_platform_initialize_plugin(self):
        ""
        sys.path.insert( 0, vtu.cfgdir )

        try:
            import platform_plugin as plug

            plat = MockPlatform()
            plug.initialize( plat )

            plat = MockPlatform( 'Cray' )
            plug.initialize( plat )
            assert plat.save[0] == 'pbs'
            assert plat.save[1] == 32
            assert plat.save[2]['variation'] == 'select'

            plat = MockPlatform( 'CrayXC' )
            plug.initialize( plat )
            assert plat.save[0] == 'slurm'
            assert plat.save[1] == 32
            assert 'variation' not in plat.save[2]

            platopt = { '--platopt': { 'variation':'knl' } }
            plat = MockPlatform( 'CrayXC', platopt=platopt )
            plug.initialize( plat )
            assert plat.save[0] == 'slurm'
            assert plat.save[1] == 64
            assert plat.save[2]['variation'] == 'knl'

            plat = MockPlatform( 'TLCC2' )
            plug.initialize( plat )
            assert plat.save[0] == 'slurm'
            assert plat.save[1] == 16

            plat = MockPlatform( 'CTS1' )
            plug.initialize( plat )
            assert plat.save[0] == 'slurm'
            assert plat.save[1] == 36

            plat = MockPlatform( 'Godzilla' )
            plug.initialize( plat )
            assert plat.save[0] == 'slurm'
            assert plat.save[1] == 20

        finally:
            sys.path.pop(0)

    def test_overriding_builtin_script_utils(self):
        ""
        cfg = os.path.abspath('config')
        util.writescript( 'pytest.vvt', """
            #!"""+sys.executable+"""
            import os, sys
            import vvtest_util as vvt
            import script_util.standard_utilities as std
            std.if_diff_exit_diff()
            """ )
        util.writescript( 'shtest.vvt', """
            #!/bin/sh
            source ./vvtest_util.sh
            if_diff_exit_diff || exit 1
            """ )

        util.writefile( 'config/script_util/__init__.py', '' )
        util.writefile( "config/script_util/standard_utilities.py", """
            import os, sys
            def if_diff_exit_diff():
                print ( 'override pyfunc if diff exit diff' )
            """ )
        util.writefile( "config/script_util.sh", """
            if_diff_exit_diff() {
                echo 'override shfunc if diff exit diff'
            }
            """ )

        for batch in [False,True]:

            vtu.remove_results()

            vrun = vtu.runvvtest( '--config config', batch=batch )
            vrun.assertCounts( total=2, npass=2 )

            assert vrun.countGrepLogs( "override pyfunc if diff exit diff", 'pytest' ) == 1
            assert vrun.countGrepLogs( "override shfunc if diff exit diff", 'shtest' ) == 1

    def test_adding_a_config_dir_to_script_utils(self):
        ""
        cfg = os.path.abspath('config')
        util.writescript( 'pytest.vvt', """
            #!"""+sys.executable+"""
            import os, sys
            import vvtest_util as vvt
            import mystuff
            mystuff.my_special_func()
            """ )
        util.writescript( 'shtest.vvt', """
            #!/bin/sh
            source ./vvtest_util.sh
            my_special_func || exit 1
            """ )

        util.writefile( "config/mystuff.py", """
            import os, sys
            def my_special_func():
                print ( 'my special pyfunc called' )
            """ )
        # any script_util.sh file in the config dirs is sourced by vvtest_util.sh
        util.writefile( "config/script_util.sh", """
            my_special_func() {
                echo 'my special shfunc called'
            }
            """ )

        for batch in [False,True]:

            vtu.remove_results()

            vrun = vtu.runvvtest( '--config config', batch=batch )
            vrun.assertCounts( total=2, npass=2 )

            assert vrun.countGrepLogs( "my special pyfunc called", 'pytest' ) == 1
            assert vrun.countGrepLogs( "my special shfunc called", 'shtest' ) == 1

    def test_config_dirs_are_added_to_PATH(self):
        ""
        util.writescript( 'myconfig/myscript', """
            #!"""+sys.executable+"""
            print ( 'output from myscript' )
            """ )
        util.writefile( 'rundir/atest.vvt', """
            import subprocess
            import vvtest_util as vvt
            subprocess.check_call( 'myscript', shell=True )
            import script_util as util
            assert util.which('exprutil')
            """ )
        util.writescript( 'rundir/btest.vvt', """
            #!/bin/bash
            source ./vvtest_util.sh
            myscript || exit 1
            type exprutil || exit 1
            """ )
        util.writefile( 'rundir/ctest.xml', """
            <rtest name="ctest">
                <execute>
                    myscript || exit 1
                    ( which exprutil ) || exit 1
                </execute>
            </rtest>
            """ )

        for batch in [False,True]:

            vrun = vtu.runvvtest( '-w --config ../myconfig',
                                  chdir='rundir', batch=batch )
            vrun.assertCounts( total=3, npass=3 )

            assert vrun.countGrepLogs( "output from myscript", 'atest' ) == 1
            assert vrun.countGrepLogs( "output from myscript", 'btest' ) == 1
            assert vrun.countGrepLogs( "output from myscript", 'ctest' ) == 1

    def test_exercising_defaults_and_checking_in_the_idplatform_plugin(self):
        ""
        os.mkdir( 'config' )
        util.writefile( "tst.xml", """
            <rtest name="tst">
              <execute> echo "the COMPILER is $COMPILER" </execute>
            </rtest>""" )

        # first grab the default compiler and platform name
        vrun = vtu.runvvtest( '--config config', addplatform=False )
        default_platname, default_cplr = check_get_compiler_and_platform( vrun )

        # override idplatform.py but misspell the function names, which will
        # force vvtest to fall back to some other default
        util.writefile( "config/idplatform.py", """
            def platforms( opts ):
                return "XBox"
            def compilers( platname, opts ):
                return "BASIC"
            """ )
        vtu.remove_results()

        vrun = vtu.runvvtest( '--config config', addplatform=False )
        core_platname, core_cplr = check_get_compiler_and_platform( vrun )
        # no guarantees about the value here; just make sure it is non-empty
        assert core_cplr and core_platname

        # if the functions return an empty string, the core defaults should be used
        util.writefile( "config/idplatform.py", """
            def platform( opts ):
                return ''
            def compiler( platname, opts ):
                return ''
            """ )
        vtu.remove_results()

        vrun = vtu.runvvtest( '--config config', addplatform=False )
        platname, cplr = check_get_compiler_and_platform( vrun )
        assert cplr == core_cplr
        assert platname == core_platname

        # if the functions do not return a value, the core defaults should be used
        util.writefile( "config/idplatform.py", """
            def platform( opts ):
                pass
            def compiler( platname, opts ):
                pass
            """ )
        vtu.remove_results()

        vrun = vtu.runvvtest( '--config config', addplatform=False )
        platname, cplr = check_get_compiler_and_platform( vrun )
        assert cplr == core_cplr
        assert platname == core_platname

        # the command line option --plat should take precedence
        util.writefile( "config/idplatform.py", """
            def platform( opts ):
                return "XBox"
            def compiler( platname, opts ):
                if platname == 'PlayStation': return "BASIC"
            """ )
        vtu.remove_results()

        vrun = vtu.runvvtest( '--config config --plat PlayStation' )
        platname, cplr = check_get_compiler_and_platform( vrun )
        assert cplr == "BASIC"
        assert platname == "PlayStation"

    def test_using_multiple_config_directories(self):
        ""
        cfg1 = os.path.abspath('config1')
        cfg2 = os.path.abspath('config2')

        os.mkdir( 'rundir' )

        util.writefile( 'pytest.vvt', """
            import vvtest_util as vvt
            import mypyutil
            mypyutil.mypyfunc()
            """ )
        util.writescript( 'shtest.vvt', """
            #!/bin/sh
            source ./vvtest_util.sh
            save_IFS=$IFS ; IFS=:
            for pth in $CONFIGDIR ; do
                [ -e $pth/myshutil.sh ] && source $pth/myshutil.sh
            done
            IFS=$save_IFS
            myshfunc
            """ )

        util.writefile( cfg1+'/mypyutil.py', """
            import os, sys
            def mypyfunc():
                print ( 'mypyfunc was called' )
            """ )
        util.writefile( cfg2+'/myshutil.sh', """
            myshfunc() {
                echo "myshfunc was called"
            }
            """ )

        for batch in [False,True]:

            with util.set_environ( VVTEST_CONFIGDIR=None ):
                self.run_multi_config( '--config', cfg1, '--config', cfg2, '..',
                                       chdir='rundir', batch=batch )
                self.run_multi_config( '--config ../config1', '--config ../config2', '..',
                                       chdir='rundir', batch=batch )
                self.run_multi_config( '--config', cfg2, '--config', cfg1, '..',
                                       chdir='rundir', batch=batch )
                self.run_multi_config( '--config ../config2', '--config ../config1', '..',
                                       chdir='rundir', batch=batch )

            with util.set_environ( VVTEST_CONFIGDIR=cfg1+':'+cfg2 ):
                self.run_multi_config( '..', chdir='rundir', batch=batch )

            with util.set_environ( VVTEST_CONFIGDIR='../config2:../config1'):
                self.run_multi_config( '..', chdir='rundir', batch=batch )

    def run_multi_config(self, *args, **kwargs):
        ""
        vrun = vtu.runvvtest( '-w', *args, **kwargs )
        vrun.assertCounts( total=2, npass=2 )
        assert len( vrun.greplogs( 'mypyfunc was called' ) ) == 1
        assert len( vrun.greplogs( 'myshfunc was called' ) ) == 1


class preload_tests( vtu.vvtestTestCase ):

    def test_user_plugin_preload_function(self):
        ""
        plug = vtu.make_user_plugin( """
            import os
            def test_preload( specs ):
                ""
                os.environ['VVTEST_PRELOAD_PLUGIN_TEST'] = 'value'
                return 'fakepython31'
            """ )

        os.environ.pop( 'VVTEST_PRELOAD_PLUGIN_TEST', None )

        tcase = vtu.make_fake_TestCase()
        try:
            rtn = plug.testPreload( tcase )
            assert rtn == 'fakepython31'
            assert os.environ['VVTEST_PRELOAD_PLUGIN_TEST'] == 'value'
        finally:
            os.environ.pop( 'VVTEST_PRELOAD_PLUGIN_TEST', None )

    def test_parsing_preload_label_in_test_specification(self):
        ""
        util.writefile( "testA.vvt", """
            #VVT: preload = fakepython
            pass
            """ )

        tspec = vtu.parse_single_test_file( 'testA.vvt' )
        assert tspec.getPreloadLabel() == 'fakepython'

    def test_using_a_preload_label_in_a_test(self):
        ""
        util.writefile( "testA.vvt", """
            #VVT: preload = fakepython
            print ( 'in testA' )
            """ )
        util.writefile( "testB.vvt", """
            print ( 'in testB' )
            """ )
        util.writescript( 'mybin/fakepython31', """
            #!/bin/bash
            echo "Fake Python 3.1"
            exec python "$@"
            """ )
        util.writefile( "cfg/vvtest_user_plugin.py", """
            import os
            def test_preload( specs ):
                ""
                label = specs.get( 'preload', None )
                if label:
                    os.environ['PATH'] += ':"""+os.path.abspath('mybin')+"""'
                    return 'fakepython31'
                else:
                    pass  # test does not specify a preload label
            """ )

        for batch in [False,True]:

            vtu.remove_results()

            vrun = vtu.runvvtest( '--config cfg', batch=batch )
            vrun.assertCounts( total=2, npass=2 )

            assert vrun.countGrepLogs( 'in testA', 'testA' ) == 1
            assert vrun.countGrepLogs( 'Fake Python 3.1', 'testA' ) == 1

            assert vrun.countGrepLogs( 'in testB', 'testB' ) == 1
            assert vrun.countGrepLogs( 'Fake Python 3.1', 'testB' ) == 0


########################################################################

def check_get_compiler_and_platform( vrun ):
    ""
    vrun.assertCounts( total=1, npass=1 )

    platname = vrun.platformName()

    lines = vrun.greplogs( 'the COMPILER is', 'tst' )
    assert len( lines ) == 1

    cplr = lines[0].split()[-1]

    return platname, cplr


def extract_maxprocs( vvtest_output ):
    ""
    maxprocs = None

    L1 = util.greplines( 'max cores', vvtest_output )
    if len(L1) > 0:
        L2 = L1[0].split( 'max cores', 1 )[1].strip().strip('=').split(',')
        maxprocs = int( L2[0].strip() )

    return maxprocs


class MockPlatform:

    def __init__(self, name='XBox', compiler='gcc', platopt={}):
        ""
        self.platname = name
        self.cplr = compiler
        self.opts = platopt

        self.save = None

    def getName(self): return self.platname
    def getCompiler(self): return self.cplr
    def getOptions(self): return self.opts

    def setBatchSystem(self, batch, ppn, **kwargs):
        ""
        assert self.save == None
        self.save = ( batch, ppn, kwargs )


########################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
