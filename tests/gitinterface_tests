#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST: trig

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
from os.path import abspath, dirname, normpath
from os.path import join as pjoin
import time
import shutil
import glob
import filecmp
import string
import random
import unittest

import trigtestutils as trigutil
import testutils as util
from testutils import print3

from gitinterface import GitInterfaceError, GitRepo, GitRunner
from gitinterface import set_environ, change_directory
from gitinterface import create_repo, clone_repo
from gitinterface import get_repo_toplevel, _find_toplevel_bare_git_repo
from gitinterface import _copy_path_to_current_directory
from gitinterface import runcmd
from gitinterface import update_repository_mirror
from gitinterface import repository_url_match
from gitinterface import is_a_local_repository
from gitinterface import verify_repository_url
from gitinterface import repo_name_from_url
from gitinterface import get_remote_branches
from gitinterface import is_subdir


class with_set_environ( trigutil.trigTestCase ):

    def setUp(self):
        ""
        trigutil.trigTestCase.setUp( self, cleanout=False )

    def test_setting_no_names_should_not_change_environ(self):
        ""
        orig = dict( os.environ )

        with set_environ():
            state = dict( os.environ )

        self.assertEqual( orig, os.environ )
        self.assertEqual( orig, state )

    def test_setting_a_new_name_should_get_set_then_unset(self):
        ""
        orig = dict( os.environ )
        assert 'MY_SPECIAL_NAME' not in os.environ

        with set_environ( MY_SPECIAL_NAME='my special value' ):
            state = dict( os.environ )

        self.assertEqual( orig, os.environ )
        assert state['MY_SPECIAL_NAME'] == 'my special value'

    def test_a_value_of_None_causes_an_unset(self):
        ""
        orig = dict( os.environ )
        os.environ['MY_SPECIAL_NAME'] = 'my special value'

        assert 'MY_SPECIAL_NAME' in os.environ

        with set_environ( MY_SPECIAL_NAME=None ):
            state = dict( os.environ )

        assert os.environ['MY_SPECIAL_NAME'] == 'my special value'
        assert 'MY_SPECIAL_NAME' not in state

        del os.environ['MY_SPECIAL_NAME']

    def test_unset_has_no_affect_if_not_already_defined(self):
        ""
        orig = dict( os.environ )
        assert 'MY_SPECIAL_NAME' not in os.environ

        with set_environ( MY_SPECIAL_NAME=None ):
            state = dict( os.environ )

        assert 'MY_SPECIAL_NAME' not in state
        self.assertEqual( orig, state )


class create_and_clone( trigutil.trigTestCase ):

    def test_getting_a_repository_toplevel(self):
        ""
        url = util.create_bare_repo( 'example', 'baredir' )
        baredir = 'baredir/example.git'
        util.push_file_to_repo( url, 'subdir/myfile.txt', 'hello\n' )
        util.runcmd( 'git clone '+url+' myclone' )

        grun = GitRunner()

        with util.change_directory( '/' ):
            self.assertRaises( GitInterfaceError, get_repo_toplevel, grun )

        with util.change_directory( 'myclone' ):
            top = get_repo_toplevel( grun )
        assert os.path.samefile( top, 'myclone' )

        with util.change_directory( 'myclone/subdir' ):
            top = get_repo_toplevel( grun )
        assert os.path.samefile( top, 'myclone' )

        with util.change_directory( 'myclone/.git' ):
            top = get_repo_toplevel( grun )
        assert os.path.samefile( top, 'myclone' )

        self.assertRaises( GitInterfaceError, get_repo_toplevel, grun, '/' )
        top = get_repo_toplevel( grun, 'myclone' )
        assert os.path.samefile( top, 'myclone' )
        top = get_repo_toplevel( grun, 'myclone/subdir' )
        assert os.path.samefile( top, 'myclone' )
        top = get_repo_toplevel( grun, 'myclone/.git' )
        assert os.path.samefile( top, 'myclone' )

        with util.change_directory( baredir ):
            top = get_repo_toplevel( grun )
        assert os.path.samefile( top, baredir )

        with util.change_directory( baredir+'/branches' ):
            top = get_repo_toplevel( grun )
        assert os.path.samefile( top, baredir )

        top = get_repo_toplevel( grun, baredir )
        assert os.path.samefile( top, baredir )

        top = get_repo_toplevel( grun, baredir+'/branches' )
        assert os.path.samefile( top, baredir )

        # check unlikely case of bare repo not found
        top = _find_toplevel_bare_git_repo( '/usr/bin' )
        assert not top

    def test_create_repository_in_existing_directory(self):
        ""
        create_repo()

        time.sleep(1)
        assert os.path.exists( '.git/config' )

    def test_create_repository_in_a_new_directory(self):
        ""
        git1 = create_repo( 'newrepo' )
        git2 = create_repo( 'adir/aclone' )

        time.sleep(1)

        assert not os.path.exists( '.git' )
        assert os.path.exists( 'newrepo/.git/config' )
        assert not git1.get_remote_URL( verbose=3 )

        assert os.path.exists( 'adir/aclone/.git/config' )
        assert not git2.get_remote_URL( verbose=3 )

    def test_specify_git_executable_to_use(self):
        ""
        scr = write_git_wrapper()
        time.sleep(1)

        create_repo( 'newrepo', gitexe=scr )

        time.sleep(1)
        assert os.path.exists( 'touchfile.txt' )
        assert os.path.exists( 'newrepo/.git/config' )

    def test_create_bare_repository(self):
        ""
        git = create_repo( 'newrepo.git', bare=True )
        assert git.is_bare()

        time.sleep(1)
        lineL = util.grepfiles( 'bare', 'newrepo.git/config' )
        assert len(lineL) == 1 and 'true' in lineL[0].lower()

        assert os.path.samefile( git.get_toplevel(), 'newrepo.git' )

    def test_clone_a_local_repository(self):
        ""
        url = util.create_bare_repo( 'example' )
        util.push_file_to_repo( url, 'file.txt', 'file contents' )

        git = clone_repo( url )
        time.sleep(1)

        assert not git.is_bare()
        assert len( util.grepfiles( 'example', 'example/.git/config' ) ) > 0
        assert len( util.grepfiles( 'file contents', 'example/file.txt' ) ) == 1

    def test_specify_https_proxy(self):
        ""
        scr = write_git_wrapper()
        time.sleep(1)

        with set_environ( https_proxy=None, HTTPS_PROXY=None ):

            url = util.create_bare_repo( 'example' )
            util.push_file_to_repo( url, 'file.txt', 'file contents' )

            assert 'https_proxy' not in os.environ
            assert 'HTTPS_PROXY' not in os.environ

            git = clone_repo( url, gitexe=scr,
                                   https_proxy='fakeurl://some/thing' )

        assert len( util.grepfiles( 'https_proxy=fakeurl://some/thing',
                                    'touchfile.txt' ) ) == 1
        assert len( util.grepfiles( 'HTTPS_PROXY=fakeurl://some/thing',
                                    'touchfile.txt' ) ) == 1
        os.remove( 'touchfile.txt' )
        time.sleep(1)

        # this should run the git wrapper again
        br = git.get_branch()

        assert br == 'master'
        assert len( util.grepfiles( 'https_proxy=fakeurl://some/thing',
                                    'touchfile.txt' ) ) == 1
        assert len( util.grepfiles( 'HTTPS_PROXY=fakeurl://some/thing',
                                    'touchfile.txt' ) ) == 1

    def test_setting_directory_in_constructor(self):
        ""
        os.mkdir( 'adir' )
        time.sleep(1)

        bare_url = util.create_bare_repo( 'example' )
        util.push_file_to_repo( bare_url, 'file.txt', 'file contents' )

        with change_directory( 'adir' ):
            clone_repo( bare_url )

        git2 = GitRepo( 'adir/example' )
        assert not git2.is_bare()
        assert git2.get_branch() == 'master'

        # check if unknown keyword arguments given
        GitRepo( 'adir/example', verbose=3 )
        self.assertRaises( GitInterfaceError, GitRepo, 'adir/example', foobar=42 )

    def test_using_verbose_setting_with_exceptions(self):
        ""
        url = 'file://'+abspath('fakerepo')
        os.mkdir( 'curdir' )
        time.sleep(1)

        os.chdir( 'curdir' )

        sout,serr = call_expect_GitInterfaceError_capture_output(
                        clone_repo,
                        url,
                        verbose=0 )
        assert not sout.strip()
        assert not serr.strip()

        sout,serr = call_expect_GitInterfaceError_capture_output(
                        clone_repo,
                        url,
                        verbose=1 )
        assert 'git clone' in sout
        assert 'does not appear to be a git repository' not in sout
        assert not serr.strip()

        sout,serr = call_expect_GitInterfaceError_capture_output(
                        clone_repo,
                        url,
                        verbose=2 )
        assert 'git clone' in sout and 'fatal' not in sout
        assert 'does not appear to be a git repository' in serr

        sout,serr = call_expect_GitInterfaceError_capture_output(
                        clone_repo,
                        url,
                        verbose=3 )
        assert 'git clone' in sout.strip()
        assert 'does not appear to be a git repository' in serr

    def test_clone_master_branch_only(self):
        ""
        url = util.create_bare_repo_with_file_and_branch( 'example' )

        # default clone first; a checkout of the branch should succeed
        git = clone_repo( url )
        runcmd( 'git checkout topic', chdir='example' )

        shutil.rmtree( 'example' )
        time.sleep(1)

        # clone with master only; a checkout of the branch should fail
        git = clone_repo( url, branch='master' )
        self.assertRaises( GitInterfaceError,
            runcmd, 'git checkout topic', chdir='example' )

    def test_clone_into_a_subdirectory(self):
        ""
        url = util.create_bare_repo_with_file_and_branch( 'example' )

        git1 = clone_repo( url, directory='ex1' )
        url1 = 'file://'+git1.get_toplevel()

        git2 = clone_repo( url, directory='ex2' )

        git3 = clone_repo( url, directory='ex3', branch='topic' )
        url3 = 'file://'+git3.get_toplevel()

        fL = glob.glob( 'ex*/.git/config' )
        fL.sort()
        assert fL == ['ex1/.git/config', 'ex2/.git/config', 'ex3/.git/config']

        assert len( get_remote_branches( url1 ) ) > 0
        assert len( get_remote_branches( url3 ) ) > 0

    def test_exercise_toplevel_method(self):
        ""
        url = util.create_bare_repo_with_file_and_branch( 'example' )
        util.push_file_to_repo( url, 'subdir/afile', 'my file' )
        git1 = clone_repo( url, directory='ex1', verbose=3 )

        clone_repo( url )

        top = os.path.abspath( 'example' )

        git = GitRepo( 'example' )
        assert os.path.samefile( git.get_toplevel(), top )

        git = GitRepo( 'example/subdir', verbose=3 )
        assert os.path.samefile( git.get_toplevel(), top )

        self.assertRaises( GitInterfaceError, GitRepo, '/' )

    def test_a_bare_clone_can_be_cloned(self):
        ""
        os.mkdir( 'baredir' )
        time.sleep(1)

        url = util.create_bare_repo_with_file_and_branch( 'example' )

        bare_url = self.make_bare_clone_in_subdirectory( url, 'baredir' )
        assert os.path.isdir( 'baredir/example.git' )
        assert not os.path.exists( 'baredir/example.git/.git' )

        git = clone_repo( bare_url )
        assert util.readfile( 'example/file.txt' ).strip() == 'file contents'

    def make_bare_clone_in_subdirectory(self, origin_url, subdir):
        ""
        with change_directory( subdir ):
            git = clone_repo( origin_url, bare=True )

        return 'file://'+git.get_toplevel()

    def test_a_bare_clone_into_a_specified_directory(self):
        ""
        url = util.create_bare_repo_with_file_and_branch( 'example' )

        bare_git = clone_repo( url, directory='bare_clone_subdir', bare=True )
        assert os.path.isdir( 'bare_clone_subdir' )
        assert not os.path.exists( 'bare_clone_subdir/.git' )
        bare_url = 'file://'+bare_git.get_toplevel()

        git = clone_repo( bare_url, directory='checkrepo' )
        assert util.readfile( 'checkrepo/file.txt' ).strip() == 'file contents'

    def test_can_push_to_a_bare_clone(self):
        ""
        os.mkdir( 'baredir' )
        time.sleep(1)

        url = util.create_bare_repo_with_file_and_branch( 'example' )

        bare_url = self.make_bare_clone_in_subdirectory( url, 'baredir' )

        git = clone_repo( bare_url )
        assert 'baredir' in git.get_remote_URL()
        write_and_commit_file( git, 'cool message', 'file.txt', "yep ;)" )
        git.push()

        git2 = clone_repo( bare_url, directory='checkrepo' )
        assert util.readfile( 'checkrepo/file.txt' ).strip() == 'yep ;)'

    def test_can_push_from_a_bare_clone(self):
        ""
        orig_url = util.create_bare_repo_with_file_and_branch( 'example' )

        bare_git = clone_repo( orig_url, directory='bareclone', bare=True )
        bare_url = 'file://'+bare_git.get_toplevel()

        git = clone_repo( bare_url, directory='pushclone' )
        write_and_commit_file( git, 'a msg', 'file.txt', "make a mod" )
        git.push()

        bare_git.push()

        clone_repo( orig_url, directory='checkrepo' )
        assert util.readfile( 'checkrepo/file.txt' ).strip() == 'make a mod'

    def test_a_bare_clone_gets_all_branches_and_tags(self):
        ""
        orig_url = util.create_bare_repo_with_file_and_branch( 'example', tag='atag' )

        bare_git = clone_repo( orig_url, directory='bareclone', bare=True )
        bare_url = 'file://'+bare_git.get_toplevel()

        branchL = bare_git.get_branches()
        assert branchL == [ 'master', 'topic' ]

        tagL = bare_git.get_tags()
        assert tagL == [ 'atag' ]

    def test_can_push_all_branches_from_a_bare_clone(self):
        ""
        orig_url = util.create_bare_repo_with_file_and_branch( 'example' )

        bare_git = clone_repo( orig_url, directory='bareclone', bare=True )
        bare_url = 'file://'+bare_git.get_toplevel()

        util.push_new_branch_with_file( bare_url, 'whatever',
                                        'file2.md', 'some content' )

        bare_git.push( all_branches=True )

        git2 = clone_repo( orig_url, directory='checkrepo' )
        git2.checkout_branch( 'whatever' )
        assert util.readfile( 'checkrepo/file2.md' ).strip() == 'some content'
        git2.checkout_branch( 'topic' )
        assert not os.path.exists( 'checkrepo/file2.md' )
        assert os.path.exists( 'checkrepo/file.txt' )

    def test_can_push_all_tags_from_a_bare_clone(self):
        ""
        orig_url = util.create_bare_repo_with_file_and_branch( 'example', tag='atag' )

        bare_git = clone_repo( orig_url, directory='bareclone', bare=True )
        bare_url = 'file://'+bare_git.get_toplevel()

        util.push_file_to_repo( bare_url, 'newfile.txt', 'new junk' )
        util.push_tag_to_repo( bare_url, 'sosad' )

        bare_git.push( all_tags=True )

        git2 = clone_repo( orig_url, directory='checkrepo' )
        tagL = git2.get_tags()
        assert tagL == [ 'atag', 'sosad' ]

    def test_cannot_bare_clone_a_single_branch(self):
        ""
        url = util.create_bare_repo_with_file_and_branch( 'example' )

        self.assertRaises( GitInterfaceError,
                           clone_repo, url, branch='master', bare=True )

    def test_pushing_to_a_different_repository(self):
        ""
        orig_url = util.create_bare_repo_with_file_and_branch( 'example' )

        bare_git = clone_repo( orig_url, 'bareclone', bare=True )
        bare_url = 'file://'+bare_git.get_toplevel()

        git = clone_repo( bare_url, 'workclone' )
        write_and_commit_file( git, 'a mod', 'file.txt', "modify this guy" )

        git.push( repository=orig_url )

        clone_repo( orig_url, 'checkclone' )
        assert util.readfile( 'checkclone/file.txt' ).strip() == 'modify this guy'

        clone_repo( bare_url, 'checktwo' )
        assert util.readfile( 'checktwo/file.txt' ).strip() == 'file contents'

        git.create_remote_branch( 'newbranch' )
        write_and_commit_file( git, 'b mod', 'file.txt', "branch mod" )

        git.push( all_branches=True, repository=orig_url )

        chkit = clone_repo( orig_url, 'checkclone2' )
        chkit.checkout_branch( 'newbranch' )
        assert util.readfile( 'checkclone2/file.txt' ).strip() == 'branch mod'

    def test_verbose_prints_git_command_and_output(self):
        ""
        orig_url = util.create_bare_repo_with_file_and_branch( 'example' )

        git,out,err = util.call_capture_output( clone_repo,
                                                orig_url, 'dest0', verbose=0 )
        assert not (out+err).strip()

        git,out,err = util.call_capture_output( clone_repo,
                                                orig_url, 'dest1', verbose=1 )
        print3( out, err )
        assert 'clone ' in out and orig_url in out
        assert 'cd ' not in out and 'PWD=' not in out
        assert not err.strip()

        git,out,err = util.call_capture_output( clone_repo,
                                                orig_url, 'dest2', verbose=2 )
        print3( out, err )
        assert 'clone' in out and orig_url in out
        assert 'cd ' in out or 'PWD=' in out
        assert not err.strip()

        git,out,err = util.call_capture_output( clone_repo,
                                                orig_url, 'dest3', verbose=3 )
        print3( out, err )
        assert 'clone' in out and orig_url in out
        assert 'cd ' in out or 'PWD=' in out

        rtn,out,err = util.call_capture_output( git.checkout_branch, 'topic' )
        assert not (out+err).strip()

        rtn,out,err = util.call_capture_output( git.checkout_branch, 'master',
                                                verbose=3 )
        print3( out, err )
        assert 'checkout' in out and 'master' in out

        git.checkout_branch( 'topic', verbose=1 )

        rtn,out,err = util.call_capture_output( git.get_branch, verbose=3 )
        print3( out, err )
        assert rtn == 'topic'
        assert 'branch' in out and 'topic' in out

    def test_verbose_print_with_a_command_that_captures_output(self):
        ""
        orig_url = util.create_bare_repo_with_file_and_branch( 'example' )

        git = clone_repo( orig_url, 'dest' )

        branches,out,err = util.call_capture_output(
                                    git.get_branches,
                                    remotes=True,
                                    verbose=3 )
        print3( out, err )
        assert 'origin/master' in out and 'origin/topic' in out
        assert not err.strip()


class commit_and_push( trigutil.trigTestCase ):

    def test_create_repo_and_commit_a_file(self):
        ""
        util.writefile( 'grepo/file.txt', "file contents" )
        time.sleep(1)

        git = create_repo( 'grepo' )
        git.add( 'file.txt' )
        git.commit( 'first commit message' )

    def test_commit_and_push_a_new_file(self):
        ""
        url = util.create_bare_repo( 'myrepo' )
        util.push_file_to_repo( url, 'file.txt', 'file contents' )
        time.sleep(1)

        git = clone_repo( url )
        write_and_commit_file( git, 'adding file', 'another.txt', "another contents" )
        git.push()

        assert len( util.grepfiles( 'another', 'myrepo/another.txt' ) ) == 1

        shutil.rmtree( 'myrepo' )
        time.sleep(1)

        git = clone_repo( url )
        assert len( util.grepfiles( 'file', 'myrepo/file.txt' ) ) == 1
        assert len( util.grepfiles( 'another', 'myrepo/another.txt' ) ) == 1

    def test_add_commit_push_every_changed_file_in_a_directory(self):
        ""
        url = util.create_bare_repo_with_file_and_branch( 'example' )

        git = clone_repo( url )

        write_and_commit_file( git, 'create directory', 'adir/afile.txt', "whatever" )
        git.push()

        util.writefile( 'example/adir/afile.txt', 'changed' )
        util.writefile( 'example/adir/newfile.txt', 'brand spanking new' )
        util.writefile( 'example/adir/deep/file.txt', 'further down' )
        time.sleep(1)

        git.add( 'adir' )
        git.commit( 'add everything under adir' )
        git.push()

        time.sleep(1)
        git2 = clone_repo( url, 'check' )
        assert os.path.isfile( 'check/adir/deep/file.txt' )
        assert util.readfile( 'check/adir/afile.txt' ).strip() == 'changed'

    def test_add_method_is_relative_to_current_directory_or_toplevel(self):
        """
        but have not tried absolute paths
        """
        os.mkdir( 'work' )
        time.sleep(1)

        git = create_repo( 'myrepo' )

        write_and_commit_file( git, 'msg1', 'file1.txt', 'content1' )
        write_and_commit_file( git, 'msg2', 'subdir/file2.txt', 'content2' )

        self.assertRaises( GitInterfaceError, git.add, 'file.no.exist' )

        with change_directory( 'myrepo/subdir' ):
            util.writefile( 'file1.txt', 'subcontent1' )
            git.add( 'file1.txt', verbose=2 )
            git.commit( 'msg3', verbose=2 )

        util.writefile( 'myrepo/subdir/file4.txt', 'content4' )
        git.add( 'myrepo/subdir/file4.txt' )
        git.commit( 'msg4' )

        util.writefile( 'myrepo/file5.txt', 'content5' )
        git.add( 'myrepo/file5.txt' )
        git.commit( 'msg5' )

        util.writefile( 'myrepo/subdir/file6.txt', 'content6' )
        with change_directory( 'work' ):
            git.add( 'subdir/file6.txt' )
        git.commit( 'msg6' )

        util.writefile( 'myrepo/file7.txt', 'content7' )
        with change_directory( 'work' ):
            git.add( 'file7.txt' )
        git.commit( 'msg7' )

    def test_add_method_accepts_a_deleted_file(self):
        """
        but PWD must be within the repo, and the path must be relative to PWD
        and Git version must be >= 2.0
        """
        mj,mn,mc = git_version()
        if mj >= 2:

            git = create_repo( 'myrepo' )

            write_and_commit_file( git, 'msg1', 'file1.txt', 'content1' )
            write_and_commit_file( git, 'msg2', 'adir/file2.txt', 'content2' )

            os.remove( 'myrepo/file1.txt' )
            with change_directory( 'myrepo' ):
                git.add( 'file1.txt', verbose=3 )
            git.commit( 'msg3' )

            os.remove( 'myrepo/adir/file2.txt' )
            with change_directory( 'myrepo' ):
                git.add( 'adir/file2.txt', verbose=3 )
            git.commit( 'msg4' )

    def test_its_and_error_to_add_a_file_not_in_the_repo(self):
        ""
        git = create_repo( 'myrepo' )

        write_and_commit_file( git, 'msg1', 'file1.txt', 'content1' )

        util.writefile( 'file2.txt', 'content2' )
        self.assertRaises( GitInterfaceError, git.add, 'file2.txt', verbose=3 )

    def test_add_method_using_the_update_option(self):
        ""
        git = create_repo( 'myrepo' )

        write_and_commit_file( git, 'msg1', 'file1.txt', 'content1' )
        write_and_commit_file( git, 'msg2', 'adir/file2.txt', 'content2' )

        util.writefile( 'myrepo/file1.txt', 'new content1' )
        util.writefile( 'myrepo/adir/file2.txt', 'new content2' )

        git.add( update=True )
        git.commit( 'msg3' )

        clone_repo( git.get_toplevel(), 'checkrepo' )
        assert 'new content1' in util.readfile( 'checkrepo/file1.txt' )
        assert 'new content2' in util.readfile( 'checkrepo/adir/file2.txt' )


class branches( trigutil.trigTestCase ):

    def setUp(self):
        ""
        trigutil.trigTestCase.setUp( self )

        self.url = util.create_bare_repo_with_file_and_branch( 'example' )
        time.sleep(1)

    def test_listing_branches(self):
        ""
        os.mkdir( 'default' )
        os.mkdir( 'single' )
        os.mkdir( 'again' )
        time.sleep(1)

        assert get_remote_branches( self.url ) == [ 'master', 'topic' ]
        self.assertRaises( GitInterfaceError, get_remote_branches, os.getcwd() )

        os.chdir( 'default' )
        git = clone_repo( self.url )
        assert git.get_branches() == [ 'master' ]
        assert git.get_branches( remotes=True ) == [ 'master', 'topic' ]
        assert get_remote_branches( abspath('example') ) == [ 'master' ]
        assert get_remote_branches( 'file://'+abspath('example') ) == [ 'master' ]
        git.checkout_branch( 'topic' )
        assert get_remote_branches( abspath('example') ) == [ 'master', 'topic' ]
        assert get_remote_branches( 'file://'+abspath('example') ) == [ 'master', 'topic' ]

        os.chdir( '../single' )
        git = clone_repo( self.url, branch='topic' )
        assert git.get_branches() == [ 'topic' ]
        # the fetch entry in .git/config limits the remote listing
        assert git.get_branches( remotes=True ) == [ 'topic' ]

        os.chdir( '../again' )
        git = clone_repo( self.url, branch='master' )
        assert git.get_branches() == [ 'master' ]
        assert git.get_branches( remotes=True ) == [ 'master' ]

    def test_determine_current_branch(self):
        ""
        git = clone_repo( self.url )
        assert git.get_branch() == 'master'

        git.checkout_branch( 'topic' )
        assert git.get_branch() == 'topic'

        git = GitRepo( 'example' )
        git.get_branch() == 'topic'

    def test_current_branch_returns_None_if_in_detached_HEAD_state(self):
        ""
        util.push_file_to_repo( self.url, 'file.txt', 'new contents' )

        git = clone_repo( self.url )
        util.checkout_to_previous_sha1( git.get_toplevel() )
        assert git.get_branch() == None

    def test_current_branch_fails_if_done_right_after_git_init(self):
        ""
        os.mkdir( 'arepo' )
        time.sleep(1)

        with util.change_directory( 'arepo' ):
            runcmd( 'git init' )

        git = GitRepo( 'arepo' )
        self.assertRaises( GitInterfaceError, git.get_branch )

    def test_a_push_fails_if_not_on_a_branch(self):
        ""
        util.push_file_to_repo( self.url, 'file.txt', 'new contents' )

        git = clone_repo( self.url )
        util.checkout_to_previous_sha1( git.get_toplevel() )
        assert git.get_branch() == None
        self.assertRaises( GitInterfaceError, git.push )

    def test_clone_followed_by_a_new_branch_showing_up_on_remote(self):
        ""
        git = clone_repo( self.url )
        assert git.get_branches() == [ 'master' ]
        assert git.get_branches( remotes=True ) == [ 'master', 'topic' ]
        assert get_remote_branches( self.url ) == [ 'master', 'topic' ]

        util.push_new_branch_with_file( self.url, 'newtopic',
                                        'file.txt', 'redo' )
        time.sleep(1)

        assert git.get_branches() == [ 'master' ]
        assert git.get_branches( remotes=True ) == [ 'master', 'topic' ]
        assert get_remote_branches( self.url ) == [ 'master', 'newtopic', 'topic' ]
        git.checkout_branch( 'newtopic', verbose=3 )
        assert git.get_branch() == 'newtopic'
        assert git.get_branches( remotes=True ) == [ 'master', 'newtopic', 'topic' ]

    def test_exception_if_checkout_branch_name_does_not_exist(self):
        ""
        git = clone_repo( self.url )
        assert git.get_branches() == [ 'master' ]
        git.checkout_branch( 'topic' )
        self.assertRaises( GitInterfaceError, git.checkout_branch, 'foobar' )

        git = create_local_repo_with_a_commit( 'noremote' )
        try:
            git.checkout_branch( 'foobar' )
        except GitInterfaceError as e:
            err = str(e)
        else:
            raise Exception( 'expected an exception' )
        assert 'branch does not exist' in err

    def test_creating_a_local_branch(self):
        ""
        git = clone_repo( self.url )
        git.create_branch( 'justme' )
        assert git.get_branch() == 'justme'

        util.writefile( 'example/file.txt', 'branch contents' )
        git.add( 'file.txt' )
        git.commit( 'mod to file on branch' )
        git.checkout_branch( 'master' )

        git2 = clone_repo( 'example', 'checkrepo' )
        assert 'justme' not in git2.get_branches()
        assert 'justme' in get_remote_branches( git2.get_remote_URL() )
        git2.checkout_branch( 'justme' )
        assert util.readfile( 'checkrepo/file.txt' ).strip() == 'branch contents'

    def test_create_local_branch_fails_if_branch_already_exists(self):
        ""
        git = clone_repo( self.url )
        git.checkout_branch( 'topic' )
        git.checkout_branch( 'master' )

        self.assertRaises( GitInterfaceError, git.create_branch, 'topic' )
        assert git.get_branch() == 'master'

    def test_creating_a_remote_branch(self):
        ""
        git = clone_repo( self.url )
        git.create_remote_branch( 'nasa' )

        git = clone_repo( self.url, 'check' )
        git.checkout_branch( 'nasa' )
        assert util.readfile( 'check/file.txt' ).strip() == 'file contents'

    def create_a_remote_branch_and_push_a_change(self, git):
        ""
        git.create_remote_branch( 'nasa' )
        util.writefile( 'example/newfile.txt', 'new contents' )
        git.add( 'newfile.txt' )
        git.commit( 'add file to new branch' )
        git.push()

        git = clone_repo( self.url, 'check' )
        git.checkout_branch( 'nasa' )
        assert util.readfile( 'check/newfile.txt' ).strip() == 'new contents'

    def test_creating_a_remote_branch_and_pushing_a_change(self):
        ""
        git = clone_repo( self.url )
        self.create_a_remote_branch_and_push_a_change( git )

    def test_clone_specific_branch_then_create_a_remote_branch_and_push(self):
        ""
        git = clone_repo( self.url, branch='master' )
        self.create_a_remote_branch_and_push_a_change( git )

    def test_create_remote_branch_does_not_push_local_changes(self):
        ""
        git1 = clone_repo( self.url )
        write_and_commit_file( git1, 'modify file', 'file.txt', "modified contents" )
        git1.create_remote_branch( 'nasa' )

        git2 = clone_repo( self.url, 'check1' )
        git2.checkout_branch( 'nasa' )
        assert util.readfile( 'check1/file.txt' ).strip() == 'file contents'

        git1.push()

        git2.pull()
        assert util.readfile( 'check1/file.txt' ).strip() == 'modified contents'

    def test_create_remote_branch_within_a_single_branch_clone(self):
        ""
        git1 = clone_repo( self.url, branch='master' )
        git1.create_remote_branch( 'nasa' )

        git2 = clone_repo( self.url, 'check1' )
        git2.checkout_branch( 'nasa' )
        assert util.readfile( 'check1/file.txt' ).strip() == 'file contents'

        write_and_commit_file( git1, 'modify file', 'file.txt', "modified contents" )
        git1.push()

        git2.pull()
        assert util.readfile( 'check1/file.txt' ).strip() == 'modified contents'

    def test_checkout_a_branch_after_a_single_branch_clone(self):
        ""
        git = clone_repo( self.url, branch='master' )
        assert util.readfile( 'example/file.txt' ).strip() == 'file contents'

        git.checkout_branch( 'topic' )
        assert util.readfile( 'example/file.txt' ).strip() == 'new contents'

        git.checkout_branch( 'master' )
        assert util.readfile( 'example/file.txt' ).strip() == 'file contents'

    def test_create_remote_branch_that_already_exists_is_an_error(self):
        ""
        git = clone_repo( self.url )
        try:
            git.create_remote_branch( 'topic' )
        except GitInterfaceError as e:
            err = str(e)
        else:
            raise Exception( 'expected an exception' )
        assert 'name already exists' in err

    def test_create_remote_branch_on_a_repo_with_no_remote_URL(self):
        ""
        git = create_local_repo_with_a_commit( 'noremote' )
        try:
            git.create_remote_branch( 'topic' )
        except GitInterfaceError as e:
            err = str(e)
        else:
            raise Exception( 'expected an exception' )
        assert 'no remote URL' in err

    def test_create_remote_branch_fails_if_current_branch_is_not_tracked(self):
        ""
        git = clone_repo( self.url )
        util.create_local_branch( 'example', 'proximus' )
        assert git.get_branch() == 'proximus'
        self.assertRaises( GitInterfaceError, git.create_remote_branch, 'nasa' )

    def test_create_remote_branch_of_same_name_as_current_branch_is_an_error(self):
        ""
        git = clone_repo( self.url )
        git.checkout_branch( 'topic' )
        assert git.get_branch() == 'topic'
        self.assertRaises( GitInterfaceError, git.create_remote_branch, 'topic' )

    def test_create_remote_branch_with_added_files_should_succeed(self):
        ""
        git = clone_repo( self.url )
        util.writefile( 'example/file.txt', 'modified contents' )
        git.add( 'file.txt' )
        git.create_remote_branch( 'nasa' )

        git = clone_repo( self.url, 'check' )
        git.checkout_branch( 'nasa' )
        assert util.readfile( 'check/file.txt' ).strip() == 'file contents'

    def test_create_remote_branch_with_modified_but_not_added_files_should_succeed(self):
        ""
        git = clone_repo( self.url )
        util.writefile( 'example/file.txt', 'modified contents' )
        git.create_remote_branch( 'nasa' )

        git = clone_repo( self.url, 'check' )
        git.checkout_branch( 'nasa' )
        assert util.readfile( 'check/file.txt' ).strip() == 'file contents'

    def test_delete_remote_branch_while_on_master(self):
        ""
        git = clone_repo( self.url )
        assert 'topic' in git.get_branches( remotes=True )
        assert 'topic' in get_remote_branches( git.get_remote_URL() )
        git.delete_remote_branch( 'topic' )
        assert 'topic' not in git.get_branches( remotes=True )
        assert 'topic' not in get_remote_branches( git.get_remote_URL() )

        git = clone_repo( self.url, 'ex2' )
        assert 'topic' not in git.get_branches( remotes=True )
        assert 'topic' not in get_remote_branches( git.get_remote_URL() )

    def test_delete_remote_branch_after_checking_it_out(self):
        ""
        git = clone_repo( self.url )
        git.checkout_branch( 'topic' )
        git.checkout_branch( 'master' )
        assert 'topic' in git.get_branches()
        assert 'topic' in git.get_branches( remotes=True )
        git.delete_remote_branch( 'topic' )
        assert 'topic' not in git.get_branches()
        assert 'topic' not in git.get_branches( remotes=True )
        assert 'topic' not in get_remote_branches( git.get_remote_URL() )

        git = clone_repo( self.url, 'ex2' )
        assert 'topic' not in git.get_branches( remotes=True )
        assert 'topic' not in get_remote_branches( git.get_remote_URL() )

    def test_deleting_the_current_branch_is_an_error(self):
        ""
        git = clone_repo( self.url )
        git.checkout_branch( 'topic' )
        self.assertRaises( GitInterfaceError, git.delete_remote_branch, 'topic' )

    def test_deleting_an_unknown_branch_is_an_error(self):
        ""
        git = clone_repo( self.url )
        self.assertRaises( GitInterfaceError, git.delete_remote_branch, 'foobar' )


class tagging( trigutil.trigTestCase ):

    def test_checking_out_a_tag(self):
        ""
        bare = util.create_bare_repo_with_file_and_branch( 'example' )
        util.push_file_to_repo( bare, 'newfile.txt', 'add new file' )
        util.push_tag_to_repo( bare, 'newtag' )
        util.push_file_to_repo( bare, 'newfile.txt', 'change new file' )

        clone_repo( bare, 'chk' )
        git = GitRepo( 'chk' )
        assert util.readfile( 'chk/newfile.txt' ).strip() == 'change new file'

        git.checkout_tag( 'newtag' )
        assert util.readfile( 'chk/newfile.txt' ).strip() == 'add new file'

        git.checkout_branch( 'master' )
        assert util.readfile( 'chk/newfile.txt' ).strip() == 'change new file'

        self.assertRaises( GitInterfaceError,
                           git.checkout_tag, 'tag_that_does_not_exist' )

    def test_creating_a_tag(self):
        ""
        bare = util.create_bare_repo_with_file_and_branch( 'example' )
        util.push_file_to_repo( bare, 'newfile.txt', 'add new file' )

        git = clone_repo( bare, 'ex' )

        git.create_tag( 'newtag', 'create new tag' )

        util.writefile( 'ex/newfile.txt', 'change new file' )
        git.add( 'ex/newfile.txt' )
        git.commit( 'make a commit' )

        git.checkout_tag( 'newtag' )
        assert util.readfile( 'ex/newfile.txt' ).strip() == 'add new file'

        git.checkout_branch( 'master' )
        git.push()
        git.push( all_tags=True )

        git2 = clone_repo( bare, 'chk' )
        assert util.readfile( 'chk/newfile.txt' ).strip() == 'change new file'

        git2.checkout_tag( 'newtag' )
        assert util.readfile( 'chk/newfile.txt' ).strip() == 'add new file'

        git2.checkout_branch( 'master' )
        assert util.readfile( 'chk/newfile.txt' ).strip() == 'change new file'
        self.assertRaises( GitInterfaceError, git.create_tag, 'newtag', 'mesg' )


class pulling( trigutil.trigTestCase ):

    def setUp(self):
        ""
        trigutil.trigTestCase.setUp( self )

        self.url = util.create_bare_repo_with_file_and_branch( 'example' )
        time.sleep(1)

    def clone_twice_and_modify_and_push_file_txt(self):
        ""
        git1 = clone_repo( self.url, 'ex1' )
        git2 = clone_repo( self.url, 'ex2' )

        write_and_commit_file( git2, 'modify and push', 'file.txt', "modified contents" )
        git2.push()

        return git1, git2

    def test_push_in_one_repo_and_pull_in_another(self):
        ""
        git1, git2 = self.clone_twice_and_modify_and_push_file_txt()

        # pull with no changes
        git1.pull()
        write_and_commit_file( git1, 'adding another file',
                               'filetwo.txt', "file two contents" )
        git1.push()

        time.sleep(1)
        assert util.readfile( 'ex1/file.txt' ).strip() == 'modified contents'

        # pull with unstaged changes
        util.writefile( 'ex2/something.txt', 'whatever' )
        git2.pull()
        git2.add( 'something.txt' )
        git2.commit( 'adding something' )
        git2.push()

        time.sleep(1)
        assert util.readfile( 'ex2/filetwo.txt' ).strip() == 'file two contents'

        # pull with committed changes
        write_and_commit_file( git1, 'third change',
                               'filetwo.txt', "for the third time!" )
        git1.pull()

        time.sleep(1)
        assert util.readfile( 'ex1/something.txt' ).strip() == 'whatever'

    def test_pull_will_fail_if_repo_is_currently_in_a_rebase_operation(self):
        ""
        git1, git2 = self.clone_twice_and_modify_and_push_file_txt()

        write_and_commit_file( git1, 'this will conflict',
                               'file.txt', "also modified contents" )

        # let this fail due to a conflict
        x,out = runcmd( 'git pull', chdir='ex1', raise_on_error=False )
        assert x != 0

        # this should now fail because it is in the middle of a rebase operation
        self.assertRaises( GitInterfaceError, git1.pull )

    def test_the_repo_is_reset_after_a_pull_conflict(self):
        ""
        git1, git2 = self.clone_twice_and_modify_and_push_file_txt()

        write_and_commit_file( git1, 'this will conflict',
                               'file.txt', "also modified contents" )

        self.assertRaises( GitInterfaceError, git1.pull )

        assert git1.get_branch() == 'master'
        assert util.readfile( 'ex1/file.txt' ).strip() == 'also modified contents'

    def test_cannot_pull_into_a_bare_repo(self):
        ""
        url = util.create_bare_repo_with_file_and_branch( 'example' )
        git = clone_repo( url, 'ex', bare=True )
        self.assertRaises( GitInterfaceError, git.pull )


class orphan_branches( trigutil.trigTestCase ):

    def test_copy_file_or_directory_to_current_directory(self):
        ""
        util.writefile( 'subdir/myfile.txt', 'hello my file' )
        src = os.path.abspath( 'subdir' )
        os.mkdir( 'destdir' ) ; dest = os.path.abspath( 'destdir' )
        util.writefile( 'subdir/adir/another.txt', 'what' )
        os.symlink( 'myfile.txt', 'subdir/linkfile' )
        time.sleep(1)

        cwd = os.getcwd()

        os.chdir( dest )
        f1 = _copy_path_to_current_directory( src+'/adir' )
        f2 = _copy_path_to_current_directory( src+'/myfile.txt' )
        f3 = _copy_path_to_current_directory( src+'/linkfile' )

        time.sleep(1)

        assert util.readfile( 'adir/another.txt' ).strip() == 'what'
        assert f1 == 'adir'
        assert util.readfile( 'myfile.txt' ).strip() == 'hello my file'
        assert f2 == 'myfile.txt'
        assert os.path.islink( 'linkfile' )
        assert os.readlink( 'linkfile' ) == 'myfile.txt'
        assert f3 == 'linkfile'

    def test_create_orphan_branch(self):
        ""
        self.run_create_orphan_branch_test()

    def test_clone_master_only_then_create_orphan_branch(self):
        ""
        self.run_create_orphan_branch_test( 'master' )

    def run_create_orphan_branch_test(self, initial_branchname=None):
        ""
        url = util.create_bare_repo_with_file_and_branch( 'example' )
        util.writefile( 'readme.txt', 'this is adam' )
        time.sleep(1)

        git = clone_repo( url, 'ex', initial_branchname )
        git.create_remote_orphan_branch( 'loner', 'start fresh', 'readme.txt' )

        assert git.get_branch() == 'loner'
        assert 'loner' in get_remote_branches( git.get_remote_URL() )
        fL = glob.glob( 'ex/*' )
        assert len( fL ) == 1 and fL[0] == 'ex/readme.txt'

        git.checkout_branch( 'master' )
        assert not os.path.exists( 'ex/readme.txt' )
        assert util.readfile( 'ex/file.txt' ).strip() == 'file contents'

        git2 = clone_repo( url, 'ex2', branch='loner' )
        fL = glob.glob( 'ex2/*' )
        assert len( fL ) == 1 and fL[0] == 'ex2/readme.txt'

    def test_orphan_branch_creation_errors(self):
        ""
        url = util.create_bare_repo_with_file_and_branch( 'example' )
        util.push_file_to_repo( url, 'file.txt', 'new contents' )

        util.writefile( 'readme.txt', 'this is adam' )
        time.sleep(1)

        git = clone_repo( url )
        util.checkout_to_previous_sha1( git.get_toplevel() )

        self.assertRaises( GitInterfaceError,
            git.create_remote_orphan_branch, 'loner', 'start it', 'readme.txt' )

        git = clone_repo( url, 'ex2' )
        assert git.get_branch() == 'master'
        self.assertRaises( GitInterfaceError,
            git.create_remote_orphan_branch, 'topic', 'start it', 'readme.txt' )


class mirroring_repositories( trigutil.trigTestCase ):

    def test_copy_one_repo_to_a_second_empty_repo(self):
        ""
        src_url = util.create_bare_repo( 'foobar', 'src' )
        util.push_file_to_repo( src_url, 'file.txt', 'file contents' )

        cpy_url = util.create_bare_repo( 'example', 'cpy' )

        update_repository_mirror( src_url, cpy_url, verbose=True )

        time.sleep(1)
        git = clone_repo( cpy_url )
        assert util.readfile( 'example/file.txt' ).strip() == 'file contents'
        assert git.get_branch() == 'master'

    def test_update_a_second_repo(self):
        ""
        src_url = util.create_bare_repo( 'example' )
        util.push_file_to_repo( src_url, 'file.txt', 'file contents' )

        git1 = clone_repo( src_url, directory='cpy', bare=True )
        cpy_url = 'file://'+git1.get_toplevel()

        util.push_file_to_repo( src_url, 'file.txt', 'new contents' )

        update_repository_mirror( src_url, cpy_url )

        time.sleep(1)
        git2 = clone_repo( cpy_url, directory='checkclone' )
        assert util.readfile( 'checkclone/file.txt' ).strip() == 'new contents'

    def test_that_branches_and_tags_are_copied(self):
        ""
        src_url = util.create_bare_repo_with_file_and_branch( 'example',
                                                              subdir='srcrepo',
                                                              tag='FANCYTAG' )

        cpy_url = util.create_bare_repo( 'cpyrepo' )

        update_repository_mirror( src_url, cpy_url )

        time.sleep(1)
        git = clone_repo( cpy_url, directory='checkclone1', bare=True )
        assert git.get_branches() == ['master', 'topic']
        assert git.get_tags() == ['FANCYTAG']

        util.push_new_branch_with_file( src_url, 'coolbranch',
                                        'file.txt', 'cool contents' )
        util.push_tag_to_repo( src_url, 'COOLTAG' )

        update_repository_mirror( src_url, cpy_url )

        time.sleep(1)
        git = clone_repo( cpy_url, directory='checkclone2', bare=True )
        assert git.get_branches() == ['coolbranch', 'master', 'topic']
        assert git.get_tags() == ['COOLTAG', 'FANCYTAG']

    def test_update_a_second_repo_using_an_existing_working_repo(self):
        ""
        src_url = util.create_bare_repo_with_file_and_branch( 'example',
                                                              subdir='srcrepo',
                                                              tag='FANCYTAG' )

        cpy_url = util.create_bare_repo( 'cpyrepo' )

        git = clone_repo( src_url, directory='wrkclone', bare=True )
        wrkdir = git.get_toplevel()

        # make work clone out-of-date
        util.push_file_to_repo( src_url, 'file.txt', 'my contents' )
        util.push_new_branch_with_file( src_url, 'coolbranch',
                                        'file.txt', 'cool contents' )
        util.push_tag_to_repo( src_url, 'NEWTAG' )

        update_repository_mirror( src_url, cpy_url, work_clone=wrkdir )

        time.sleep(1)
        git = clone_repo( cpy_url, directory='checkclone' )
        assert get_remote_branches( git.get_remote_URL() ) == ['coolbranch', 'master', 'topic']
        assert git.get_tags() == ['FANCYTAG', 'NEWTAG']
        assert util.readfile( 'checkclone/file.txt' ).strip() == 'my contents'

    def test_using_an_existing_working_non_bare_repo_is_an_error(self):
        ""
        src_url = util.create_bare_repo_with_file_and_branch( 'example',
                                                              subdir='srcrepo',
                                                              tag='FANCYTAG' )

        cpy_url = util.create_bare_repo( 'cpyrepo' )

        git = clone_repo( src_url, directory='wrkclone' )
        wrkdir = git.get_toplevel()

        self.assertRaises( GitInterfaceError,
                update_repository_mirror, src_url, cpy_url, work_clone=wrkdir )

    def test_the_work_dir_will_be_created_if_it_doesnt_exist(self):
        ""
        src_url = util.create_bare_repo_with_file_and_branch( 'example',
                                                              subdir='srcrepo',
                                                              tag='FANCYTAG' )

        cpy_url = util.create_bare_repo( 'cpyrepo' )

        wrkdir = 'workclone'
        update_repository_mirror( src_url, cpy_url, work_clone=wrkdir )

        git = GitRepo( wrkdir )
        assert git.is_bare()

    def test_an_update_fails_if_history_would_be_changed(self):
        ""
        src_url = util.create_bare_repo_with_file_and_branch( 'example',
                                                              subdir='srcrepo',
                                                              tag='FANCYTAG' )

        cpy_url = util.create_bare_repo( 'cpyrepo' )

        update_repository_mirror( src_url, cpy_url )

        util.push_file_to_repo( cpy_url, 'file.txt', 'careful...' )

        self.assertRaises( GitInterfaceError,
                update_repository_mirror, src_url, cpy_url )


class misc_functions( trigutil.trigTestCase ):

    def test_repo_name_from_url(self):
        ""
        assert repo_name_from_url( 'foo/bar.git' ) == 'bar'
        assert repo_name_from_url( 'foo/bar' ) == 'bar'
        assert repo_name_from_url( 'foo/bar.git/' ) == 'bar'
        assert repo_name_from_url( 'foo/bar/' ) == 'bar'

    def test_function_repository_url_match(self):
        ""
        os.makedirs( 'subdir/deep' )
        os.mkdir( 'sub:dir' )
        url = util.create_bare_repo_with_file_and_branch( 'cool', 'barerepo' )
        clone_repo( url )
        clone_repo( url, 'mrdir/.mrgit' )
        git = clone_repo( url, 'bare_mrdir/.mrgit.git', bare=True )
        time.sleep(1)

        assert repository_url_match( 'file:///foo/bar' )
        assert repository_url_match( 'http://host.xx/path' )
        assert repository_url_match( 'https://host.xx/path' )
        assert repository_url_match( 'ssh://host.xx/path' )
        assert repository_url_match( 'git://host.xx/path' )
        assert repository_url_match( 'ftp://host.xx/path' )
        assert repository_url_match( 'ftps://host.xx/path' )

        assert repository_url_match( 'sub:dir' )
        assert not repository_url_match( './sub:dir' )
        assert repository_url_match( 'git-server:/git/proj' )
        assert repository_url_match( 'host.xx:path/to/repo.git' )
        assert repository_url_match( 'usrname@host.xx:/path/to/repo.git' )

        assert not repository_url_match( 'barerepo/cool.git' )
        assert not repository_url_match( abspath( 'barerepo/cool.git' ) )
        assert not repository_url_match( 'cool' )
        assert not repository_url_match( abspath( 'cool' ) )
        assert not repository_url_match( 'subdir' )
        assert not repository_url_match( 'subdir/deep' )

        assert not os.path.exists( 'mrdir/.git' )
        assert not os.path.exists( 'mrdir/config' )
        assert not repository_url_match( 'mrdir' )
        assert not os.path.exists( 'bare_mrdir/.git' )
        assert not os.path.exists( 'bare_mrdir/config' )
        assert not repository_url_match( 'bare_mrdir' )

    def test_function_is_a_local_repository(self):
        ""
        url = util.create_bare_repo_with_file_and_branch( 'cool', 'barerepo' )
        clone_repo( url )
        time.sleep(1)

        assert not is_a_local_repository( 'barerepo' )
        assert is_a_local_repository( 'barerepo/cool.git' )
        assert is_a_local_repository( abspath( 'barerepo/cool.git' ) )
        assert is_a_local_repository( 'barerepo/cool' )
        assert is_a_local_repository( abspath( 'barerepo/cool' ) )

        assert is_a_local_repository( 'cool' )
        assert is_a_local_repository( abspath( 'cool' ) )

    def test_function_verify_repository_url(self):
        ""
        url = util.create_bare_repo_with_file_and_branch( 'cool', 'barerepo' )
        clone_repo( url, directory='dir1/coolclone' )
        clone_repo( url, directory='dir2/bareclone.git', bare=True )
        time.sleep(1)

        assert os.path.isdir( 'dir1/coolclone' )
        assert os.path.isdir( 'dir2/bareclone.git' )

        pre = 'file://'+os.getcwd()

        assert not verify_repository_url( 'barerepo' )
        assert not verify_repository_url( pre+'/barerepo' )
        assert not verify_repository_url( 'dir1' )
        assert not verify_repository_url( pre+'/dir1' )
        assert not verify_repository_url( 'dir2' )
        assert not verify_repository_url( pre+'/dir2' )

        assert verify_repository_url( 'dir1/coolclone' )
        assert verify_repository_url( os.path.abspath('dir1/coolclone') )
        assert verify_repository_url( 'dir2/bareclone' )
        assert verify_repository_url( os.path.abspath('dir2/bareclone') )

        assert verify_repository_url( pre+'/dir1/coolclone' )
        assert verify_repository_url( pre+'/dir2/bareclone.git' )
        assert verify_repository_url( pre+'/dir2/bareclone' )

    def test_is_subdir_function(self):
        ""
        os.mkdir( 'dir1' )
        os.mkdir( 'dir2' )
        time.sleep(1)

        assert is_subdir( '.', '.' )
        assert is_subdir( '.', os.getcwd() )
        assert is_subdir( os.getcwd(), '.' )
        assert is_subdir( os.getcwd(), os.getcwd() )

        assert is_subdir( '..', '.' )

        assert is_subdir( '.', 'dir1/..' )
        assert is_subdir( os.getcwd(), 'dir1/..' )
        assert is_subdir( os.getcwd(), pjoin( abspath('dir1'), '..' ) )
        assert is_subdir( '.', pjoin( abspath('dir1'), '..' ) )

        assert is_subdir( '.', 'dir1' )
        assert is_subdir( os.getcwd(), 'dir1' )
        assert not is_subdir( 'dir1', '.' )
        assert not is_subdir( 'dir1', os.getcwd() )

        with change_directory( 'dir2' ):
            assert is_subdir( '..', '../dir1' )
            assert not is_subdir( '.', '../dir1' )
            assert not is_subdir( '.', normpath( abspath('../dir1') ) )
            assert is_subdir( '.', pjoin( '..', 'dir1', '..', 'dir2' ) )
            assert is_subdir( os.getcwd(), pjoin( '..', 'dir1', '..', 'dir2' ) )


class status_tests( trigutil.trigTestCase ):

    def make_repo_and_clone(self):
        ""
        url = util.create_bare_repo_with_file_and_branch( 'example', tag='atag' )
        util.push_file_to_repo( url, 'file.txt', 'new file content' )
        clone_repo( url )
        git = GitRepo( 'example' )

        return git, url

    def test_entries_in_an_empty_status(self):
        ""
        git,bare = self.make_repo_and_clone()

        status = git.status()

        assert len( status['commits'] ) == 0
        assert len( status['changed'] ) == 0
        assert len( status['untracked'] ) == 0
        assert len( status['stash'] ) == 0
        assert status['branch'] == 'master'

    def test_branch_states(self):
        ""
        git,bare = self.make_repo_and_clone()

        status = git.status( verbose=3 )
        assert status['branch'] == 'master'

        git.checkout_branch( 'topic' )
        status = git.status( verbose=3 )
        assert status['branch'] == 'topic'

        util.checkout_to_previous_sha1( 'example' )
        status = git.status( verbose=3 )
        assert status['branch'].startswith( '(' )

        git.checkout_branch( 'master' )
        git.checkout_tag( 'atag' )
        status = git.status( verbose=3 )
        print3( status['branch'] )
        assert status['branch'].startswith( '(' )

    def test_branch_state_during_conflict_resolution(self):
        ""
        git,bare= self.make_repo_and_clone()

        util.push_file_to_repo( bare, 'file.txt', 'should conflict' )

        util.writefile( 'example/file.txt', 'make sure it does' )
        git.add( 'example/file.txt' )
        git.commit( 'conflict message\n\nthen message\nbody\n' )

        x,out = git.run( 'pull', verbose=3, raise_on_error=False )
        assert x != 0

        status = git.status()
        assert 'rebase in progress' in status['branch']
        assert status['changed'] == [ 'file.txt' ]

    def test_commit_list(self):
        ""
        git,bare = self.make_repo_and_clone()

        util.writefile( 'example/file.txt', 'a content string' )
        git.add( 'example/file.txt' )
        git.commit( 'a message\n\nthen message\nbody\n' )

        util.writefile( 'example/file.txt', 'next content' )
        git.add( 'example/file.txt' )
        git.commit( 'next msg\n\nand smore\n' )

        status = git.status( verbose=3 )
        cmtL = status['commits']
        assert len( cmtL ) == 2
        sha1,msg = cmtL[0]
        assert sha1
        assert 'next msg' in msg and 'and smore' not in msg
        sha1,msg = cmtL[1]
        assert sha1
        assert 'a message' in msg and 'then message' not in msg

    def test_changed_and_untracked_files(self):
        ""
        git,bare = self.make_repo_and_clone()

        for i in range(10):
            fn = 'example/file'+str(i)+'.txt'
            util.writefile( fn, random_file_content(i) )
            git.add( fn )
            git.commit( 'cmt msg '+str(i) )
            git.push

        git.run( 'rm file2.txt' )
        git.run( 'mv file4.txt file_moved.txt' )
        shutil.copy( 'example/file6.txt', 'example/file_copied.txt' )
        util.writefile( 'example/file7.txt', 'complete overwrite' )
        util.writefile( 'example/file_new.txt', 'a new file' )
        os.remove( 'example/file9.txt' )

        status = git.status()

        assert status['changed'] == [ 'file2.txt', 'file4.txt',
                                      'file7.txt', 'file9.txt' ]
        assert status['untracked'] == [ 'file_copied.txt', 'file_new.txt' ]

    def test_the_stash_list(self):
        ""
        git,bare = self.make_repo_and_clone()

        util.writefile( 'example/file.txt', 'complete overwrite' )
        mj,mn,mc = git_version()
        if mj < 2 or ( mj == 2 and mn < 13 ):
            git.run( 'stash save "stash message"', verbose=3 )
        else:
            git.run( 'stash push -m "stash message"', verbose=3 )

        util.writefile( 'example/file.txt', 'another overwrite' )
        git.run( 'stash', verbose=3 )

        status = git.status()

        stashL = status['stash']
        assert len( stashL ) == 2
        ref,msg = stashL[0]
        assert ref.startswith( 'stash@' ) and 'WIP' in msg
        ref,msg = stashL[1]
        assert ref.startswith( 'stash@' ) and 'stash message' in msg


def random_file_content( idx ):
    ""
    cs = ''

    letters = string.ascii_letters + string.digits
    for i in range(idx+1):
        for j in range(100):
            cs += random.choice( letters )
        cs += '\n'

    return cs


def call_expect_GitInterfaceError_capture_output( func, *args, **kwargs ):
    ""
    caught = False
    with util.redirect_output( 'stdout.log', 'stderr.log' ):
        try:
            func( *args, **kwargs )
        except GitInterfaceError:
            caught = True

    assert caught
    time.sleep(1)

    return util.readfile('stdout.log'), util.readfile('stderr.log')


def write_git_wrapper():
    ""
    touchfile = abspath( 'touchfile.txt' )
    fname = 'mygit/gitwrapper'

    util.writescript( fname, """
        #!"""+sys.executable+"""
        import os, sys, subprocess

        with open( '"""+touchfile+"""', 'w' ) as fp:
            for name in ['https_proxy','HTTPS_PROXY']:
                val = os.environ.get( name, 'None' )
                fp.write( name+'=' + val + os.linesep )

        x = subprocess.call( ' '.join( ['git']+sys.argv[1:] ), shell=True )
        assert x == 0
        """ )

    return abspath( fname )


def write_and_commit_file( git, message, fname, content ):
    ""
    with util.change_directory( git.get_toplevel() ):
        util.writefile( fname, content )
        git.add( fname )
        git.commit( message )


def create_local_repo_with_a_commit( directory ):
    ""
    git = create_repo( directory )
    write_and_commit_file( git, 'new file', 'something', 'content' )
    return git


def git_version():
    ""
    x,out = util.runcmd( 'git --version' )
    vL = out.split()[-1].split('.')
    return int(vL[0]), int(vL[1]), int(vL[2])


#######################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
