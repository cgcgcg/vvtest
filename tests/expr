#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST: vvtest

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import time
import re

import vvtestutils as vtu
import testutils as util
from testutils import print3

from libvvtest.FilterExpressions import WordExpression, NonResultsWordExpression
from libvvtest.FilterExpressions import ParamFilter
from libvvtest.FilterExpressions import split_but_retain_separator
from libvvtest.FilterExpressions import separate_expression_into_tokens
from libvvtest.FilterExpressions import convert_token_list_into_eval_string
from libvvtest.FilterExpressions import parse_non_results_expression
from libvvtest.FilterExpressions import replace_forward_slashes
from libvvtest.FilterExpressions import join_expressions_with_AND
from libvvtest.FilterExpressions import conditional_paren_wrap
from libvvtest.FilterExpressions import parenthetical_tokenize
from libvvtest.FilterExpressions import create_parameter_filter


class word_expression_tests( vtu.vvtestTestCase ):

    def setUp(self):
        vtu.vvtestTestCase.setUp( self, cleanout=False )

    def test_WordExpression_use_cases(self):
        ""
        ex = WordExpression()
        print3( ex )
        assert str(ex) == 'WordExpression=None'
        assert ex.evaluate( list().count )

        ex.append(None)
        print3( ex )
        assert str(ex) == 'WordExpression=None'
        assert ex.evaluate( list().count )

        ex = WordExpression('')
        print3( ex )
        assert str(ex) == 'WordExpression=""'
        assert not ex.evaluate( list().count )

        ex.append('')
        print3( ex )
        assert str(ex) == 'WordExpression=""'
        assert not ex.evaluate( list().count )

        ex.append("")
        print3( ex )
        assert str(ex) == 'WordExpression=""'
        assert not ex.evaluate( list().count )

        ex.append(" ")
        print3( ex )
        assert str(ex) == 'WordExpression=""'
        assert not ex.evaluate( list().count )

        ex = WordExpression(" ")
        print3( ex )
        assert str(ex) == 'WordExpression=""'
        assert not ex.evaluate( list().count )

        ex = WordExpression(" hello  ")
        print3( ex )
        assert str(ex) == 'WordExpression="hello"'
        assert not ex.evaluate( list().count )
        assert ex.evaluate( list(['hello']).count )
        assert not ex.evaluate( list(['world']).count )

        ex.append(None)
        print3( ex )
        assert str(ex) == 'WordExpression="hello"'
        assert not ex.evaluate( list().count )
        assert ex.evaluate( list(['hello']).count )
        assert not ex.evaluate( list(['world']).count )

        ex.append("")
        print3( ex )
        assert str(ex) == 'WordExpression=""'
        assert not ex.evaluate( list().count )
        assert not ex.evaluate( list(['hello']).count )
        assert not ex.evaluate( list(['world']).count )

        ex.append("  ")
        print3( ex )
        assert str(ex) == 'WordExpression=""'
        assert not ex.evaluate( list().count )
        assert not ex.evaluate( list(['hello']).count )
        assert not ex.evaluate( list(['world']).count )

        ex.append("world")
        print3( ex )
        assert str(ex) == 'WordExpression=""'
        assert not ex.evaluate( list().count )
        assert not ex.evaluate( list(['hello']).count )
        assert not ex.evaluate( list(['world']).count )
        assert not ex.evaluate( list(['hello','world']).count )
        assert not ex.evaluate( list(['the','next']).count )

    def test_expression_and_or_precedence(self):
        ""
        ex = WordExpression("hello and world or period")
        print3( ex )
        assert str(ex) == 'WordExpression="hello and world or period"'
        assert ex.evaluate( list(['period']).count )

        ex = WordExpression("(hello and world) or period")
        print3( ex )
        assert str(ex) == 'WordExpression="(hello and world) or period"'
        assert ex.evaluate( list(['period']).count )

        ex = WordExpression("hello or world and period")
        print3( ex )
        assert str(ex) == 'WordExpression="hello or world and period"'
        assert ex.evaluate( list(['hello']).count )

        ex = WordExpression("hello or (world and period)")
        print3( ex )
        assert str(ex) == 'WordExpression="hello or (world and period)"'
        assert ex.evaluate( list(['hello']).count )

    def test_expression_errors(self):
        ""
        ex = WordExpression()

        self.assertRaises( ValueError, WordExpression, "aword1) word2" )
        self.assertRaises( ValueError, WordExpression, "word1 not word2" )
        self.assertRaises( ValueError, WordExpression, "word1 word2" )
        self.assertRaises( ValueError, WordExpression, "word1 and" )
        self.assertRaises( ValueError, WordExpression, "word1 or" )
        self.assertRaises( ValueError, WordExpression, "(word or)" )
        self.assertRaises( ValueError, WordExpression, "(word and)" )
        self.assertRaises( ValueError, WordExpression, "word and ()" )
        self.assertRaises( ValueError, WordExpression, "()" )
        self.assertRaises( ValueError, WordExpression, "word1 and and word2" )
        self.assertRaises( ValueError, WordExpression, "word1 and or word2" )
        self.assertRaises( ValueError, WordExpression, "word1 or and word2" )
        self.assertRaises( ValueError, WordExpression, "word1 or not or word2" )
        self.assertRaises( ValueError, WordExpression, "word1 and not and word2" )
        self.assertRaises( ValueError, WordExpression, "and word1" )
        self.assertRaises( ValueError, WordExpression, "or word1" )
        self.assertRaises( ValueError, WordExpression, "word1 word2" )
        self.assertRaises( ValueError, WordExpression, "word and" )
        self.assertRaises( ValueError, WordExpression, "word or" )

    def test_using_parens_in_expressions(self):
        ""
        ex = WordExpression("( word1 and word2 ) or (word3 and word4)")
        print3( ex )
        assert     ex.evaluate( list(['word1','word2']).count )
        assert     ex.evaluate( list(['word3','word4']).count )
        assert not ex.evaluate( list(['word1','word3']).count )
        assert not ex.evaluate( list(['word2','word4']).count )

        ex = WordExpression("( word1 and not (word2 or word3) ) or word4")
        print3( ex )
        assert     ex.evaluate( list(['word4']).count )
        assert     ex.evaluate( list(['word1']).count )
        assert not ex.evaluate( list(['word1','word2']).count )
        assert not ex.evaluate( list(['word1','word3']).count )

        ex = WordExpression("word1 and not (word2 or word3) or word4")
        print3( ex )
        assert     ex.evaluate( list(['word4']).count )
        assert     ex.evaluate( list(['word1']).count )
        assert not ex.evaluate( list(['word1','word2']).count )
        assert not ex.evaluate( list(['word1','word3']).count )

        ex = WordExpression("word4 or word1 and not (word2 or word3)")
        print3( ex )
        assert     ex.evaluate( list(['word4']).count )
        assert     ex.evaluate( list(['word1']).count )
        assert not ex.evaluate( list(['word1','word2']).count )
        assert not ex.evaluate( list(['word1','word3']).count )

    def test_get_word_list_after_construction(self):
        ""
        ex = WordExpression( "word4 or word1 and not (word2 or word3 )" )
        wL = ex.getWordList()
        wL.sort()
        assert wL == ['word1','word2','word3','word4']

        ex = WordExpression()
        assert ex.getWordList() == []

        ex = WordExpression( '' )
        assert ex.getWordList() == []

    def test_tokenizing_expressions(self):
        ""
        assert split_but_retain_separator( '', '(' ) == ['']
        assert split_but_retain_separator( ' ', '(' ) == [' ']
        assert split_but_retain_separator( 'abc', '(' ) == ['abc']
        assert split_but_retain_separator( '(', '(' ) == ['','(','']
        assert split_but_retain_separator( 'a(', '(' ) == ['a','(','']
        assert split_but_retain_separator( '(b', '(' ) == ['','(','b']
        assert split_but_retain_separator( 'a(b', '(' ) == ['a','(','b']
        assert split_but_retain_separator( 'a(b (c(', '(' ) == \
                                           ['a','(','b ','(','c','(','']
        assert split_but_retain_separator( ')a)b', ')' ) == \
                                           ['',')','a',')','b']

        assert separate_expression_into_tokens( '' ) == ['']
        assert separate_expression_into_tokens( ' ' ) == ['']
        assert separate_expression_into_tokens( 'word' ) == ['word']
        assert separate_expression_into_tokens( ' word ' ) == ['word']
        assert separate_expression_into_tokens( 'word1  or word2 ' ) == \
                                            ['word1','or','word2']
        assert separate_expression_into_tokens( ' not  word' ) == \
                                            ['not','word']
        assert separate_expression_into_tokens( ' not ( word )' ) == \
                                            ['not','(','word',')']
        assert separate_expression_into_tokens( ' not(word) ' ) == \
                                            ['not','(','word',')']
        assert separate_expression_into_tokens(
            'not ( word1 or word2) and word3 or (word4)' ) == \
            ['not','(','word1','or','word2',')','and','word3','or','(','word4',')']

    def test_creating_eval_string(self):
        ""
        def evalfunc(tok):
            assert tok != None and tok.strip()
            return tok == 'word'

        es = convert_token_list_into_eval_string( [''] )
        val = eval( es )
        assert val == False and type(val) == type(True)

        es = convert_token_list_into_eval_string( ['not','word'] )
        val = eval( es )
        assert val == False and type(val) == type(True)

        es = convert_token_list_into_eval_string( ['not','foo'] )
        val = eval( es )
        assert val == True and type(val) == type(True)

        es = convert_token_list_into_eval_string( ['not','(','foo',')'] )
        val = eval( es )
        assert val == True and type(val) == type(True)

        es = convert_token_list_into_eval_string( ['(','word',')'] )
        val = eval( es )
        assert val == True and type(val) == type(True)

        es = convert_token_list_into_eval_string(
                                    ['(','word',')','or','not','word'] )
        val = eval( es )
        assert val == True and type(val) == type(True)

    def test_parsing_expr_for_non_results_evaluation(self):
        ""
        def evalfunc(tok):
            return tok == 'word'

        ex = parse_non_results_expression( '' )
        print3( ex )
        assert not eval( ex )

        ex = parse_non_results_expression( 'notrun' )
        assert ex == None

        ex = parse_non_results_expression( 'not pass' )
        assert ex == None

        ex = parse_non_results_expression( 'not ( pass or diff )' )
        assert ex == None

        ex = parse_non_results_expression( 'word and fail' )
        assert eval( ex ) == True

        ex = parse_non_results_expression( 'fail and word' )
        print3( ex )
        assert eval( ex ) == True

        ex = parse_non_results_expression( 'not word and fail' )
        print3( ex )
        assert eval( ex ) == False

        ex = parse_non_results_expression( 'fail and not word' )
        print3( ex )
        assert eval( ex ) == False

        ex = parse_non_results_expression( '( foo or word ) and ( pass or fail )' )
        print3( ex )
        assert eval( ex ) == True

        ex = parse_non_results_expression(
                            '( foo or word ) and not ( pass or fail )' )
        print3( ex )
        assert eval( ex ) == True

        ex = parse_non_results_expression(
                            '( pass or fail ) and ( foo or word ) ' )
        print3( ex )
        assert eval( ex ) == True

        ex = parse_non_results_expression( 'word1 and not word2' )
        print3( ex )
        assert eval( ex ) == False

        def evalfunc(tok):
            return tok in ['word1','word3']

        ex = parse_non_results_expression(
                    '( word1 and not (word2 or word3) ) or word' )
        print3( ex )
        assert eval( ex ) == False

    def test_removing_results_keywords_from_expressions(self):
        ""
        ex = WordExpression( "foo and bar" )
        nrex = NonResultsWordExpression( "foo and bar" )
        assert not nrex.containsResultsKeywords()
        assert not ex.evaluate( ['foo'].count )
        assert not nrex.evaluate( ['foo'].count )
        assert     ex.evaluate( ['foo','bar'].count )
        assert     nrex.evaluate( ['foo','bar'].count )

        ex = WordExpression( "notrun or notdone" )
        nrex = NonResultsWordExpression( "notrun or notdone" )
        assert     nrex.containsResultsKeywords()
        assert     ex.evaluate( ['aword','notdone'].count )
        assert not ex.evaluate( ['aword','pass'].count )
        assert     nrex.evaluate( ['aword','pass'].count )

        ex = WordExpression( "notrun and word" )
        nrex = NonResultsWordExpression( "notrun and word" )
        assert     nrex.containsResultsKeywords()
        assert     ex.evaluate( ['word','notrun'].count )
        assert     nrex.evaluate( ['word','notrun'].count )
        assert not ex.evaluate( ['word','pass'].count )
        assert     nrex.evaluate( ['word','pass'].count )

        ex = WordExpression( "not pass and not ( foo or bar )" )
        nrex = NonResultsWordExpression( "not pass and not ( foo or bar )" )
        assert     nrex.containsResultsKeywords()
        assert     ex.evaluate( ['foobar','notrun'].count )
        assert     nrex.evaluate( ['foobar','notrun'].count )
        assert not ex.evaluate( ['foobar','pass'].count )
        assert not ex.evaluate( ['foobar','pass'].count )
        assert     nrex.evaluate( ['foobar','pass'].count )

        ex = WordExpression( "not pass or not ( foo or bar )" )
        nrex = NonResultsWordExpression( "not pass or not ( foo or bar )" )
        assert     nrex.containsResultsKeywords()
        assert     ex.evaluate( ['foo','notrun'].count )
        assert not nrex.evaluate( ['foo','notrun'].count )

    def test_an_exclamation_point_means_NOT(self):
        ""
        for expr in ['!foo','! foo','not foo']:
            ex = WordExpression( expr )
            assert not ex.evaluate( ['foo'].count )
            assert     ex.evaluate( ['bar'].count )

        for expr in ['foo or !bar','foo or ! bar']:
            ex = WordExpression( expr )
            assert     ex.evaluate( ['foo'].count )
            assert not ex.evaluate( ['bar'].count )
            assert     ex.evaluate( ['foo','bar'].count )
            assert     ex.evaluate( ['baz'].count )

        for expr in ['!(foo or bar)','! (foo or bar)']:
            ex = WordExpression( expr )
            assert not ex.evaluate( ['foo'].count )
            assert not ex.evaluate( ['bar'].count )
            assert not ex.evaluate( ['foo','bar'].count )
            assert     ex.evaluate( ['baz'].count )

        for expr in ['!(foo and bar)','! (foo and bar)']:
            ex = WordExpression( expr )
            assert     ex.evaluate( ['foo'].count )
            assert     ex.evaluate( ['bar'].count )
            assert not ex.evaluate( ['foo','bar'].count )
            assert     ex.evaluate( ['baz'].count )

    def test_replace_forward_slashes(self):
        ""
        assert replace_forward_slashes( 'foo' ) == 'foo'
        assert replace_forward_slashes( 'foo', True ) == 'not foo'
        assert replace_forward_slashes( 'foo and bar' ) == 'foo and bar'
        assert replace_forward_slashes( 'foo and bar', True ) == \
                                            'not ( foo and bar )'

        assert replace_forward_slashes( 'foo/bar' ) == 'foo or bar'
        assert replace_forward_slashes( 'foo/ bar' ) == 'foo or bar'
        assert replace_forward_slashes( 'foo / bar' ) == 'foo or bar'
        assert replace_forward_slashes( 'foo /bar' ) == 'foo or bar'
        assert replace_forward_slashes( 'foo/bar/baz' ) == 'foo or bar or baz'
        assert replace_forward_slashes( 'foo/!bar/baz' ) == 'foo or !bar or baz'

        assert replace_forward_slashes( 'foo', True ) == 'not foo'
        assert replace_forward_slashes( 'foo/bar', True ) == 'not foo or not bar'
        assert replace_forward_slashes( 'foo/!bar/baz', True ) == \
                                            'not foo or not !bar or not baz'

        assert replace_forward_slashes( '/foo/bar' ) == 'foo or bar'
        assert replace_forward_slashes( 'foo/bar/' ) == 'foo or bar'

        self.assertRaises( ValueError, replace_forward_slashes, 'foo/(not bar)' )
        self.assertRaises( ValueError, replace_forward_slashes, 'foo/not bar' )
        self.assertRaises( ValueError, replace_forward_slashes, 'foo or bar / baz' )
        self.assertRaises( ValueError, replace_forward_slashes, 'foo / bar and baz' )
        self.assertRaises( ValueError, replace_forward_slashes, 'foo/(bar)' )

    def test_parenthetical_tokenize(self):
        ""
        px = parenthetical_tokenize( 'foo' ) ; assert px.toks == ['foo']
        px = parenthetical_tokenize( 'not foo' ) ; assert px.toks == ['not','foo']
        px = parenthetical_tokenize( '! foo' ) ; assert px.toks == ['not','foo']
        px = parenthetical_tokenize( '!foo' ) ; assert px.toks == ['not','foo']

        px = parenthetical_tokenize( 'foo or bar' )
        assert px.toks == ['foo','or','bar']

        px = parenthetical_tokenize( '(foo)' )
        assert px.numTokens() == 1
        assert px.toks[0].toks == ['foo']

        px = parenthetical_tokenize( '(foo or bar)' )
        assert px.numTokens() == 1
        assert px.toks[0].toks == ['foo','or','bar']

        px = parenthetical_tokenize( '!(foo or bar)' )
        assert px.numTokens() == 2
        assert px.toks[0] == 'not'
        assert px.toks[1].toks == ['foo','or','bar']

        px = parenthetical_tokenize( 'foo or (bar and baz)' )
        assert px.numTokens() == 3
        assert px.toks[:2] == ['foo','or']
        assert px.toks[2].toks == ['bar','and','baz']

        px = parenthetical_tokenize( '(foo) or (bar)' )
        assert px.numTokens() == 3
        assert px.toks[0].toks == ['foo']
        assert px.toks[1] == 'or'
        assert px.toks[2].toks == ['bar']

        px = parenthetical_tokenize( '((foo or bar))' )
        assert px.numTokens() == 1
        assert px.toks[0].numTokens() == 1
        assert px.toks[0].toks[0].toks == ['foo','or','bar']

    def test_conditional_paren_wrap(self):
        ""
        assert conditional_paren_wrap( 'foo' ) == 'foo'
        assert conditional_paren_wrap( 'foo or bar' ) == '( foo or bar )'
        assert conditional_paren_wrap( '(foo)' ) == '(foo)'
        assert conditional_paren_wrap( '( foo )' ) == '( foo )'
        assert conditional_paren_wrap( '(foo or bar)' ) == '(foo or bar)'
        assert conditional_paren_wrap( '( foo or bar )' ) == '( foo or bar )'

    def test_join_expressions_with_AND(self):
        ""
        assert join_expressions_with_AND( [] ) == None
        assert join_expressions_with_AND( [''] ) == ''
        assert join_expressions_with_AND( ['foo',''] ) == ''
        assert join_expressions_with_AND( ['','foo'] ) == ''
        assert join_expressions_with_AND( ['foo','bar'] ) == 'foo and bar'
        assert join_expressions_with_AND( ['foo or bar'] ) == 'foo or bar'
        assert join_expressions_with_AND( ['foo or bar','baz'] ) == \
                                                '( foo or bar ) and baz'
        assert join_expressions_with_AND( ['foo','bar or baz'] ) == \
                                                'foo and ( bar or baz )'
        assert join_expressions_with_AND( ['( foo or bar )'] ) == \
                                                '( foo or bar )'
        assert join_expressions_with_AND( ['( foo or bar ) and baz'] ) == \
                                                '( foo or bar ) and baz'
        assert join_expressions_with_AND( ['( foo or bar ) and baz','yep'] ) == \
                                    '( ( foo or bar ) and baz ) and yep'

    def magic_test_processing_forward_slash_and_negation(self):
        ""
        for expr in ['foo/bar','foo / bar','foo/ bar','foo /bar']:
            ex = WordExpression( expr )
            assert     ex.evaluate( ['foo'].count )
            assert     ex.evaluate( ['bar'].count )
            assert     ex.evaluate( ['bar','foo'].count )
            assert not ex.evaluate( ['baz'].count )

        for expr in ['!foo/bar','!foo / bar','!foo/ bar','!foo /bar',
                     'not foo/bar','not foo / bar','not foo/ bar','not foo /bar' ]:
            ex = WordExpression( expr )
            assert not ex.evaluate( ['foo'].count )
            assert not ex.evaluate( ['bar'].count )
            assert not ex.evaluate( ['bar','foo'].count )
            assert     ex.evaluate( ['baz'].count )

        for expr in ['(!foo)/bar','(!foo) / bar','(!foo)/ bar','(!foo) /bar',
                     '(not foo)/bar','(not foo) / bar','(not foo)/ bar','(not foo) /bar' ]:
            ex = WordExpression( expr )
            assert not ex.evaluate( ['foo'].count )
            assert     ex.evaluate( ['bar'].count )
            assert     ex.evaluate( ['bar','foo'].count )
            assert     ex.evaluate( ['baz'].count )

        for expr in ['foo/!bar','foo / !bar','foo/ !bar','foo /!bar',
                     'foo/not bar','foo / not bar','foo/ not bar','foo /not bar' ]:
            ex = WordExpression( expr )
            assert     ex.evaluate( ['foo'].count )
            assert not ex.evaluate( ['bar'].count )
            assert     ex.evaluate( ['bar','foo'].count )
            assert     ex.evaluate( ['baz'].count )

        # magic: these should error out
        #   - cannot have '/' in an expr with parens
        for expr in ['not ( foo/bar and baz )','! (foo/bar and baz)',
                     'not( foo/bar and baz )','!(foo/bar and baz)']:
            ex = WordExpression( expr )
        # magic: these should error out
        #   - cannot have '/' in an expr with AND or OR
        for expr in ['foo/bar and baz','foo/bar or baz',
                     'baz and foo/bar','baz or foo/bar']:
            ex = WordExpression( expr )


class param_expression_tests( vtu.vvtestTestCase ):

    def setUp(self):
        vtu.vvtestTestCase.setUp( self, cleanout=False )

    def test_ParamFilters_with_integer_param_types(self):
        ""
        pf = ParamFilter( 'np=4' )
        assert not pf.evaluate( {} )
        assert     pf.evaluate( {'np':4} )
        assert not pf.evaluate( {'np':2} )
        assert not pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {'size':"10", 'np':4} )
        assert not pf.evaluate( {'size':"10"} )

        pf = ParamFilter( replace_forward_slashes('np=1/np=4') )
        assert not pf.evaluate( {} )
        assert     pf.evaluate( {'np':4} )
        assert     pf.evaluate( {'np':1} )
        assert     pf.evaluate( {'size':"10", 'np':4} )
        assert not pf.evaluate( {'np':3} )
        assert not pf.evaluate( {'size':"10", 'np':3} )
        assert not pf.evaluate( {'size':"10"} )

        pf = ParamFilter( replace_forward_slashes('np=1/!np') )
        assert not pf.evaluate( {'np':4} )
        assert     pf.evaluate( {'np':1} )
        assert     pf.evaluate( {'size':"10", 'np':1} )
        assert     pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {} )

        pf = ParamFilter( replace_forward_slashes('np=1/np!=') )
        assert not pf.evaluate( {'np':4} )
        assert     pf.evaluate( {'np':1} )
        assert     pf.evaluate( {'size':"10", 'np':1} )
        assert     pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {} )

        pf = ParamFilter( '!np' )
        assert not pf.evaluate( {'np':4} )
        assert not pf.evaluate( {'size':"10", 'np':1} )
        assert     pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {} )

        pf = ParamFilter( 'np=1', 'size' )
        assert not pf.evaluate( {'np':4} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {'size':"10", 'np':4} )
        assert     pf.evaluate( {'size':"10", 'np':1} )
        assert not pf.evaluate( {} )

        pf = ParamFilter( 'np=1', 'size=' )
        assert not pf.evaluate( {'np':4} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {'size':"10", 'np':4} )
        assert     pf.evaluate( {'size':"10", 'np':1} )
        assert not pf.evaluate( {} )

        pf = ParamFilter( 'np!=1', 'np!=4' )
        assert not pf.evaluate( {'np':1} )
        assert not pf.evaluate( {'np':4} )
        assert     pf.evaluate( {'np':2} )

        pf = ParamFilter( 'np<=13' )
        assert     pf.evaluate( {'np':2} )
        assert not pf.evaluate( {'np':14} )
        assert     pf.evaluate( {'np':13} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

        pf = ParamFilter( 'np>=13' )
        assert not pf.evaluate( {'np':2} )
        assert     pf.evaluate( {'np':13} )
        assert     pf.evaluate( {'np':14} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

        pf = ParamFilter( 'np<13' )
        assert     pf.evaluate( {'np':2} )
        assert not pf.evaluate( {'np':14} )
        assert not pf.evaluate( {'np':15} )
        assert not pf.evaluate( {'np':13} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

        pf = ParamFilter( 'np>13' )
        assert not pf.evaluate( {'np':2} )
        assert not pf.evaluate( {'np':13} )
        assert     pf.evaluate( {'np':14} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

    def test_ParamFilters_with_string_param_types(self):
        ""
        pf = ParamFilter( 'np=4' )
        assert not pf.evaluate( {} )
        assert     pf.evaluate( {'np':'4'} )
        assert not pf.evaluate( {'np':'2'} )
        assert not pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {'size':"10", 'np':'4'} )
        assert not pf.evaluate( {'size':"10"} )

        pf = ParamFilter( replace_forward_slashes('np=1/np=4') )
        assert not pf.evaluate( {} )
        assert     pf.evaluate( {'np':'4'} )
        assert     pf.evaluate( {'np':'1'} )
        assert     pf.evaluate( {'size':"10", 'np':'4'} )
        assert not pf.evaluate( {'np':'3'} )
        assert not pf.evaluate( {'size':"10", 'np':'3'} )
        assert not pf.evaluate( {'size':"10"} )

        pf = ParamFilter( replace_forward_slashes('np=1/!np') )
        assert not pf.evaluate( {'np':'4'} )
        assert     pf.evaluate( {'np':'1'} )
        assert     pf.evaluate( {'size':"10", 'np':'1'} )
        assert     pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {} )

        pf = ParamFilter( replace_forward_slashes('np=1/np!=') )
        assert not pf.evaluate( {'np':'4'} )
        assert     pf.evaluate( {'np':'1'} )
        assert     pf.evaluate( {'size':"10", 'np':'1'} )
        assert     pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {} )

        pf = ParamFilter( '!np' )
        assert not pf.evaluate( {'np':'4'} )
        assert not pf.evaluate( {'size':"10", 'np':'1'} )
        assert     pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {} )

        pf = ParamFilter( 'np=1', 'size' )
        assert not pf.evaluate( {'np':'4'} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {'size':"10", 'np':'4'} )
        assert     pf.evaluate( {'size':"10", 'np':'1'} )
        assert not pf.evaluate( {} )

        pf = ParamFilter( 'np=1', 'size=' )
        assert not pf.evaluate( {'np':'4'} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {'size':"10", 'np':'4'} )
        assert     pf.evaluate( {'size':"10", 'np':'1'} )
        assert not pf.evaluate( {} )

        pf = ParamFilter( 'np!=1', 'np!=4' )
        assert not pf.evaluate( {'np':'1'} )
        assert not pf.evaluate( {'np':'4'} )
        assert     pf.evaluate( {'np':'2'} )

        pf = ParamFilter( 'np<=13' )
        assert     pf.evaluate( {'np':'2'} )
        assert not pf.evaluate( {'np':'20'} )
        assert     pf.evaluate( {'np':'13'} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

        pf = ParamFilter( 'np>=13' )
        assert not pf.evaluate( {'np':'2'} )
        assert     pf.evaluate( {'np':'13'} )
        assert     pf.evaluate( {'np':'20'} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

        pf = ParamFilter( 'np<13' )
        assert     pf.evaluate( {'np':'2'} )
        assert not pf.evaluate( {'np':'20'} )
        assert not pf.evaluate( {'np':'15'} )
        assert not pf.evaluate( {'np':'13'} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

        pf = ParamFilter( 'np>13' )
        assert not pf.evaluate( {'np':'2'} )
        assert not pf.evaluate( {'np':'13'} )
        assert     pf.evaluate( {'np':'14'} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

    def test_ParamFilters_with_mixed_types(self):
        ""
        pf = ParamFilter( 'np=13' )
        assert not pf.evaluate( {'np':'a'} )

        pf = ParamFilter( 'np=ab' )
        assert not pf.evaluate( {'np':'13'} )

        pf = ParamFilter( 'np=ab' )
        assert     pf.evaluate( {'np':'ab'} )


        pf = ParamFilter( 'np!=13' )
        assert     pf.evaluate( {'np':'a'} )

        pf = ParamFilter( 'np!=ab' )
        assert     pf.evaluate( {'np':'13'} )

        pf = ParamFilter( 'np!=ab' )
        assert not pf.evaluate( {'np':'ab'} )


        pf = ParamFilter( 'np<=13' )
        assert not pf.evaluate( {'np':'a'} )

        pf = ParamFilter( 'np<=13' )
        assert     pf.evaluate( {'np':'0a'} )

        pf = ParamFilter( 'np<=ab' )
        assert     pf.evaluate( {'np':'13'} )

        pf = ParamFilter( 'np<=ab' )
        assert     pf.evaluate( {'np':'ab'} )


        pf = ParamFilter( 'np>=13' )
        assert     pf.evaluate( {'np':'a'} )

        pf = ParamFilter( 'np>=13' )
        assert not pf.evaluate( {'np':'0a'} )

        pf = ParamFilter( 'np>=ab' )
        assert not pf.evaluate( {'np':'13'} )

        pf = ParamFilter( 'np>=ab' )
        assert     pf.evaluate( {'np':'ab'} )


        pf = ParamFilter( 'np<13' )
        assert not pf.evaluate( {'np':'a'} )

        pf = ParamFilter( 'np<13' )
        assert     pf.evaluate( {'np':'0a'} )

        pf = ParamFilter( 'np<ab' )
        assert     pf.evaluate( {'np':'13'} )

        pf = ParamFilter( 'np<ab' )
        assert not pf.evaluate( {'np':'ab'} )


        pf = ParamFilter( 'np>13' )
        assert     pf.evaluate( {'np':'a'} )

        pf = ParamFilter( 'np>13' )
        assert not pf.evaluate( {'np':'0a'} )

        pf = ParamFilter( 'np>ab' )
        assert not pf.evaluate( {'np':'13'} )

        pf = ParamFilter( 'np>ab' )
        assert not pf.evaluate( {'np':'ab'} )

    def test_behavior_of_the_NOT_operator_on_param_expressions(self):
        ""
        pf = ParamFilter( 'np' )
        assert not pf.evaluate( {} )
        assert not pf.evaluate( { 'foo':5 } )
        assert     pf.evaluate( { 'np':2 } )

        for expr in [ '!np', ' not np' ]:
            pf = ParamFilter( expr )
            assert     pf.evaluate( {} )
            assert     pf.evaluate( { 'foo':5 } )
            assert not pf.evaluate( { 'np':2 } )

        pf = ParamFilter( 'np>2' )
        assert not pf.evaluate( {} )
        assert not pf.evaluate( {'foo':5} )
        assert not pf.evaluate( {'np':2} )
        assert     pf.evaluate( {'np':3} )

        # Note: the expr np<=2 is not the same as !np>2
        #       this is because np<=2 actually means
        #           (np is defined) AND (np<=2)
        #       and therefore !np<=2 actually means
        #           NOT [ (np is defined) AND (np<=2) ]
        #       which equals
        #           (np is not defined) OR (np>2)

        pf = ParamFilter( 'np<=2' )
        assert     pf.evaluate( {'np':2} )
        assert not pf.evaluate( {'np':3} )
        assert not pf.evaluate( {} )
        assert not pf.evaluate( { 'foo':5 } )

        for expr in [ '!np>2', 'not np>2' ]:
            pf = ParamFilter( expr )
            assert     pf.evaluate( {'np':2} )
            assert not pf.evaluate( {'np':3} )
            assert     pf.evaluate( {} )
            assert     pf.evaluate( { 'foo':5 } )

        for expr in [ '!np>3 and np!=1', 'not np>3 and np!=1' ]:
            pf = ParamFilter( expr )
            assert not pf.evaluate( {'np':1} )
            assert     pf.evaluate( {'np':2} )
            assert     pf.evaluate( {'np':3} )
            assert not pf.evaluate( {'np':4} )

    def test_creating_unified_parameter_expression(self):
        ""
        pf = create_parameter_filter( None, None )
        assert pf == None

        pf = create_parameter_filter( ['np=1'], None )
        assert pf.evaluate( {'np':'1'} )

        pf = create_parameter_filter( None, ['np=1'] )
        assert not pf.evaluate( {'np':'1'} )

        pf = create_parameter_filter( ['np<8'], ['np=1/ndevice'] )
        assert     pf.evaluate( {'np':'2'} )
        assert     pf.evaluate( {'np':'1'} )
        assert not pf.evaluate( {'np':'1', 'ndevice':'1'} )
        assert     pf.evaluate( {'np':'2', 'ndevice':'1'} )
        assert not pf.evaluate( {'np':'9', 'ndevice':'1'} )


############################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
