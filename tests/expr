#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST: vvtest

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import time
import re

import vvtestutils as vtu
import testutils as util
from testutils import print3

from libvvtest.errors import TestSpecError

from libvvtest.wordexpr import WordExpression, WildcardWordExpression
from libvvtest.wordexpr import create_word_expression
from libvvtest.wordexpr import split_but_retain_separator
from libvvtest.wordexpr import separate_expression_into_tokens
from libvvtest.wordexpr import convert_token_list_into_eval_string
from libvvtest.wordexpr import replace_forward_slashes
from libvvtest.wordexpr import join_expressions_with_AND
from libvvtest.wordexpr import conditional_paren_wrap
from libvvtest.wordexpr import parenthetical_tokenize

from libvvtest.keyexpr import KeywordExpression
from libvvtest.keyexpr import create_keyword_expression
from libvvtest.keyexpr import make_non_results_expression

from libvvtest.paramexpr import ParameterExpression
from libvvtest.paramexpr import create_parameter_expression

from libvvtest.parseutil import parse_to_word_expression


class word_expression_tests( vtu.vvtestTestCase ):

    def setUp(self):
        vtu.vvtestTestCase.setUp( self, cleanout=False )

    def test_WordExpression_use_cases(self):
        ""
        ex = WordExpression()
        assert ex.evaluate( [] )

        ex.append(None)
        assert ex.evaluate( [] )

        ex = WordExpression('')
        assert not ex.evaluate( [] )

        ex.append('')
        assert not ex.evaluate( [] )

        ex.append("")
        assert not ex.evaluate( [] )

        ex.append(" ")
        assert not ex.evaluate( [] )

        ex = WordExpression(" ")
        assert not ex.evaluate( [] )

        ex = WordExpression(" hello  ")
        assert not ex.evaluate( [] )
        assert ex.evaluate( 'hello' )
        assert not ex.evaluate( 'world' )

        ex.append(None)
        assert not ex.evaluate( [] )
        assert ex.evaluate( 'hello' )
        assert not ex.evaluate( 'world' )

        ex.append("")
        assert not ex.evaluate( [] )
        assert not ex.evaluate( 'hello' )
        assert not ex.evaluate( 'world' )

        ex.append("  ")
        assert not ex.evaluate( [] )
        assert not ex.evaluate( 'hello' )
        assert not ex.evaluate( 'world' )

        ex.append("world")
        assert not ex.evaluate( [] )
        assert not ex.evaluate( 'hello' )
        assert not ex.evaluate( 'world' )
        assert not ex.evaluate( ['hello','world'] )
        assert not ex.evaluate( ['the','next'] )

    def test_expression_and_or_precedence(self):
        ""
        ex = WordExpression("hello and world or period")
        assert not ex.evaluate( 'hello' )
        assert not ex.evaluate( 'world' )
        assert     ex.evaluate( 'period' )
        assert     ex.evaluate( ['hello','world'] )

        ex = WordExpression("(hello and world) or period")
        assert not ex.evaluate( 'hello' )
        assert not ex.evaluate( 'world' )
        assert     ex.evaluate( 'period' )
        assert     ex.evaluate( ['hello','world'] )

        ex = WordExpression("hello or world and period")
        assert     ex.evaluate( 'hello' )
        assert not ex.evaluate( 'world' )
        assert not ex.evaluate( 'period' )
        assert     ex.evaluate( ['hello','period'] )
        assert     ex.evaluate( ['world','period'] )

        ex = WordExpression("hello or (world and period)")
        assert     ex.evaluate( 'hello' )
        assert not ex.evaluate( 'world' )
        assert not ex.evaluate( 'period' )
        assert     ex.evaluate( ['hello','period'] )
        assert     ex.evaluate( ['world','period'] )

    def test_expression_errors(self):
        ""
        ex = WordExpression()

        self.assertRaises( ValueError, WordExpression, "aword1) word2" )
        self.assertRaises( ValueError, WordExpression, "word1 not word2" )
        self.assertRaises( ValueError, WordExpression, "word1 word2" )
        self.assertRaises( ValueError, WordExpression, "word1 and" )
        self.assertRaises( ValueError, WordExpression, "word1 or" )
        self.assertRaises( ValueError, WordExpression, "(word or)" )
        self.assertRaises( ValueError, WordExpression, "(word and)" )
        self.assertRaises( ValueError, WordExpression, "word and ()" )
        self.assertRaises( ValueError, WordExpression, "()" )
        self.assertRaises( ValueError, WordExpression, "word1 and and word2" )
        self.assertRaises( ValueError, WordExpression, "word1 and or word2" )
        self.assertRaises( ValueError, WordExpression, "word1 or and word2" )
        self.assertRaises( ValueError, WordExpression, "word1 or not or word2" )
        self.assertRaises( ValueError, WordExpression, "word1 and not and word2" )
        self.assertRaises( ValueError, WordExpression, "and word1" )
        self.assertRaises( ValueError, WordExpression, "or word1" )
        self.assertRaises( ValueError, WordExpression, "word1 word2" )
        self.assertRaises( ValueError, WordExpression, "word and" )
        self.assertRaises( ValueError, WordExpression, "word or" )

    def test_using_parens_in_expressions(self):
        ""
        ex = WordExpression("( word1 and word2 ) or (word3 and word4)")
        assert     ex.evaluate( ['word1','word2'] )
        assert     ex.evaluate( ['word3','word4'] )
        assert not ex.evaluate( ['word1','word3'] )
        assert not ex.evaluate( ['word2','word4'] )

        ex = WordExpression("( word1 and not (word2 or word3) ) or word4")
        assert     ex.evaluate( ['word4'] )
        assert     ex.evaluate( ['word1'] )
        assert not ex.evaluate( ['word1','word2'] )
        assert not ex.evaluate( ['word1','word3'] )

        ex = WordExpression("word1 and not (word2 or word3) or word4")
        assert     ex.evaluate( ['word4'] )
        assert     ex.evaluate( ['word1'] )
        assert not ex.evaluate( ['word1','word2'] )
        assert not ex.evaluate( ['word1','word3'] )

        ex = WordExpression("word4 or word1 and not (word2 or word3)")
        assert     ex.evaluate( ['word4'] )
        assert     ex.evaluate( ['word1'] )
        assert not ex.evaluate( ['word1','word2'] )
        assert not ex.evaluate( ['word1','word3'] )

    def test_get_word_list_after_construction(self):
        ""
        ex = WordExpression( "word4 or word1 and not (word2 or word3 )" )
        wL = ex.getWordList()
        wL.sort()
        assert wL == ['word1','word2','word3','word4']

        ex = WordExpression()
        assert ex.getWordList() == []

        ex = WordExpression( '' )
        assert ex.getWordList() == []

    def test_tokenizing_expressions(self):
        ""
        assert split_but_retain_separator( '', '(' ) == ['']
        assert split_but_retain_separator( ' ', '(' ) == [' ']
        assert split_but_retain_separator( 'abc', '(' ) == ['abc']
        assert split_but_retain_separator( '(', '(' ) == ['','(','']
        assert split_but_retain_separator( 'a(', '(' ) == ['a','(','']
        assert split_but_retain_separator( '(b', '(' ) == ['','(','b']
        assert split_but_retain_separator( 'a(b', '(' ) == ['a','(','b']
        assert split_but_retain_separator( 'a(b (c(', '(' ) == \
                                           ['a','(','b ','(','c','(','']
        assert split_but_retain_separator( ')a)b', ')' ) == \
                                           ['',')','a',')','b']

        assert separate_expression_into_tokens( '' ) == ['']
        assert separate_expression_into_tokens( ' ' ) == ['']
        assert separate_expression_into_tokens( 'word' ) == ['word']
        assert separate_expression_into_tokens( ' word ' ) == ['word']
        assert separate_expression_into_tokens( 'word1  or word2 ' ) == \
                                            ['word1','or','word2']
        assert separate_expression_into_tokens( ' not  word' ) == \
                                            ['not','word']
        assert separate_expression_into_tokens( ' not ( word )' ) == \
                                            ['not','(','word',')']
        assert separate_expression_into_tokens( ' not(word) ' ) == \
                                            ['not','(','word',')']
        assert separate_expression_into_tokens(
            'not ( word1 or word2) and word3 or (word4)' ) == \
            ['not','(','word1','or','word2',')','and','word3','or','(','word4',')']

    def test_creating_eval_string(self):
        ""
        def evalfunc(tok):
            assert tok != None and tok.strip()
            return tok == 'word'

        es = convert_token_list_into_eval_string( [''] )
        val = eval( es )
        assert val == False and type(val) == type(True)

        es = convert_token_list_into_eval_string( ['not','word'] )
        val = eval( es )
        assert val == False and type(val) == type(True)

        es = convert_token_list_into_eval_string( ['not','foo'] )
        val = eval( es )
        assert val == True and type(val) == type(True)

        es = convert_token_list_into_eval_string( ['not','(','foo',')'] )
        val = eval( es )
        assert val == True and type(val) == type(True)

        es = convert_token_list_into_eval_string( ['(','word',')'] )
        val = eval( es )
        assert val == True and type(val) == type(True)

        es = convert_token_list_into_eval_string(
                                    ['(','word',')','or','not','word'] )
        val = eval( es )
        assert val == True and type(val) == type(True)

    def test_an_exclamation_point_means_NOT(self):
        ""
        for expr in ['!foo','! foo','not foo']:
            ex = WordExpression( expr )
            assert not ex.evaluate( 'foo' )
            assert     ex.evaluate( 'bar' )

        for expr in ['foo or !bar','foo or ! bar']:
            ex = WordExpression( expr )
            assert     ex.evaluate( 'foo' )
            assert not ex.evaluate( 'bar' )
            assert     ex.evaluate( ['foo','bar'] )
            assert     ex.evaluate( 'baz' )

        for expr in ['!(foo or bar)','! (foo or bar)']:
            ex = WordExpression( expr )
            assert not ex.evaluate( 'foo' )
            assert not ex.evaluate( 'bar' )
            assert not ex.evaluate( ['foo','bar'] )
            assert     ex.evaluate( 'baz' )

        for expr in ['!(foo and bar)','! (foo and bar)']:
            ex = WordExpression( expr )
            assert     ex.evaluate( ['foo'] )
            assert     ex.evaluate( ['bar'] )
            assert not ex.evaluate( ['foo','bar'] )
            assert     ex.evaluate( ['baz'] )

    def test_replace_forward_slashes(self):
        ""
        assert replace_forward_slashes( 'foo' ) == 'foo'
        assert replace_forward_slashes( 'foo', True ) == 'not foo'
        assert replace_forward_slashes( 'foo and bar' ) == 'foo and bar'
        assert replace_forward_slashes( 'foo and bar', True ) == \
                                            'not ( foo and bar )'

        assert replace_forward_slashes( 'foo/bar' ) == 'foo or bar'
        assert replace_forward_slashes( 'foo/ bar' ) == 'foo or bar'
        assert replace_forward_slashes( 'foo / bar' ) == 'foo or bar'
        assert replace_forward_slashes( 'foo /bar' ) == 'foo or bar'
        assert replace_forward_slashes( 'foo/bar/baz' ) == 'foo or bar or baz'
        assert replace_forward_slashes( 'foo/!bar/baz' ) == 'foo or !bar or baz'

        assert replace_forward_slashes( 'foo', True ) == 'not foo'
        assert replace_forward_slashes( 'foo/bar', True ) == 'not foo or not bar'
        assert replace_forward_slashes( 'foo/!bar/baz', True ) == \
                                            'not foo or not !bar or not baz'

        assert replace_forward_slashes( '/foo/bar' ) == 'foo or bar'
        assert replace_forward_slashes( 'foo/bar/' ) == 'foo or bar'
        assert replace_forward_slashes( 'foo/not bar' ) == 'foo or not bar'

        self.assertRaises( ValueError, replace_forward_slashes, 'foo/(not bar)' )
        self.assertRaises( ValueError, replace_forward_slashes, 'foo or bar / baz' )
        self.assertRaises( ValueError, replace_forward_slashes, 'foo / bar and baz' )
        self.assertRaises( ValueError, replace_forward_slashes, 'foo/(bar)' )

    def test_parenthetical_tokenize(self):
        ""
        px = parenthetical_tokenize( 'foo' ) ; assert px.toks == ['foo']
        px = parenthetical_tokenize( 'not foo' ) ; assert px.toks == ['not','foo']
        px = parenthetical_tokenize( '! foo' ) ; assert px.toks == ['not','foo']
        px = parenthetical_tokenize( '!foo' ) ; assert px.toks == ['not','foo']

        px = parenthetical_tokenize( 'foo or bar' )
        assert px.toks == ['foo','or','bar']

        px = parenthetical_tokenize( '(foo)' )
        assert px.numTokens() == 1
        assert px.toks[0].toks == ['foo']

        px = parenthetical_tokenize( '(foo or bar)' )
        assert px.numTokens() == 1
        assert px.toks[0].toks == ['foo','or','bar']

        px = parenthetical_tokenize( '!(foo or bar)' )
        assert px.numTokens() == 2
        assert px.toks[0] == 'not'
        assert px.toks[1].toks == ['foo','or','bar']

        px = parenthetical_tokenize( 'foo or (bar and baz)' )
        assert px.numTokens() == 3
        assert px.toks[:2] == ['foo','or']
        assert px.toks[2].toks == ['bar','and','baz']

        px = parenthetical_tokenize( '(foo) or (bar)' )
        assert px.numTokens() == 3
        assert px.toks[0].toks == ['foo']
        assert px.toks[1] == 'or'
        assert px.toks[2].toks == ['bar']

        px = parenthetical_tokenize( '((foo or bar))' )
        assert px.numTokens() == 1
        assert px.toks[0].numTokens() == 1
        assert px.toks[0].toks[0].toks == ['foo','or','bar']

    def test_conditional_paren_wrap(self):
        ""
        assert conditional_paren_wrap( 'foo' ) == 'foo'
        assert conditional_paren_wrap( 'foo or bar' ) == '( foo or bar )'
        assert conditional_paren_wrap( 'not foo' ) == 'not foo'
        assert conditional_paren_wrap( '! foo' ) == '! foo'
        assert conditional_paren_wrap( '!foo' ) == '!foo'
        assert conditional_paren_wrap( '(foo)' ) == '(foo)'
        assert conditional_paren_wrap( '( foo )' ) == '( foo )'
        assert conditional_paren_wrap( '(foo or bar)' ) == '(foo or bar)'
        assert conditional_paren_wrap( '( foo or bar )' ) == '( foo or bar )'

    def test_join_expressions_with_AND(self):
        ""
        assert join_expressions_with_AND( [] ) == None
        assert join_expressions_with_AND( [''] ) == ''
        assert join_expressions_with_AND( ['foo',''] ) == ''
        assert join_expressions_with_AND( ['','foo'] ) == ''
        assert join_expressions_with_AND( ['foo','bar'] ) == 'foo and bar'
        assert join_expressions_with_AND( ['foo or bar'] ) == 'foo or bar'
        assert join_expressions_with_AND( ['foo or bar','baz'] ) == \
                                                '( foo or bar ) and baz'
        assert join_expressions_with_AND( ['foo','bar or baz'] ) == \
                                                'foo and ( bar or baz )'
        assert join_expressions_with_AND( ['( foo or bar )'] ) == \
                                                '( foo or bar )'
        assert join_expressions_with_AND( ['( foo or bar ) and baz'] ) == \
                                                '( foo or bar ) and baz'
        assert join_expressions_with_AND( ['( foo or bar ) and baz','yep'] ) == \
                                    '( ( foo or bar ) and baz ) and yep'

    def test_processing_forward_slash_and_negation(self):
        ""
        for expr in ['foo/bar','foo / bar','foo/ bar','foo /bar']:
            ex = create_word_expression( [expr] )
            assert     ex.evaluate( 'foo' )
            assert     ex.evaluate( 'bar' )
            assert     ex.evaluate( ['bar','foo'] )
            assert not ex.evaluate( 'baz' )

        for expr in ['!foo/bar','!foo / bar','!foo/ bar','!foo /bar',
                     'not foo/bar','not foo / bar','not foo/ bar','not foo /bar' ]:
            ex = create_word_expression( [expr] )
            assert not ex.evaluate( 'foo' )
            assert     ex.evaluate( 'bar' )
            assert     ex.evaluate( ['bar','foo'] )
            assert     ex.evaluate( 'baz' )

        for expr in ['foo/!bar','foo / !bar','foo/ !bar','foo /!bar',
                     'foo/not bar','foo / not bar','foo/ not bar','foo /not bar' ]:
            ex = create_word_expression( [expr] )
            assert     ex.evaluate( 'foo' )
            assert not ex.evaluate( 'bar' )
            assert     ex.evaluate( ['bar','foo'] )
            assert     ex.evaluate( 'baz' )

        # cannot have '/' in an expr with parens
        for expr in ['not ( foo/bar and baz )','! (foo/bar and baz)',
                     'not( foo/bar and baz )','!(foo/bar and baz)']:
            self.assertRaises( ValueError, create_word_expression, [expr] )

        # cannot have '/' in an expr with AND or OR
        for expr in ['foo/bar and baz','foo/bar or baz',
                     'baz and foo/bar','baz or foo/bar']:
            self.assertRaises( ValueError, create_word_expression, [expr] )


class wildcard_word_expression_tests( vtu.vvtestTestCase ):

    def setUp(self):
        vtu.vvtestTestCase.setUp( self, cleanout=False )

    def test_shell_style_wildcards_in_expressions(self):
        ""
        ex = WordExpression( 'foo*' )
        assert not ex.evaluate( 'foobar' )

        ex = WildcardWordExpression( 'foo*' )
        assert     ex.evaluate( 'foobar' )
        assert not ex.evaluate( 'fobar' )
        assert not ex.evaluate( 'bazfoobar' )
        assert     ex.evaluate( ['fo','fo o','fool'] )

        ex = WildcardWordExpression( 'foo?' )
        assert not ex.evaluate( 'foo' )
        assert     ex.evaluate( 'fool' )
        assert not ex.evaluate( 'fools' )


class keyword_expression_tests( vtu.vvtestTestCase ):

    def setUp(self):
        vtu.vvtestTestCase.setUp( self, cleanout=False )

    def test_removing_results_keywords_from_an_expression(self):
        ""
        func = make_non_results_expression  # for testing convenience

        assert func( '' ) == ''
        assert func( 'foo' ) == 'foo'
        assert func( 'foo or bar' ) == 'foo or bar'
        assert func( 'foo and (not bar)' ) == 'foo and ( not bar )'
        assert func( 'foo and not bar' ) == 'foo and not bar'

        assert func( 'notrun' ) == None
        assert func( 'not pass' ) == None
        assert func( 'not ( pass or diff )' ) == None
        assert func( '(pass or diff) or (notrun or fail)' ) == None
        assert func( '(notrun or notdone) and fail' ) == None
        assert func( 'not (fail or (notrun or notdone) )' ) == None

        assert func( 'word and fail' ) == 'word'
        assert func( 'not word and fail' ) == 'not word'
        assert func( 'word and not fail' ) == 'word'
        assert func( 'fail and not word' ) == 'not word'
        assert func( 'fail and (not word)' ) == 'not word'
        assert func( '(not word) and fail' ) == 'not word'
        assert func( 'notrun or (fail and word)' ) == 'word'
        assert func( '(fail and word) or notrun' ) == 'word'
        assert func( 'not ( (fail and word) or notrun )' ) == 'not word'

        assert func( '(foo or word) and (pass or fail)' ) == 'foo or word'
        assert func( '(foo and pass) or (bar and fail)' ) == 'foo or bar'

        assert func( 'foo or not (bar and fail)' ) == 'foo or not bar'
        assert func( 'not ( (foo or pass) )' ) == 'not foo'
        assert func( 'not ( (foo or bar) )' ) == 'not ( foo or bar )'

    def test_expressions_with_results_keywords(self):
        ""
        ex = KeywordExpression( 'foo and fail' )
        assert not ex.evaluate( [] )
        assert not ex.evaluate( [], include_results=False )
        assert not ex.evaluate( ['foo'] )
        assert     ex.evaluate( ['foo'], include_results=False )

        ex = KeywordExpression( 'foo' )
        assert     ex.evaluate( ['foo'] )
        assert     ex.evaluate( ['foo'], include_results=False )
        ex.appendKeywordExpression( 'notdone or notrun' )
        assert not ex.evaluate( ['foo','pass'] )
        assert     ex.evaluate( ['foo','pass'], include_results=False )
        assert     ex.evaluate( ['foo','notdone'] )
        assert     ex.evaluate( ['foo','notdone'], include_results=False )
        assert     ex.evaluate( ['foo','notrun'] )
        assert     ex.evaluate( ['foo','notrun'], include_results=False )

    def test_keyword_expression_evaluation(self):
        ""
        ex = KeywordExpression()
        assert ex.evaluate( [] )
        assert ex.evaluate( ['foo'] )
        assert ex.evaluate( [], include_results=False )
        assert ex.evaluate( ['foo'], include_results=False )

        ex = KeywordExpression( '' )
        assert not ex.evaluate( [] )
        assert not ex.evaluate( ['foo'] )
        assert not ex.evaluate( [], include_results=False )
        assert not ex.evaluate( ['foo'], include_results=False )

        ex = KeywordExpression( 'foo and bar' )
        assert not ex.evaluate( [] )
        assert not ex.evaluate( ['foo'] )
        assert not ex.evaluate( ['bar'] )
        assert     ex.evaluate( ['foo','bar'] )
        assert not ex.evaluate( [], include_results=False )
        assert not ex.evaluate( ['foo'], include_results=False )
        assert not ex.evaluate( ['bar'], include_results=False )
        assert     ex.evaluate( ['foo','bar'], include_results=False )

    def test_creating_unified_keyword_expression(self):
        ""
        kx = create_keyword_expression( None, None )
        assert kx == None

        kx = create_keyword_expression( ['foo'], None )
        assert not kx.evaluate( ['bar'] )
        assert     kx.evaluate( ['foo'] )

        kx = create_keyword_expression( None, ['bar'] )
        assert not kx.evaluate( ['bar'] )
        assert     kx.evaluate( ['foo'] )

        kx = create_keyword_expression( ['foo'], ['bar'] )
        assert     kx.evaluate( ['foo'] )
        assert not kx.evaluate( ['foo','bar'] )

        self.assertRaises( Exception,
                           create_keyword_expression, ['foo )'], None )
        self.assertRaises( Exception,
                           create_keyword_expression, None, ['foo )'] )
        self.assertRaises( Exception,
                           create_keyword_expression, ['foo and or bar'], None )
        self.assertRaises( Exception,
                           create_keyword_expression, ['foo$bar'], None )
        self.assertRaises( Exception,
                           create_keyword_expression, None, ['foo$bar'] )

    def test_wildcard_globbing_in_keyword_expression(self):
        ""
        kx = create_keyword_expression( ['foo*'], None )
        assert     kx.evaluate( ['foo'] )
        assert     kx.evaluate( ['foobar'] )
        assert not kx.evaluate( ['bazfoobar'] )

        kx = create_keyword_expression( None, ['foo*'] )
        assert not kx.evaluate( ['foo'] )
        assert not kx.evaluate( ['foobar'] )
        assert     kx.evaluate( ['bazfoobar'] )


class param_expression_tests( vtu.vvtestTestCase ):

    def setUp(self):
        vtu.vvtestTestCase.setUp( self, cleanout=False )

    def test_parameter_expressions_with_integer_param_types(self):
        ""
        pf = ParameterExpression( 'np=4' )
        assert not pf.evaluate( {} )
        assert     pf.evaluate( {'np':4} )
        assert not pf.evaluate( {'np':2} )
        assert not pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {'size':"10", 'np':4} )
        assert not pf.evaluate( {'size':"10"} )

        pf = ParameterExpression( replace_forward_slashes('np=1/np=4') )
        assert not pf.evaluate( {} )
        assert     pf.evaluate( {'np':4} )
        assert     pf.evaluate( {'np':1} )
        assert     pf.evaluate( {'size':"10", 'np':4} )
        assert not pf.evaluate( {'np':3} )
        assert not pf.evaluate( {'size':"10", 'np':3} )
        assert not pf.evaluate( {'size':"10"} )

        pf = ParameterExpression( replace_forward_slashes('np=1/!np') )
        assert not pf.evaluate( {'np':4} )
        assert     pf.evaluate( {'np':1} )
        assert     pf.evaluate( {'size':"10", 'np':1} )
        assert     pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {} )

        pf = ParameterExpression( replace_forward_slashes('np=1/np!=') )
        assert not pf.evaluate( {'np':4} )
        assert     pf.evaluate( {'np':1} )
        assert     pf.evaluate( {'size':"10", 'np':1} )
        assert     pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {} )

        pf = ParameterExpression( '!np' )
        assert not pf.evaluate( {'np':4} )
        assert not pf.evaluate( {'size':"10", 'np':1} )
        assert     pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {} )

        pf = ParameterExpression( 'np=1', 'size' )
        assert not pf.evaluate( {'np':4} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {'size':"10", 'np':4} )
        assert     pf.evaluate( {'size':"10", 'np':1} )
        assert not pf.evaluate( {} )

        pf = ParameterExpression( 'np=1', 'size=' )
        assert not pf.evaluate( {'np':4} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {'size':"10", 'np':4} )
        assert     pf.evaluate( {'size':"10", 'np':1} )
        assert not pf.evaluate( {} )

        pf = ParameterExpression( 'np!=1', 'np!=4' )
        assert not pf.evaluate( {'np':1} )
        assert not pf.evaluate( {'np':4} )
        assert     pf.evaluate( {'np':2} )

        pf = ParameterExpression( 'np<=13' )
        assert     pf.evaluate( {'np':2} )
        assert not pf.evaluate( {'np':14} )
        assert     pf.evaluate( {'np':13} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

        pf = ParameterExpression( 'np>=13' )
        assert not pf.evaluate( {'np':2} )
        assert     pf.evaluate( {'np':13} )
        assert     pf.evaluate( {'np':14} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

        pf = ParameterExpression( 'np<13' )
        assert     pf.evaluate( {'np':2} )
        assert not pf.evaluate( {'np':14} )
        assert not pf.evaluate( {'np':15} )
        assert not pf.evaluate( {'np':13} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

        pf = ParameterExpression( 'np>13' )
        assert not pf.evaluate( {'np':2} )
        assert not pf.evaluate( {'np':13} )
        assert     pf.evaluate( {'np':14} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

    def test_parameter_expressions_with_string_param_types(self):
        ""
        pf = ParameterExpression( 'np=4' )
        assert not pf.evaluate( {} )
        assert     pf.evaluate( {'np':'4'} )
        assert not pf.evaluate( {'np':'2'} )
        assert not pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {'size':"10", 'np':'4'} )
        assert not pf.evaluate( {'size':"10"} )

        pf = ParameterExpression( replace_forward_slashes('np=1/np=4') )
        assert not pf.evaluate( {} )
        assert     pf.evaluate( {'np':'4'} )
        assert     pf.evaluate( {'np':'1'} )
        assert     pf.evaluate( {'size':"10", 'np':'4'} )
        assert not pf.evaluate( {'np':'3'} )
        assert not pf.evaluate( {'size':"10", 'np':'3'} )
        assert not pf.evaluate( {'size':"10"} )

        pf = ParameterExpression( replace_forward_slashes('np=1/!np') )
        assert not pf.evaluate( {'np':'4'} )
        assert     pf.evaluate( {'np':'1'} )
        assert     pf.evaluate( {'size':"10", 'np':'1'} )
        assert     pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {} )

        pf = ParameterExpression( replace_forward_slashes('np=1/np!=') )
        assert not pf.evaluate( {'np':'4'} )
        assert     pf.evaluate( {'np':'1'} )
        assert     pf.evaluate( {'size':"10", 'np':'1'} )
        assert     pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {} )

        pf = ParameterExpression( '!np' )
        assert not pf.evaluate( {'np':'4'} )
        assert not pf.evaluate( {'size':"10", 'np':'1'} )
        assert     pf.evaluate( {'size':"10"} )
        assert     pf.evaluate( {} )

        pf = ParameterExpression( 'np=1', 'size' )
        assert not pf.evaluate( {'np':'4'} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {'size':"10", 'np':'4'} )
        assert     pf.evaluate( {'size':"10", 'np':'1'} )
        assert not pf.evaluate( {} )

        pf = ParameterExpression( 'np=1', 'size=' )
        assert not pf.evaluate( {'np':'4'} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {'size':"10", 'np':'4'} )
        assert     pf.evaluate( {'size':"10", 'np':'1'} )
        assert not pf.evaluate( {} )

        pf = ParameterExpression( 'np!=1', 'np!=4' )
        assert not pf.evaluate( {'np':'1'} )
        assert not pf.evaluate( {'np':'4'} )
        assert     pf.evaluate( {'np':'2'} )

        pf = ParameterExpression( 'np<=13' )
        assert     pf.evaluate( {'np':'2'} )
        assert not pf.evaluate( {'np':'20'} )
        assert     pf.evaluate( {'np':'13'} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

        pf = ParameterExpression( 'np>=13' )
        assert not pf.evaluate( {'np':'2'} )
        assert     pf.evaluate( {'np':'13'} )
        assert     pf.evaluate( {'np':'20'} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

        pf = ParameterExpression( 'np<13' )
        assert     pf.evaluate( {'np':'2'} )
        assert not pf.evaluate( {'np':'20'} )
        assert not pf.evaluate( {'np':'15'} )
        assert not pf.evaluate( {'np':'13'} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

        pf = ParameterExpression( 'np>13' )
        assert not pf.evaluate( {'np':'2'} )
        assert not pf.evaluate( {'np':'13'} )
        assert     pf.evaluate( {'np':'14'} )
        assert not pf.evaluate( {'size':"10"} )
        assert not pf.evaluate( {} )

    def test_parameter_expressions_with_mixed_types(self):
        ""
        pf = ParameterExpression( 'np=13' )
        assert not pf.evaluate( {'np':'a'} )

        pf = ParameterExpression( 'np=ab' )
        assert not pf.evaluate( {'np':'13'} )

        pf = ParameterExpression( 'np=ab' )
        assert     pf.evaluate( {'np':'ab'} )


        pf = ParameterExpression( 'np!=13' )
        assert     pf.evaluate( {'np':'a'} )

        pf = ParameterExpression( 'np!=ab' )
        assert     pf.evaluate( {'np':'13'} )

        pf = ParameterExpression( 'np!=ab' )
        assert not pf.evaluate( {'np':'ab'} )


        pf = ParameterExpression( 'np<=13' )
        assert not pf.evaluate( {'np':'a'} )

        pf = ParameterExpression( 'np<=13' )
        assert     pf.evaluate( {'np':'0a'} )

        pf = ParameterExpression( 'np<=ab' )
        assert     pf.evaluate( {'np':'13'} )

        pf = ParameterExpression( 'np<=ab' )
        assert     pf.evaluate( {'np':'ab'} )


        pf = ParameterExpression( 'np>=13' )
        assert     pf.evaluate( {'np':'a'} )

        pf = ParameterExpression( 'np>=13' )
        assert not pf.evaluate( {'np':'0a'} )

        pf = ParameterExpression( 'np>=ab' )
        assert not pf.evaluate( {'np':'13'} )

        pf = ParameterExpression( 'np>=ab' )
        assert     pf.evaluate( {'np':'ab'} )


        pf = ParameterExpression( 'np<13' )
        assert not pf.evaluate( {'np':'a'} )

        pf = ParameterExpression( 'np<13' )
        assert     pf.evaluate( {'np':'0a'} )

        pf = ParameterExpression( 'np<ab' )
        assert     pf.evaluate( {'np':'13'} )

        pf = ParameterExpression( 'np<ab' )
        assert not pf.evaluate( {'np':'ab'} )


        pf = ParameterExpression( 'np>13' )
        assert     pf.evaluate( {'np':'a'} )

        pf = ParameterExpression( 'np>13' )
        assert not pf.evaluate( {'np':'0a'} )

        pf = ParameterExpression( 'np>ab' )
        assert not pf.evaluate( {'np':'13'} )

        pf = ParameterExpression( 'np>ab' )
        assert not pf.evaluate( {'np':'ab'} )

    def test_behavior_of_the_NOT_operator_on_param_expressions(self):
        ""
        pf = ParameterExpression( 'np' )
        assert not pf.evaluate( {} )
        assert not pf.evaluate( { 'foo':5 } )
        assert     pf.evaluate( { 'np':2 } )

        for expr in [ '!np', ' not np' ]:
            pf = ParameterExpression( expr )
            assert     pf.evaluate( {} )
            assert     pf.evaluate( { 'foo':5 } )
            assert not pf.evaluate( { 'np':2 } )

        pf = ParameterExpression( 'np>2' )
        assert not pf.evaluate( {} )
        assert not pf.evaluate( {'foo':5} )
        assert not pf.evaluate( {'np':2} )
        assert     pf.evaluate( {'np':3} )

        # Note: the expr np<=2 is not the same as !np>2
        #       this is because np<=2 actually means
        #           (np is defined) AND (np<=2)
        #       and therefore !np<=2 actually means
        #           NOT [ (np is defined) AND (np<=2) ]
        #       which equals
        #           (np is not defined) OR (np>2)

        pf = ParameterExpression( 'np<=2' )
        assert     pf.evaluate( {'np':2} )
        assert not pf.evaluate( {'np':3} )
        assert not pf.evaluate( {} )
        assert not pf.evaluate( { 'foo':5 } )

        for expr in [ '!np>2', 'not np>2' ]:
            pf = ParameterExpression( expr )
            assert     pf.evaluate( {'np':2} )
            assert not pf.evaluate( {'np':3} )
            assert     pf.evaluate( {} )
            assert     pf.evaluate( { 'foo':5 } )

        for expr in [ '!np>3 and np!=1', 'not np>3 and np!=1' ]:
            pf = ParameterExpression( expr )
            assert not pf.evaluate( {'np':1} )
            assert     pf.evaluate( {'np':2} )
            assert     pf.evaluate( {'np':3} )
            assert not pf.evaluate( {'np':4} )

    def test_errors_and_corner_cases(self):
        ""
        pf = ParameterExpression( 'foo<=bar@3' )
        assert pf.evaluate( {'foo':'bar@2'} )

        self.assertRaises( ValueError, ParameterExpression, 'foo@=bar' )
        self.assertRaises( ValueError, ParameterExpression, '=bar' )
        self.assertRaises( ValueError, ParameterExpression, 'foo=b$ar' )
        self.assertRaises( ValueError, ParameterExpression, 'foo=b*ar' )

    def test_creating_unified_parameter_expression(self):
        ""
        pf = create_parameter_expression( None, None )
        assert pf == None

        pf = create_parameter_expression( ['np=1'], None )
        assert pf.evaluate( {'np':'1'} )

        pf = create_parameter_expression( None, ['np=1'] )
        assert not pf.evaluate( {'np':'1'} )

        pf = create_parameter_expression( ['np<8'], ['np=1/ndevice'] )
        assert     pf.evaluate( {'np':'2'} )
        assert     pf.evaluate( {'np':'1'} )
        assert not pf.evaluate( {'np':'1', 'ndevice':'1'} )
        assert     pf.evaluate( {'np':'2', 'ndevice':'1'} )
        assert not pf.evaluate( {'np':'9', 'ndevice':'1'} )

    def test_parse_to_word_expression_utility(self):
        ""
        wx = parse_to_word_expression( '' )
        assert not wx.evaluate( 'foo' )

        wx = parse_to_word_expression( 'foo or bar', 10 )
        assert     wx.evaluate( 'foo' )
        assert     wx.evaluate( 'bar' )
        assert     wx.evaluate( ['bar','foo'] )
        assert not wx.evaluate( 'baz' )

        self.assertRaises( TestSpecError,
                           parse_to_word_expression, 'foo or b$ar' )


############################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
