#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST:

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import time

import vvtestutils as vtu
import testutils as util
from testutils import print3


class Simple_Aprepro( vtu.vvtestTestCase ):

    def test_division(self):
        ""
        util.writefile( 'values.aprepro', """
            # {secret = 1 / 9}
            """ )
        util.writefile( 'test_division.py.vvt', """
            #VVT: copy : values.aprepro
            import script_util as util

            apr = util.simple_aprepro("values.aprepro", None)
            print("this is apr", apr)

            assert apr['secret'] != 0  # this would be true for integer division
            assert apr['secret'] == float(1.0 / 9.0)  # this is a float
            """ )
        time.sleep(1)

        for batch in [False,True]:

            vtu.remove_results()

            vtu.runvvtest( batch=batch ).assertCounts( total=1, npass=1 )

    def test_simple1(self):
        ""
        util.writefile( 'values.aprepro', """
            # {secret = 3 * 6}
            """ )
        util.writefile( 'testA.py.vvt', """
            #VVT: copy : values.aprepro
            import script_util as util

            apr = util.simple_aprepro("values.aprepro", None)

            assert apr['secret'] == 18
            """ )
        time.sleep(1)

        for batch in [False,True]:

            vtu.remove_results()

            vtu.runvvtest( batch=batch ).assertCounts( total=1, npass=1 )

    def test_simple2(self):
        ""
        util.writefile( 'values.aprepro', """
            # {first_secret = 2 * 5 - 3}
            """ )
        util.writefile( 'input.yaml.apr', """
            # 'first_secret' should be overridden
            # {first_secret = 1}
            # {second_secret = first_secret + 1}
            """ )
        util.writefile( 'testA.py.vvt', """
            #VVT: copy : values.aprepro input.yaml.apr
            import script_util as util

            apr = util.simple_aprepro("values.aprepro", None)
            apr = util.simple_aprepro("input.yaml.apr", "input.yaml", override=apr)

            assert apr['first_secret'] == 7
            assert apr['second_secret'] == 8
            """ )
        time.sleep(1)

        for batch in [False,True]:

            vtu.remove_results()

            vtu.runvvtest( batch=batch ).assertCounts( total=1, npass=1 )

    def test_simple3(self):
        """
        The only difference between txt_out1 and txt_out2 is one extra digit
        of precision for problems between python2 and python3.
        """
        txt_in = """# abc = { abc = PI }
            # abc = { abc }
            # xyz = { xyz = 123.456 }
            # xyz = { xyz }"""
        txt_out1 = """# abc = 3.141592653589793
            # abc = 3.141592653589793
            # xyz = 123.456
            # xyz = 123.456"""
        txt_out2 = """# abc = 3.1415926535897931
            # abc = 3.1415926535897931
            # xyz = 123.456
            # xyz = 123.456"""
        util.writefile( 'values.aprepro', txt_in )
        util.writefile( 'values.gold1', txt_out1 )
        util.writefile( 'values.gold2', txt_out2 )
        util.writefile( 'testA.py.vvt', """
            #VVT: copy : values.aprepro values.gold1 values.gold2
            import math
            import script_util as util

            apr = util.simple_aprepro("values.aprepro", "values.comp")

            assert apr == {'abc': math.pi, 'xyz': 123.456}

            with open("values.gold1", 'r') as F:
                gold1 = F.read()
            print("gold1", gold1)

            with open("values.gold2", 'r') as F:
                gold2 = F.read()
            print("gold2", gold2)

            with open("values.comp", 'r') as F:
                comp = F.read()
            print("comp", comp)

            assert (gold1 == comp) or (gold2 == comp)
            """ )
        time.sleep(1)

        for batch in [False,True]:

            vtu.remove_results()

            vtu.runvvtest( batch=batch ).assertCounts( total=1, npass=1 )

    def test_escaped_curly_braces(self):
        """
        This test makes sure that it correctly fixes escaped curly
        braces. The test includes
          * escaped start and end braces
          * escaped start brace
          * escaped end brace
          * escaped braces before and after
        """
        util.writefile( 'values.aprepro', """
            # {baz = 3 * 6}
            if (foo == 1) \{bar = {baz}\}
            if (foo == 2) \{bar = {baz}
            \}
            if (foo == 3) \{
              bar = {baz}\}
            if (foo == 4) \{
              bar = {baz}
            \}
            """ )
        util.writefile( 'values.aprepro.gold', """
            # 18
            if (foo == 1) {bar = 18}
            if (foo == 2) {bar = 18
            }
            if (foo == 3) {
              bar = 18}
            if (foo == 4) {
              bar = 18
            }
            """ )
        util.writefile( 'testCurlyBrace.py.vvt', """
            #VVT: copy : values.aprepro values.aprepro.gold
            import script_util as util

            apr = util.simple_aprepro("values.aprepro", "values.aprepro.comp")

            with open("values.aprepro.comp", "r") as F:
                comp = F.readlines()

            with open("values.aprepro.gold", "r") as F:
                gold = F.readlines()

            print(comp)
            print(gold)
            assert comp == gold
            """ )
        time.sleep(1)

        for batch in [False,True]:

            vtu.remove_results()

            vtu.runvvtest( batch=batch ).assertCounts( total=1, npass=1 )


############################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
