#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST:

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import time

import vvtestutils as vtu
import testutils as util
from testutils import print3

from libvvtest.TestSpecCreator import TestCreator
from libvvtest.RuntimeConfig import RuntimeConfig
from libvvtest.testcase import TestCase
from libvvtest.TestSpec import TestSpec  # magic: get rid of this?
from libvvtest.TestExec import TestExec  # magic: get rid of this?
from libvvtest.teststatus import TestStatusHandler

from libvvtest import depend
find_tests_by_execute_directory_match = depend.find_tests_by_execute_directory_match


class Parse_Dependencies( vtu.vvtestTestCase ):

    def test_simple_dependencies(self):
        ""
        util.writefile( 'testX.py.vvt', """
            #VVT: depends on : testY
            """ )
        util.writefile( 'testA.py.vvt', """
            #VVT: depends on : testC testB
            """ )
        time.sleep(1)

        nofltr = RuntimeConfig()

        tL = create_tests( '.', 'testX.py.vvt', nofltr )
        assert len(tL) == 1
        assert_dependencies( tL[0], 'testY' )
        assert get_depencency_expr( tL[0], 'testY' ) == None

        tL = create_tests( '.', 'testA.py.vvt', nofltr )
        assert len(tL) == 1

        assert_dependencies( tL[0], 'testC', 'testB' )
        assert get_depencency_expr( tL[0], 'testC' ) == None
        assert get_depencency_expr( tL[0], 'testB' ) == None

    def test_result_attribute_with_dependency(self):
        ""
        util.writefile( 'testX.py.vvt', """
            #VVT: depends on (result=fail): testY testZ
            """ )
        util.writefile( 'testA.py.vvt', """
            #VVT: depends on (result="fail or diff") : testB
            """ )
        time.sleep(1)

        nofltr = RuntimeConfig()

        tL = create_tests( '.', 'testX.py.vvt', nofltr )
        assert len(tL) == 1

        assert_dependencies( tL[0], 'testY', 'testZ' )

        for wx in [ get_depencency_expr( tL[0], 'testY' ),
                    get_depencency_expr( tL[0], 'testZ' ) ]:
            assert not wx.evaluate( lambda word: word == "pass" )
            assert not wx.evaluate( lambda word: word == "diff" )
            assert wx.evaluate( lambda word: word == "fail" )

        tL = create_tests( '.', 'testA.py.vvt', nofltr )
        assert len(tL) == 1

        assert_dependencies( tL[0], 'testB' )

        wx = get_depencency_expr( tL[0], 'testB' )
        assert not wx.evaluate( lambda word: word == "pass" )
        assert wx.evaluate( lambda word: word == "diff" )
        assert wx.evaluate( lambda word: word == "fail" )

    def test_an_astrisk_result_attribute_means_match_anything(self):
        ""
        util.writefile( 'testX.py.vvt', """
            #VVT: depends on (result="*"): testY testZ
            """ )
        time.sleep(1)

        nofltr = RuntimeConfig()

        tL = create_tests( '.', 'testX.py.vvt', nofltr )
        assert len(tL) == 1

        assert_dependencies( tL[0], 'testY', 'testZ' )
        for wx in [ get_depencency_expr( tL[0], 'testY' ),
                    get_depencency_expr( tL[0], 'testZ' ) ]:
            assert wx.evaluate( lambda word: word == "pass" )
            assert wx.evaluate( lambda word: word == "diff" )
            assert wx.evaluate( lambda word: word == "fail" )

    def test_multiple_dependency_specifications(self):
        ""
        util.writefile( 'testX.py.vvt', """
            #VVT: depends on (result=fail): testY testZ
            #VVT: depends on (result="fail or diff") : testB
            #VVT: depends on : testW
            """ )
        time.sleep(1)

        nofltr = RuntimeConfig()

        tL = create_tests( '.', 'testX.py.vvt', nofltr )
        assert len(tL) == 1

        assert_dependencies( tL[0], 'testB', 'testW', 'testY', 'testZ' )

        wx = get_depencency_expr( tL[0], 'testB' )
        assert not wx.evaluate( lambda word: word == "pass" )
        assert wx.evaluate( lambda word: word == "diff" )
        assert wx.evaluate( lambda word: word == "fail" )

        for wx in [ get_depencency_expr( tL[0], 'testY' ),
                    get_depencency_expr( tL[0], 'testZ' ) ]:
            assert not wx.evaluate( lambda word: word == "pass" )
            assert not wx.evaluate( lambda word: word == "diff" )
            assert wx.evaluate( lambda word: word == "fail" )

        assert get_depencency_expr( tL[0], 'testW' ) == None

    def test_using_filter_attributes(self):
        ""
        util.writefile( 'testX.py.vvt', """
            #VVT: depends on (platforms="XBox", result="fail") : testY
            #VVT: depends on (platforms="not XBox") : testZ
            """ )
        time.sleep(1)

        fltr = RuntimeConfig( platform_name='XBox' )

        tL = create_tests( '.', 'testX.py.vvt', fltr )
        assert len(tL) == 1

        assert_dependencies( tL[0], 'testY' )

        wx = get_depencency_expr( tL[0], 'testY' )
        assert not wx.evaluate( lambda word: word == "pass" )
        assert not wx.evaluate( lambda word: word == "diff" )
        assert wx.evaluate( lambda word: word == "fail" )

        fltr = RuntimeConfig( platform_name='PlayStation' )

        tL = create_tests( '.', 'testX.py.vvt', fltr )
        assert len(tL) == 1

        assert_dependencies( tL[0], 'testZ' )

        assert get_depencency_expr( tL[0], 'testZ' ) == None


def assert_dependencies( tspec, *check_names ):
    ""
    depL = tspec.getDependencies()

    nameL = []
    for name,expr in depL:
        nameL.append( name )
    nameL.sort()

    checkL = list( check_names )
    checkL.sort()

    assert nameL == checkL


def get_depencency_expr( tspec, dep_name ):
    ""
    for name,expr in tspec.getDependencies():
        if name == dep_name:
            return expr

    raise Exception( 'could not find dependency name: ' + dep_name )


#######################################

def make_tspec_map( *dirlist ):
    ""
    D = {}
    for sd in dirlist:
        D[ sd ] = None

    return D


class Function_find_tests_by_execute_directory_match( vtu.vvtestTestCase ):

    def setUp(self):
        ""
        vtu.vvtestTestCase.setUp( self, cleanout=False )

    def test_base_match(self):
        ""
        xL = make_tspec_map( 'subdir/testB', 'subdir/testC' )
        S = find_tests_by_execute_directory_match( 'subdir/testA', 'testB', xL )
        assert has_same_values( S, ['subdir/testB'] )

        xL = make_tspec_map( 'subdir/testC', 'subdir1/testB', 'subdir2/testB' )
        S = find_tests_by_execute_directory_match( 'subdir2/testA', 'testB', xL )
        assert has_same_values( S, ['subdir2/testB'] )

        xL = make_tspec_map( 'subdir/testC', 'subdir1/testB', 'subdir2/testB' )
        S = find_tests_by_execute_directory_match( 'subdir1/testA', 'testB', xL )
        assert has_same_values( S, ['subdir1/testB'] )

        xL = make_tspec_map( 'subdir/testB', 'subdir/testC', 'subdir/down/testB' )
        S = find_tests_by_execute_directory_match( 'subdir/testA', 'testB', xL )
        assert has_same_values( S, ['subdir/testB'] )

        xL = make_tspec_map( 'testB', 'testC' )
        S = find_tests_by_execute_directory_match( 'testA', 'testB', xL )
        assert has_same_values( S, ['testB'] )

        xL = make_tspec_map( 'testB', 'testC', 'down/testB' )
        S = find_tests_by_execute_directory_match( 'subdir/testA', 'testB', xL )
        assert has_same_values( S, ['testB'] )

    def test_subdir_match(self):
        ""
        xL = make_tspec_map( 'subdir/testB' )
        S = find_tests_by_execute_directory_match( 'testA', 'testB', xL )
        assert has_same_values( S, ['subdir/testB'] )

        xL = make_tspec_map( 'top/subdir/testB' )
        S = find_tests_by_execute_directory_match( 'top/testA', 'testB', xL )
        assert has_same_values( S, ['top/subdir/testB'] )

        xL = make_tspec_map( 'subdir/testB', 'subdir/deep/testB' )
        S = find_tests_by_execute_directory_match( 'testA', 'testB', xL )
        assert has_same_values( S, ['subdir/deep/testB','subdir/testB'] )

        xL = make_tspec_map( 'top/subdir/testB', 'top/subdir/deep/testB' )
        S = find_tests_by_execute_directory_match( 'top/testA', 'testB', xL )
        assert has_same_values( S, ['top/subdir/deep/testB','top/subdir/testB'] )

        xL = make_tspec_map( 'subdir/testB', 'subdir/deep/testB' )
        S = find_tests_by_execute_directory_match( 'testA', 't*B', xL )
        assert has_same_values( S, ['subdir/deep/testB','subdir/testB'] )

        xL = make_tspec_map( 'subdir1/deep2/testB', 'subdir1/deep1/testB', 'subdir2/testB' )
        S = find_tests_by_execute_directory_match( 'subdir1/testA', 'testB', xL )
        assert has_same_values( S, ['subdir1/deep1/testB','subdir1/deep2/testB'] )

        xL = make_tspec_map( 'subdir1/deep2/testB', 'subdir1/deep1/testB', 'subdir2/testB' )
        S = find_tests_by_execute_directory_match( 'subdir1/testA', 't*B', xL )
        assert has_same_values( S, ['subdir1/deep1/testB','subdir1/deep2/testB'] )

    def test_absolute_path_pattern(self):
        ""
        xL = make_tspec_map( 'subdir1/testB', 'subdir2/testB' )
        S = find_tests_by_execute_directory_match(
                            'subdir1/testA', 'subdir2/testB', xL )
        assert has_same_values( S, ['subdir2/testB'] )

        xL = make_tspec_map( 'subdir1/testB', 'subdir2/subdir1/testB' )
        S = find_tests_by_execute_directory_match(
                            'subdir1/testA', 'subdir1/testB', xL )
        assert has_same_values( S, ['subdir1/testB'] )

    def test_general_pattern(self):
        ""
        xL = make_tspec_map( 'subdir1/testB', 'subdir2/testB', 'subdir3/testA' )
        S = find_tests_by_execute_directory_match(
                            'subdir3/testA', 't*B', xL )
        assert has_same_values( S, ['subdir1/testB', 'subdir2/testB'] )

    def test_relative_directory_test_location(self):
        ""
        xL = make_tspec_map( 'subdir1/testB', 'subdir2/testB', 'subdir3/testA' )
        S = find_tests_by_execute_directory_match(
                            'subdir3/testA', '../subdir1/*B', xL )
        assert has_same_values( S, ['subdir1/testB'] )

        xL = make_tspec_map( 'subdir1/testB', 'subdir2/testB', 'subdir3/testA' )
        S = find_tests_by_execute_directory_match(
                            'subdir3/testA', '../sub*/*B', xL )
        assert has_same_values( S, ['subdir1/testB','subdir2/testB'] )


#######################################

def make_test_dep( tcase ):
    ""
    return depend.TestDependency( tcase, None, None )


def add_dependency( from_test, to_test ):
    ""
    depset = from_test.getDependencySet()
    depset.addDependency( make_test_dep( to_test ) )


def make_TestSpec( name ):
    ""
    ts = TestSpec( name, os.getcwd(), name+'.vvt' )
    return TestCase( ts, None )


def make_TestExec( name ):
    ""
    st = TestStatusHandler()
    ts = TestSpec( name, os.getcwd(), name+'.vvt' )
    tx = TestExec( st, ts, None )
    return TestCase( ts, tx )


class dependency_related_functions( vtu.vvtestTestCase ):

    def setUp(self):
        ""
        vtu.vvtestTestCase.setUp( self, cleanout=False )

    def test_addDependency_uniquifies_multiple_TestSpec(self):
        ""
        tcase = make_TestSpec( 'testA' )

        dep1 = make_TestSpec( 'atest' )
        add_dependency( tcase, dep1 )

        dep2 = make_TestSpec( 'atest' )
        add_dependency( tcase, dep2 )

        assert tcase.getDependencySet().numDependencies() == 1

    def test_addDependency_uniquifies_multiple_TestExec(self):
        ""
        tcase = make_TestExec( 'testA' )

        dep1 = make_TestExec( 'atest' )
        add_dependency( tcase, dep1 )

        dep2 = make_TestExec( 'atest' )
        add_dependency( tcase, dep2 )

        assert tcase.getDependencySet().numDependencies() == 1

    def test_addDependency_uniquifies_TestSpec_then_TestExec(self):
        ""
        tcase = make_TestExec( 'testA' )

        dep1 = make_TestSpec( 'atest' )
        add_dependency( tcase, dep1 )

        dep2 = make_TestExec( 'atest' )
        add_dependency( tcase, dep2 )

        depset = tcase.getDependencySet()
        assert depset.numDependencies() == 1
        assert depset.getBlocking().getExec() != None

    def test_addDependency_uniquifies_TestExec_then_TestSpec(self):
        ""
        tcase = make_TestExec( 'testA' )

        dep1 = make_TestExec( 'atest' )
        add_dependency( tcase, dep1 )

        dep2 = make_TestSpec( 'atest' )
        add_dependency( tcase, dep2 )

        depset = tcase.getDependencySet()
        assert depset.numDependencies() == 1
        assert depset.getBlocking().getExec() != None


#######################################

def has_same_values( container1, container2 ):
    ""
    L1 = list(container1)
    L1.sort()

    L2 = list(container2)
    L2.sort()

    return L1 == L2


def create_tests( rootpath, relpath, rtconfig ):
    ""
    creator = TestCreator( rtconfig )
    tL = creator.fromFile( rootpath, relpath, None )
    return tL


############################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
