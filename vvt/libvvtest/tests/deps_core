#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST:

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import unittest
import time

import vvtestutils as vtu
import testutils as util
from testutils import print3

import libvvtest.TestSpecCreator as creator
from libvvtest.RuntimeConfig import RuntimeConfig
from libvvtest.TestList import find_tests_by_execute_directory_match
from libvvtest.TestSpec import TestSpec
from libvvtest.TestExec import TestExec


class Parse_Dependencies( unittest.TestCase ):

    def setUp(self):
        util.setup_test()

    def test_simple_dependencies(self):
        ""
        util.writefile( 'testX.py.vvt', """
            #VVT: depends on : testY
            """ )
        util.writefile( 'testA.py.vvt', """
            #VVT: depends on : testC testB
            """ )
        time.sleep(1)

        nofltr = RuntimeConfig()

        tL = creator.createTestObjects( '.', 'testX.py.vvt', None, nofltr )
        assert len(tL) == 1
        assert_dependencies( tL[0], 'testY' )
        assert get_depencency_expr( tL[0], 'testY' ) == None

        tL = creator.createTestObjects( '.', 'testA.py.vvt', None, nofltr )
        assert len(tL) == 1

        assert_dependencies( tL[0], 'testC', 'testB' )
        assert get_depencency_expr( tL[0], 'testC' ) == None
        assert get_depencency_expr( tL[0], 'testB' ) == None

    def test_result_attribute_with_dependency(self):
        ""
        util.writefile( 'testX.py.vvt', """
            #VVT: depends on (result=fail): testY testZ
            """ )
        util.writefile( 'testA.py.vvt', """
            #VVT: depends on (result="fail or diff") : testB
            """ )
        time.sleep(1)

        nofltr = RuntimeConfig()

        tL = creator.createTestObjects( '.', 'testX.py.vvt', None, nofltr )
        assert len(tL) == 1

        assert_dependencies( tL[0], 'testY', 'testZ' )

        for wx in [ get_depencency_expr( tL[0], 'testY' ),
                    get_depencency_expr( tL[0], 'testZ' ) ]:
            assert not wx.evaluate( lambda word: word == "pass" )
            assert not wx.evaluate( lambda word: word == "diff" )
            assert wx.evaluate( lambda word: word == "fail" )

        tL = creator.createTestObjects( '.', 'testA.py.vvt', None, nofltr )
        assert len(tL) == 1

        assert_dependencies( tL[0], 'testB' )

        wx = get_depencency_expr( tL[0], 'testB' )
        assert not wx.evaluate( lambda word: word == "pass" )
        assert wx.evaluate( lambda word: word == "diff" )
        assert wx.evaluate( lambda word: word == "fail" )

    def test_an_astrisk_result_attribute_means_match_anything(self):
        ""
        util.writefile( 'testX.py.vvt', """
            #VVT: depends on (result="*"): testY testZ
            """ )
        time.sleep(1)

        nofltr = RuntimeConfig()

        tL = creator.createTestObjects( '.', 'testX.py.vvt', None, nofltr )
        assert len(tL) == 1

        assert_dependencies( tL[0], 'testY', 'testZ' )
        for wx in [ get_depencency_expr( tL[0], 'testY' ),
                    get_depencency_expr( tL[0], 'testZ' ) ]:
            assert wx.evaluate( lambda word: word == "pass" )
            assert wx.evaluate( lambda word: word == "diff" )
            assert wx.evaluate( lambda word: word == "fail" )

    def test_multiple_dependency_specifications(self):
        ""
        util.writefile( 'testX.py.vvt', """
            #VVT: depends on (result=fail): testY testZ
            #VVT: depends on (result="fail or diff") : testB
            #VVT: depends on : testW
            """ )
        time.sleep(1)

        nofltr = RuntimeConfig()

        tL = creator.createTestObjects( '.', 'testX.py.vvt', None, nofltr )
        assert len(tL) == 1

        assert_dependencies( tL[0], 'testB', 'testW', 'testY', 'testZ' )

        wx = get_depencency_expr( tL[0], 'testB' )
        assert not wx.evaluate( lambda word: word == "pass" )
        assert wx.evaluate( lambda word: word == "diff" )
        assert wx.evaluate( lambda word: word == "fail" )

        for wx in [ get_depencency_expr( tL[0], 'testY' ),
                    get_depencency_expr( tL[0], 'testZ' ) ]:
            assert not wx.evaluate( lambda word: word == "pass" )
            assert not wx.evaluate( lambda word: word == "diff" )
            assert wx.evaluate( lambda word: word == "fail" )

        assert get_depencency_expr( tL[0], 'testW' ) == None

    def test_using_filter_attributes(self):
        ""
        util.writefile( 'testX.py.vvt', """
            #VVT: depends on (platforms="XBox", result="fail") : testY
            #VVT: depends on (platforms="not XBox") : testZ
            """ )
        time.sleep(1)

        fltr = RuntimeConfig( platform_name='XBox' )

        tL = creator.createTestObjects( '.', 'testX.py.vvt', None, fltr )
        assert len(tL) == 1

        assert_dependencies( tL[0], 'testY' )

        wx = get_depencency_expr( tL[0], 'testY' )
        assert not wx.evaluate( lambda word: word == "pass" )
        assert not wx.evaluate( lambda word: word == "diff" )
        assert wx.evaluate( lambda word: word == "fail" )

        fltr = RuntimeConfig( platform_name='PlayStation' )

        tL = creator.createTestObjects( '.', 'testX.py.vvt', None, fltr )
        assert len(tL) == 1

        assert_dependencies( tL[0], 'testZ' )

        assert get_depencency_expr( tL[0], 'testZ' ) == None


def assert_dependencies( tspec, *check_names ):
    ""
    depL = tspec.getDependencies()

    nameL = []
    for name,expr in depL:
        nameL.append( name )
    nameL.sort()

    checkL = list( check_names )
    checkL.sort()

    assert nameL == checkL


def get_depencency_expr( tspec, dep_name ):
    ""
    for name,expr in tspec.getDependencies():
        if name == dep_name:
            return expr

    raise Exception( 'could not find dependency name: ' + dep_name )


#######################################

class Function_find_tests_by_execute_directory_match( unittest.TestCase ):

    def setUp(self):
        util.setup_test( cleanout=False )

    def test_base_match(self):
        ""
        xL = [ 'subdir/testB', 'subdir/testC' ]
        S = find_tests_by_execute_directory_match( 'subdir/testA', 'testB', xL )
        assert has_same_values( S, ['subdir/testB'] )

        xL = [ 'subdir/testC', 'subdir1/testB', 'subdir2/testB' ]
        S = find_tests_by_execute_directory_match( 'subdir2/testA', 'testB', xL )
        assert has_same_values( S, ['subdir2/testB'] )

        xL = [ 'subdir/testC', 'subdir1/testB', 'subdir2/testB' ]
        S = find_tests_by_execute_directory_match( 'subdir1/testA', 'testB', xL )
        assert has_same_values( S, ['subdir1/testB'] )

        xL = [ 'subdir/testB', 'subdir/testC', 'subdir/down/testB' ]
        S = find_tests_by_execute_directory_match( 'subdir/testA', 'testB', xL )
        assert has_same_values( S, ['subdir/testB'] )

        xL = [ 'testB', 'testC' ]
        S = find_tests_by_execute_directory_match( 'testA', 'testB', xL )
        assert has_same_values( S, ['testB'] )

        xL = [ 'testB', 'testC', 'down/testB' ]
        S = find_tests_by_execute_directory_match( 'subdir/testA', 'testB', xL )
        assert has_same_values( S, ['testB'] )

    def test_subdir_match(self):
        ""
        xL = [ 'subdir/testB' ]
        S = find_tests_by_execute_directory_match( 'testA', 'testB', xL )
        assert has_same_values( S, ['subdir/testB'] )

        xL = [ 'top/subdir/testB' ]
        S = find_tests_by_execute_directory_match( 'top/testA', 'testB', xL )
        assert has_same_values( S, ['top/subdir/testB'] )

        xL = [ 'subdir/testB', 'subdir/deep/testB' ]
        S = find_tests_by_execute_directory_match( 'testA', 'testB', xL )
        assert has_same_values( S, ['subdir/deep/testB','subdir/testB'] )

        xL = [ 'top/subdir/testB', 'top/subdir/deep/testB' ]
        S = find_tests_by_execute_directory_match( 'top/testA', 'testB', xL )
        assert has_same_values( S, ['top/subdir/deep/testB','top/subdir/testB'] )

        xL = [ 'subdir/testB', 'subdir/deep/testB' ]
        S = find_tests_by_execute_directory_match( 'testA', 't*B', xL )
        assert has_same_values( S, ['subdir/deep/testB','subdir/testB'] )

        xL = [ 'subdir1/deep2/testB', 'subdir1/deep1/testB', 'subdir2/testB' ]
        S = find_tests_by_execute_directory_match( 'subdir1/testA', 'testB', xL )
        assert has_same_values( S, ['subdir1/deep1/testB','subdir1/deep2/testB'] )

        xL = [ 'subdir1/deep2/testB', 'subdir1/deep1/testB', 'subdir2/testB' ]
        S = find_tests_by_execute_directory_match( 'subdir1/testA', 't*B', xL )
        assert has_same_values( S, ['subdir1/deep1/testB','subdir1/deep2/testB'] )

    def test_absolute_path_pattern(self):
        ""
        xL = [ 'subdir1/testB', 'subdir2/testB' ]
        S = find_tests_by_execute_directory_match(
                            'subdir1/testA', 'subdir2/testB', xL )
        assert has_same_values( S, ['subdir2/testB'] )

        xL = [ 'subdir1/testB', 'subdir2/subdir1/testB' ]
        S = find_tests_by_execute_directory_match(
                            'subdir1/testA', 'subdir1/testB', xL )
        assert has_same_values( S, ['subdir1/testB'] )

    def test_general_pattern(self):
        ""
        xL = [ 'subdir1/testB', 'subdir2/testB', 'subdir3/testA' ]
        S = find_tests_by_execute_directory_match(
                            'subdir3/testA', 't*B', xL )
        assert has_same_values( S, ['subdir1/testB', 'subdir2/testB'] )

    def test_relative_directory_test_location(self):
        ""
        xL = [ 'subdir1/testB', 'subdir2/testB', 'subdir3/testA' ]
        S = find_tests_by_execute_directory_match(
                            'subdir3/testA', '../subdir1/*B', xL )
        assert has_same_values( S, ['subdir1/testB'] )

        xL = [ 'subdir1/testB', 'subdir2/testB', 'subdir3/testA' ]
        S = find_tests_by_execute_directory_match(
                            'subdir3/testA', '../sub*/*B', xL )
        assert has_same_values( S, ['subdir1/testB','subdir2/testB'] )


#######################################

class dependency_related_functions( unittest.TestCase ):

    def setUp(self):
        util.setup_test( cleanout=False )

    def test_addDependency_uniquifies_multiple_TestSpec(self):
        ""
        ts = TestSpec( 'testA', os.getcwd(), 'testA.vvt' )
        tx = TestExec( ts, None )

        ts1 = TestSpec( 'atest', os.getcwd(), 'atest.vvt' )
        tx.addDependency( ts1 )

        ts2 = TestSpec( 'atest', os.getcwd(), 'atest.vvt' )
        tx.addDependency( ts2 )

        assert len( tx.getDependencies() ) == 1

    def test_addDependency_uniquifies_multiple_TestExec(self):
        ""
        ts = TestSpec( 'testA', os.getcwd(), 'testA.vvt' )
        tx = TestExec( ts, None )

        ts1 = TestSpec( 'atest', os.getcwd(), 'atest.vvt' )
        tx1 = TestExec( ts1, None )
        tx.addDependency( tx1 )

        ts2 = TestSpec( 'atest', os.getcwd(), 'atest.vvt' )
        tx2 = TestExec( ts2, None )
        tx.addDependency( tx2 )

        assert len( tx.getDependencies() ) == 1

    def test_addDependency_uniquifies_TestSpec_then_TestExec(self):
        ""
        ts = TestSpec( 'testA', os.getcwd(), 'testA.vvt' )
        tx = TestExec( ts, None )

        ts1 = TestSpec( 'atest', os.getcwd(), 'atest.vvt' )
        tx.addDependency( ts1 )

        ts2 = TestSpec( 'atest', os.getcwd(), 'atest.vvt' )
        tx2 = TestExec( ts2, None )
        tx.addDependency( tx2 )

        assert len( tx.getDependencies() ) == 1

    def test_addDependency_uniquifies_TestExec_then_TestSpec(self):
        ""
        ts = TestSpec( 'testA', os.getcwd(), 'testA.vvt' )
        tx = TestExec( ts, None )

        ts1 = TestSpec( 'atest', os.getcwd(), 'atest.vvt' )
        tx1 = TestExec( ts1, None )
        tx.addDependency( tx1 )

        ts1 = TestSpec( 'atest', os.getcwd(), 'atest.vvt' )
        tx.addDependency( ts1 )

        assert len( tx.getDependencies() ) == 1


#######################################

def has_same_values( container1, container2 ):
    ""
    L1 = list(container1)
    L1.sort()

    L2 = list(container2)
    L2.sort()

    return L1 == L2


############################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
