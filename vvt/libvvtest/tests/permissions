#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST:

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import time
import stat
import unittest

import testutils as util
from testutils import print3

import libvvtest.PermissionSetter as PS


########################################################################

class unit_tests( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

    def test_specification_error(self):
        ""
        self.assertRaises( Exception, PS.PermissionSetter, '.', 'g=rq' )

    def test_dummy_permissions_class(self):
        ""
        perms = PS.DummyPermissionSetter()
        perms.set( 'blah' )
        perms.recurse( 'blah' )


class integration_tests( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

        # for batch tests
        os.environ['VVTEST_BATCH_READ_INTERVAL'] = '5'
        os.environ['VVTEST_BATCH_READ_TIMEOUT'] = '15'
        os.environ['VVTEST_BATCH_SLEEP_LENGTH'] = '1'

    def test_turning_off_group_and_world_permissions(self):
        ""
        util.writefile( "one/cat.xml", """
            <rtest name="cat">
              <execute> sleep 1 </execute>
            </rtest>""" )
        util.writefile( "one/dog.xml", """
            <rtest name="dog">
              <execute> sleep 2 </execute>
            </rtest>""" )
        util.writefile( "two/circle.xml", """
            <rtest name="circle">
              <execute> sleep 3 </execute>
            </rtest>""" )

        self.turning_off_group_and_world_permissions( '' )
        self.turning_off_group_and_world_permissions(
            '--plat '+util.core_platform_name()+' --batch' )

    def turning_off_group_and_world_permissions(self, opt):
        ""
        util.remove_results()

        out,np,nd,nf,nn = util.run_vvtest( opt+' --perms g=,o=' )
        assert np == 3 and nd == 0 and nf == 0 and nn == 0
        tdir = os.path.abspath( util.results_dir() )
        platname = util.platform_name( out )

        for p in list_all_paths( tdir ):
            assert has_no_group_permissions(p)
            assert has_no_world_permissions(p)

    def test_turn_on_group_and_world_permissions(self):
        ""
        util.writefile( "one/cat.xml", """
            <rtest name="cat">
              <execute> sleep 1 </execute>
            </rtest>""" )
        util.writefile( "one/dog.xml", """
            <rtest name="dog">
              <execute> sleep 2 </execute>
            </rtest>""" )
        util.writefile( "two/circle.xml", """
            <rtest name="circle">
              <execute> sleep 3 </execute>
            </rtest>""" )

        self.turn_on_group_and_world_permissions( '' )
        self.turn_on_group_and_world_permissions(
            '--plat '+util.core_platform_name()+' --batch' )

    def turn_on_group_and_world_permissions(self, opt):
        ""
        util.remove_results()

        out,np,nd,nf,nn = util.run_vvtest( opt+' --perms g=rws,o=rwx' )
        assert np == 3 and nd == 0 and nf == 0 and nn == 0
        tdir = os.path.abspath( util.results_dir() )
        platname = util.platform_name( out )

        for d in list_all_directories( tdir ):
            assert has_group_sticky(d)
            assert has_group_execute(d)
            assert has_world_execute(d)

        # spot check a file that should have execute set
        f = os.path.join( tdir, 'one', 'dog', 'runscript' )
        assert has_group_execute(f) and has_world_execute(f)

        for p in list_all_paths( tdir ):
            assert has_group_read(p) and has_group_write(p)
            if has_owner_execute(p):
                assert has_group_execute(p) and has_world_execute(p)


############################################################################

def list_all_paths( rootpath ):
    ""
    pathset = set()

    for dirpath,dirnames,filenames in os.walk( rootpath ):

        pathset.add( dirpath )

        for f in filenames:
            p = os.path.join( dirpath, f )
            if not os.path.islink(p):
                pathset.add(p)

    pL = list( pathset )
    pL.sort()

    return pL

def list_all_directories( rootpath ):
    ""
    pathset = set()

    for dirpath,dirnames,filenames in os.walk( rootpath ):
        pathset.add( dirpath )

    pL = list( pathset )
    pL.sort()

    return pL


def has_owner_execute( path ):
    ""
    fm = stat.S_IMODE( os.stat(path)[stat.ST_MODE] )
    return int( fm & stat.S_IXUSR ) != 0


def has_no_group_permissions( path ):
    ""
    fm = stat.S_IMODE( os.stat(path)[stat.ST_MODE] )
    return int( fm & stat.S_IRWXG ) == 0

def has_group_sticky( path ):
    ""
    fm = stat.S_IMODE( os.stat(path)[stat.ST_MODE] )
    return int( fm & stat.S_ISGID ) != 0

def has_group_read( path ):
    ""
    fm = stat.S_IMODE( os.stat(path)[stat.ST_MODE] )
    return int( fm & stat.S_IRGRP ) != 0

def has_group_write( path ):
    ""
    fm = stat.S_IMODE( os.stat(path)[stat.ST_MODE] )
    return int( fm & stat.S_IWGRP ) != 0

def has_group_execute( path ):
    ""
    fm = stat.S_IMODE( os.stat(path)[stat.ST_MODE] )
    return int( fm & stat.S_IXGRP ) != 0


def has_no_world_permissions( path ):
    ""
    fm = stat.S_IMODE( os.stat(path)[stat.ST_MODE] )
    return int( fm & stat.S_IRWXO ) == 0

def has_world_read( path ):
    ""
    fm = stat.S_IMODE( os.stat(path)[stat.ST_MODE] )
    return int( fm & stat.S_IROTH ) != 0

def has_world_write( path ):
    ""
    fm = stat.S_IMODE( os.stat(path)[stat.ST_MODE] )
    return int( fm & stat.S_IWOTH ) != 0

def has_world_execute( path ):
    ""
    fm = stat.S_IMODE( os.stat(path)[stat.ST_MODE] )
    return int( fm & stat.S_IXOTH ) != 0


############################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
