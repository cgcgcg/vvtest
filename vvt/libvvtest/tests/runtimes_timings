#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST:

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import time
from glob import glob
import unittest

import testutils as util
from testutils import print3

import libvvtest.TestSpecCreator as TestSpecCreator
from libvvtest.RuntimeConfig import RuntimeConfig

sys.path.insert( 1, os.path.dirname( os.path.dirname( util.testsrcdir ) ) )
import results


class runtimes_and_timings( unittest.TestCase ):

    def setUp(self):
        util.setup_test()

    def test_create_and_use_a_runtimes_file(self):
        ""
        util.writefile( "tests/dir1/one.xml", """
            <rtest name="one">
              <execute>
                sleep 1
              </execute>
            </rtest>""")
        util.writefile( "tests/dir1/two.xml", """
            <rtest name="two">
              <execute>
                sleep 2
              </execute>
            </rtest>""")
        util.writefile( "tests/dir2/three.xml", """
            <rtest name="three">
              <execute>
                sleep 3
              </execute>
            </rtest>""")
        time.sleep(1)

        platname = util.core_platform_name()
        tests = os.path.abspath( 'tests' )

        vrun = util.runvvtest( tests )
        vrun.assertCounts( total=3, npass=3 )

        # create a test source tree runtimes file but without any test results
        tr = results.TestResults()
        tr.writeRuntimes( 'tests', None )

        # even though a rootrel directory could be determined, no runtime is available
        tst = TestSpecCreator.createTestObjects(
                    tests, 'dir1/one.xml', None, RuntimeConfig() )[0]
        cache = results.LookupCache( platname, 'cplr' )
        tm,tv = cache.getRunTime( tst )
        assert tm == None

        # re-save the testing results (this time the test rootrel can be
        # determined) and create a multiplatform results file
        os.mkdir('testing')
        time.sleep(1)
        os.environ['TESTING_DIRECTORY'] = os.path.abspath( 'testing' )
        util.runvvtest( '-i --save-results' )

        resultsfname = os.path.abspath( glob('testing/results.*')[0] )
        plat,cplr = get_platform_compiler( resultsfname )
        util.runcmd( util.resultspy + ' merge '+resultsfname, chdir='testing' )

        # leave the source tree runtimes file empty and use the
        # multiplatform results
        cache = results.LookupCache( plat, cplr, os.path.abspath('testing') )
        tm,tv = cache.getRunTime( tst )
        assert tm != None and tm > 0 and tm < 10

        # populate the test source tree runtimes file
        tr.readResults( resultsfname )
        tr.writeRuntimes( 'tests', None )

        # a time for the test should be found from the source tree runtimes file
        cache = results.LookupCache( platname, 'cplr' )
        tm,tv = cache.getRunTime( tst )
        assert tm != None and tm > 0 and tm < 10

    def test_that_longest_runtimes_are_run_first(self):
        ""
        util.writescript( "tests/AA.vvt", """
            #!/usr/bin/env python
            import os, sys, time
            time.sleep(5)
            """ )
        util.writescript( "tests/BB.vvt", """
            #!/usr/bin/env python
            #VVT: parameterize : planet=mercury mars venus
            #VVT: analyze : --analyze
            import os, sys, time
            import script_util as vvt
            if '--analyze' not in sys.argv:
                if vvt.planet == 'mercury':
                    time.sleep(1)
                elif vvt.planet == 'mars':
                    time.sleep(3)
                elif vvt.planet == 'venus':
                    time.sleep(7)
            else:
                pass  # the analyze test
            """ )
        util.writescript( "tests/CC.vvt", """
            #!/usr/bin/env python
            import os, sys, time
            time.sleep(10)
            """ )
        time.sleep(1)

        tests = os.path.abspath( 'tests' )

        # run first to get the timings
        vrun = util.runvvtest( tests )
        vrun.assertCounts( total=6, npass=6 )

        # run again one at a time and check the execution order
        vrun = util.runvvtest( '-n 1 -R '+tests )
        vrun.assertCounts( total=6, npass=6 )

        assert vrun.startedTestIds() == [ 'CC', 'BB.planet=venus',
                                          'AA', 'BB.planet=mars',
                                          'BB.planet=mercury', 'BB' ]

    def test_using_timings_file_with_tmin_max(self):
        """
        exercise runtime min/max using a timings file
        """
        util.writescript( "tests/AA.vvt", """
            #!/usr/bin/env python
            import os, sys, time
            time.sleep(1)
            """ )
        util.writescript( "tests/BB.vvt", """
            #!/usr/bin/env python
            import os, sys, time
            time.sleep(3)
            """ )
        util.writescript( "tests/CC.vvt", """
            #!/usr/bin/env python
            import os, sys, time
            time.sleep(7)
            """ )
        time.sleep(1)

        for batch in [False,True]:

            util.remove_results()

            if os.path.exists( 'timings' ):
                os.remove( 'timings' )

            # without a runtimes available, all tests should run
            vrun = util.runvvtest( '--tmax 6 tests', batch=batch )
            vrun.assertCounts( total=3, npass=3 )

            tdir = vrun.resultsDir()

            # create a timings file
            util.runcmd( util.resultspy + ' save', chdir='tests' )
            util.runvvtest( '-i --save-results', chdir=tdir )
            resultsfname = glob('results.*')[0]
            util.runcmd( util.resultspy + ' merge -x '+resultsfname )

            # select tests based on the timings file
            util.remove_results()
            vrun = util.runvvtest( '--tmax 6 tests', batch=batch )
            vrun.assertCounts( total=2, npass=2 )
            assert vrun.getTestIds() == ['AA','BB']


########################################################################

def get_platform_compiler( resultsfname ):
    """
    """
    fmt,vers,hdr,nskip = results.read_file_header( resultsfname )
    pn = hdr['PLATFORM']
    cp = hdr['COMPILER']
    return pn,cp


########################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
