#!/usr/bin/env python

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import getopt
import subprocess
import time


help_string = """
NAME
    runtests - run the unit tests contained in this directory

SYNOPSIS
    1.  runtests { -h | --help }
    2.  runtests [OPTIONS] [ testname ... ]

DESCRIPTION
    Runs the unit test scripts in a unique subdirectory name of the current
working directory.  Without any arguments, all the test scripts are run.

OPTIONS
    -h, --help  : this help
    -j <int>    : max concurrent tests (default is one)
    -p          : run each unit test using a list of python versions
"""

#
# This is a manual list of all the test scripts
#
testlist = [ \
    'nulltest',
    'options',
    'generate',
    'execute',
    'exclude',
    'timeout',
    'info',
    'restart',
    'baseline',
    'expr',
    'tspecs',
    'cspecs',
    'cshscripts',
    'analyze',
    'filter',
    'params',
    'extract',
    'testresults',
    'runtimes',
    'config',
    'permissions',
    'scripts',
    'tdd',
]

# list of pythons to iterate over
# TODO: figure out a way to generalize the listing mechanism
pyL = [ '/home/rrdrake/bin/Linux/py244/bin/python',
        '/home/rrdrake/bin/Linux/py255/bin/python',
        '/home/rrdrake/bin/Linux/py266/bin/python',
        '/home/rrdrake/bin/Linux/py273/bin/python',
        '/home/rrdrake/bin/Linux/py301/bin/python',
        '/home/rrdrake/bin/Linux/py313/bin/python',
        '/home/rrdrake/bin/Linux/py325/bin/python',
        '/home/rrdrake/bin/Linux/py335/bin/python',
        '/home/rrdrake/bin/Linux/py343/bin/python',
        '/home/rrdrake/bin/Linux/py353/bin/python' ]


###########################################################################

def main():

    optL,argL = getopt.getopt( sys.argv[1:], 'hpj:', longopts=['help'] )

    iterpy = False
    numconcurrent = 1

    for n,v in optL:
        if n == '-h' or n == '--help':
            print3( help_string )
            return
        elif n == '-p':
            iterpy = True  # iterate python versions
        elif n == '-j':
            numconcurrent = int( v )
            assert numconcurrent >= 1

    prependPATH( os.path.normpath( os.path.join( mydir, '..' ) ) )

    tdir = makeTestDir()
    print3( 'cd '+tdir )
    os.chdir(tdir)

    # collect the test commands to be run
    cmdD = {}
    for tname in testlist:

        if len(argL) == 0 or tname in argL:

            tst = os.path.join( mydir, tname )

            if iterpy:
                # iterate python versions on the local (script) launch
                for i in range(len(pyL)):
                    py = pyL[i]
                    cmd = py + ' ' + tst
                    tid = tname+'_p'+str(i)
                    cmdD[tid] = cmd

            else:
                cmd = sys.executable + ' ' + tst
                tid = tname
                cmdD[tid] = cmd

    cwd = os.getcwd()
    jobD = {}
    for tid,cmd in cmdD.items():

        # start job only if number of concurrent jobs is not exceeded
        while True:
            if poll_jobs( jobD ) < numconcurrent:
                break
            time.sleep(1)

        jb = Job( cwd, tid, cmd )
        jobD[tid] = jb

    # wait on all jobs
    while True:
        if poll_jobs( jobD ) == 0:
            break
        time.sleep(1)

    # print results
    nf = 0
    for tid,jb in jobD.items():
        if jb.x != 0:
            print3( "FAIL:", tid+':', jb.cmd )
            nf += 1
    if nf == 0:
        print3( "ALL TESTS PASSED" )


###########################################################################

class Job:

    def __init__(self, cwd, testid, cmd):
        assert os.path.isabs( cwd )
        self.cmd = cmd
        os.chdir(cwd)
        rdir = testid + '_dir'
        os.mkdir( rdir )
        os.chdir( rdir )
        os.environ['TOOLSET_RUNDIR'] = os.path.join( cwd, rdir )
        log = os.path.join( cwd, testid+'.out' )
        self.logfp = open( log, 'w' )
        print3( "RUN: " + cmd )
        self.proc = subprocess.Popen( cmd, shell=True,
                        stdout=self.logfp.fileno(), stderr=subprocess.STDOUT )
        os.chdir(cwd)

    def poll(self):
        """
        Checks on the sub process.  If done, returns exit status, else None.
        """
        if self.proc == None:
            return self.x
        x = self.proc.poll()
        if x != None:
            self.x = x
            self.proc = None
        return x


def poll_jobs( jobD ):
    """
    Polls each job and returns the number of jobs still running.
    """
    nr = 0
    for testid,jb in jobD.items():
        x = jb.poll()
        if x == None:
            nr += 1
    return nr


def makeTestDir():
    """
    Creates and returns a unique absolute directory path under the current
    working directory.
    """
    pid = os.getpid()
    dname = "testdir." + str(pid)
    if os.path.exists(dname):
        # add additional numbers to make a unique name
        for n in range(100):
            if not os.path.exists( dname + '.' + str(n) ):
                dname = dname + '.' + str(n)
                break

    os.mkdir(dname)

    return os.path.abspath(dname)


def prependPATH(d):
    """
    Add the given directory to PATH.
    """
    if 'PATH' in os.environ:
        if os.environ['PATH']:
            os.environ['PATH'] = d + ':' + os.environ['PATH']
        else:
            os.environ['PATH'] = d
    else:
        os.environ['PATH'] = d


def print3( *args ):
    """
    Python 2 & 3 compatible print function.
    """
    s = ' '.join( [ str(x) for x in args ] )
    sys.stdout.write( s + '\n' )
    sys.stdout.flush()


###########################################################################

mydir = os.path.abspath( sys.path[0] )

main()
