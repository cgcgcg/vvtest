#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST:

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import time
import unittest
import signal
import subprocess

import testutils as util
from testutils import print3


class running_after_vvtest_is_killed( unittest.TestCase ):

    def setUp(self):
        util.setup_test()

    def test_vvtest_closes_files_ok_under_KeyboardInterrupt(self):
        ""
        util.writefile( "sleeper.xml", """
            <rtest name="sleeper">
                <execute> sleep 10 </execute>
            </rtest>""" )
        time.sleep(1)

        util.run_command_then_terminate_it( util.vvtest, signum=signal.SIGINT )
        time.sleep(1)

        out = util.readfile( 'run.log' )
        print3( out )

        np,nd = util.numpass(out), util.numdiff(out)
        nf,nn = util.numfail(out), util.numnotrun(out)
        assert np == 0 and nd == 0 and nf == 0 and nn == 1

        out,np,nd,nf,nn = util.run_vvtest()
        assert np == 1 and nn == 0

        assert len( util.grep( out, 'rror.*another process' ) ) == 0

    def test_vvtest_fails_to_run_if_a_previous_run_was_killed(self):
        ""
        util.writefile( "sleeper.xml", """
            <rtest name="sleeper">
                <execute> sleep 10 </execute>
            </rtest>""" )
        time.sleep(1)
        
        util.run_command_then_terminate_it( util.vvtest )
        time.sleep(1)

        out = util.readfile( 'run.log' )
        print3( out )

        np,nd = util.numpass(out), util.numdiff(out)
        nf,nn = util.numfail(out), util.numnotrun(out)
        assert np == 0 and nd == 0 and nf == 0 and nn == 1

        xok,out = util.run_cmd( util.vvtest )

        assert not xok
        assert len( util.grep( out, 'rror.*another process' ) ) == 1
        assert util.numpass(out) == 0

    def test_running_vvtest_after_killed_but_in_TestResults_directory(self):
        ""
        util.writefile( "sleeper.xml", """
            <rtest name="sleeper">
                <execute> sleep 10 </execute>
            </rtest>""" )
        time.sleep(1)
        
        util.run_command_then_terminate_it( util.vvtest )
        time.sleep(1)
        tdir = util.results_dir()

        out = util.readfile( 'run.log' )
        print3( out )

        np,nd = util.numpass(out), util.numdiff(out)
        nf,nn = util.numfail(out), util.numnotrun(out)
        assert np == 0 and nd == 0 and nf == 0 and nn == 1

        xok,out = util.run_cmd( util.vvtest, directory=tdir )

        assert not xok
        assert len( util.grep( out, 'rror.*another process' ) ) == 1
        assert util.numpass(out) == 0

    def test_forcing_vvtest_to_run_after_previous_was_killed(self):
        ""
        util.writefile( "sleeper1.xml", """
            <rtest name="sleeper1">
                <timeout value="20"/>
                <execute> sleep 5 </execute>
            </rtest>""" )
        util.writefile( "sleeper2.xml", """
            <rtest name="sleeper2">
                <timeout value="20"/>
                <execute> sleep 5 </execute>
            </rtest>""" )

        # using SIGTERM prevents the "finished" mark from getting placed
        os.environ['VVTEST_INTERRUPT_COUNT'] = '1'
        os.environ['VVTEST_SIGNAL'] = 'SIGTERM'
        try:
            xok,out = util.run_cmd( util.vvtest + ' -n 1' )
        finally:
            del os.environ['VVTEST_INTERRUPT_COUNT']
            del os.environ['VVTEST_SIGNAL']

        # this one should fail
        xok,out = util.run_cmd( util.vvtest + ' -R' )
        assert not xok
        assert len( util.grep( out, 'rror.*another process' ) ) == 1

        # this one should be forced to run
        xok,out = util.run_cmd( util.vvtest + ' -R --force' )
        assert xok
        assert len( util.grep( out, 'rror.*another process' ) ) == 0

        util.remove_results()

        os.environ['VVTEST_INTERRUPT_BATCH'] = '1'
        os.environ['VVTEST_SIGNAL_BATCH'] = 'SIGTERM'
        try:
            cmd = util.vvtest + ' --plat '+util.core_platform_name() + \
                           ' --batch --qsub-limit 1 --qsub-length 1'
            xok,out = util.run_cmd( cmd )
        finally:
            del os.environ['VVTEST_INTERRUPT_BATCH']
            del os.environ['VVTEST_SIGNAL_BATCH']

        platname = util.core_platform_name()

        # this one should fail
        xok,out = util.run_cmd( util.vvtest + ' --plat '+platname + \
                                    ' --batch -R' )
        assert not xok
        assert len( util.grep( out, 'rror.*another process' ) ) == 1

        # this one should be forced to run
        xok,out = util.run_cmd( util.vvtest + ' --plat '+platname + \
                                    ' --batch -R --force' )
        assert xok
        assert len( util.grep( out, 'rror.*another process' ) ) == 0


########################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
