#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST:

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import glob
import time

import vvtestutils as vtu
import testutils as util
from testutils import print3

from libvvtest.teststatus import TestStatusHandler
import libvvtest.depend as depend

import libvvtest.FilterExpressions as FilterExpressions


class dependency_result_expressions( vtu.vvtestTestCase ):

    def test_by_default_failed_dependencies_stop_execution(self):
        ""
        util.writescript( 'testX.vvt', """
            #!"""+sys.executable+"""
            #VVT: depends on : testY
            import os, sys, time
            sys.stdout.write( 'time='+str(time.time())+os.linesep )
            """ )
        util.writescript( 'testY.vvt', """
            #!"""+sys.executable+"""
            import os, sys, time
            raise Exception( 'fake exception' )
            """ )
        time.sleep(1)

        for batch in [False,True]:

            vtu.remove_results()

            vrun = vtu.runvvtest( batch=batch )
            vrun.assertCounts( total=2, fail=1, notrun=1 )

            assert len( glob.glob( 'TestResults*/testX/execute.log' ) ) == 0

    def test_allow_dependent_to_run_even_if_dependency_fails(self):
        ""
        util.writescript( 'testX.vvt', """
            #!"""+sys.executable+"""
            #VVT: depends on (result="pass or diff or fail"): testY
            import os, sys, time
            sys.stdout.write( 'time='+str(time.time())+os.linesep )
            """ )
        util.writescript( 'testY.vvt', """
            #!"""+sys.executable+"""
            import os, sys, time
            raise Exception( 'fake exception' )
            """ )
        time.sleep(1)

        for batch in [False,True]:

            vtu.remove_results()

            vrun = vtu.runvvtest( batch=batch )
            vrun.assertCounts( total=2, npass=1, fail=1 )

            lineL = util.grepfiles( 'time=', 'TestResults*/testX/execute.log' )
            assert len( lineL ) == 1

    def test_use_wildcard_value_to_ignore_dependency_result(self):
        ""
        util.writescript( 'testX.vvt', """
            #!"""+sys.executable+"""
            #VVT: depends on (result="*"): testY
            import os, sys, time
            sys.stdout.write( 'time='+str(time.time())+os.linesep )
            """ )
        util.writescript( 'testY.vvt', """
            #!"""+sys.executable+"""
            import os, sys, time
            raise Exception( 'fake exception' )
            """ )
        time.sleep(1)

        for batch in [False,True]:

            vtu.remove_results()

            vrun = vtu.runvvtest( batch=batch )
            vrun.assertCounts( total=2, npass=1, fail=1 )

            lineL = util.grepfiles( 'time=', 'TestResults*/testX/execute.log' )
            assert len( lineL ) == 1

    def test_get_blocking_dependencies_that_are_done(self):
        ""
        st = TestStatusHandler()

        depset,tcase = make_DependencySet_with_a_dependency( st, 'pass' )
        assert depset.getBlockingDependency() == None

        depset,tcase = make_DependencySet_with_a_dependency( st, 'fail' )
        assert depset.getBlockingDependency() != None

        depset,tcase = make_DependencySet_with_a_dependency( st, 'fail', '*' )
        assert depset.getBlockingDependency() == None

        depset,tcase = make_DependencySet_with_a_dependency( st, 'fail',
                                                             'pass or fail' )
        assert depset.getBlockingDependency() == None

    def test_get_blocking_dependencies_that_are_running(self):
        ""
        st = TestStatusHandler()

        depset,tcase = make_DependencySet_with_a_dependency( st, 'running' )
        assert depset.getBlockingDependency() != None

        depset,tcase = make_DependencySet_with_a_dependency( st, 'pass' )
        assert depset.getBlockingDependency() == None
        append_to_DependencySet( st, depset, 'running' )
        assert depset.getBlockingDependency() != None

    def test_get_blocking_dependencies_that_are_skipped(self):
        ""
        st = TestStatusHandler()

        depset,tcase = make_DependencySet_with_a_dependency( st, 'skip' )
        assert depset.getBlockingDependency() != None

        depset,tcase = make_DependencySet_with_a_dependency( st, 'skip', '*' )
        assert depset.getBlockingDependency() == None

    def test_get_blocking_dependencies_that_have_not_run_yet(self):
        ""
        return # magic: still working on getBlockingDependency() method

        st = TestStatusHandler()

        depset,tcase = make_DependencySet_with_a_dependency( st, 'notrun' )
        assert depset.getBlockingDependency() != None

    # def test_a_notrun_may_or_may_not_be_a_blocking_dependency(self):
    #     ""
    #     st = TestStatusHandler()
    #     depset,tcase = make_DependencySet_with_a_dependency( st, 'notrun' )

    #     assert depset.getBlocking() != None

    #     assert depset.getBlocking( allow_notrun=True ) == None

    #     st.markStarted( tspec, time.time() )
    #     st.markDone( tspec, 0 )
    #     assert depset.getBlocking() == None

    # def test_a_notdone_is_a_blocking_dependency(self):
    #     ""
    #     st = TestStatusHandler()
    #     depset,tcase = make_DependencySet_with_a_dependency( st, 'notdone' )

    #     assert depset.getBlocking() != None
    #     assert depset.getBlocking( allow_notrun=True ) != None

    def test_a_result_wildcard_will_ignore_a_skipped_dependency(self):
        ""
        return # magic: still working to fix result="*" on skipped tests

        util.writefile( 'testA.vvt', """
            #VVT: depends on (result="*") : testB testC
            import os
            import vvtest_util as vvt
            print ( vvt.DEPDIRS )
            assert len( vvt.DEPDIRS ) == 1
            """ )
        util.writefile( 'testB.vvt', """
            import os, time
            time.sleep(5)
            with open( 'checkfile', 'w' ) as fp:
                fp.write( 'hello'+os.linesep )
            """ )
        util.writefile( 'testC.vvt', """
            pass
            """ )
        time.sleep(1)

        for batch in [False,True]:

            vtu.remove_results()

            vrun = vtu.runvvtest( '-vv -k testA/testB', batch=batch )
            vrun.assertCounts( total=3, npass=2, skip=1 )

            lineL = util.grepfiles( 'time=', 'TestResults*/testX/execute.log' )
            assert len( lineL ) == 1


def make_DependencySet_with_a_dependency( statushandler, test_result,
                                          result_expr=None ):
    ""
    depset = depend.DependencySet( statushandler )
    tcase = vtu.make_fake_TestCase( test_result )

    wordexpr = make_word_expression( result_expr )

    tdep = depend.TestDependency( tcase, None, wordexpr )
    depset.addDependency( tdep )

    return depset, tcase


def append_to_DependencySet( statushandler, depset, test_result ):
    ""
    tcase = vtu.make_fake_TestCase( test_result )

    tdep = depend.TestDependency( tcase, None, None )
    depset.addDependency( tdep )


def make_word_expression( string_expr ):
    ""
    if string_expr == None:
        wx = None
    elif string_expr == '*':
        wx = FilterExpressions.WordExpression()
    else:
        wx = FilterExpressions.WordExpression( string_expr )

    return wx


############################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
