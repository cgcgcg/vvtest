#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST:

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import unittest
import time

try:
    from StringIO import StringIO
except:
    from io import StringIO

import testutils as util
from testutils import print3

import batchitf as bat
from batchjob import BatchJob


class Function_parse_variant( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test( cleanout=False )

    def test_empty(self):
        ""
        D = bat.parse_variant( '' )
        assert len(D) == 0

    def test_single_key_value(self):
        ""
        D = bat.parse_variant( 'key=value' )
        assert len(D) == 1
        assert D['key'] == 'value'

        D = bat.parse_variant( 'key=2' )
        assert len(D) == 1
        assert D['key'] == '2'

    def test_multiple_key_value(self):
        ""
        D = bat.parse_variant( 'key=value foo=2 bar=1.2' )
        assert len(D) == 3
        assert D['key'] == 'value'
        assert D['foo'] == '2'
        assert D['bar'] == '1.2'


class Function_lineprint( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test( cleanout=False )

    def test_empty_print(self):
        ""
        sio = StringIO()
        bat.lineprint( sio )
        assert len( sio.getvalue() ) == 0

    def test_print_empty_string(self):
        ""
        sio = StringIO()
        bat.lineprint( sio, '' )
        assert sio.getvalue() == '\n'

    def test_print_some_lines(self):
        ""
        sio = StringIO()
        bat.lineprint( sio, 'line one', 'line two' )
        assert sio.getvalue() == 'line one\nline two\n'


class Function_compute_num_nodes( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test( cleanout=False )

    def test_platform_ppn_is_one(self):
        ""
        assert bat.compute_num_nodes( 0, None, 1 ) == 1
        assert bat.compute_num_nodes( 1, None, 1 ) == 1
        assert bat.compute_num_nodes( 2, None, 1 ) == 2

    def test_platform_ppn_is_two(self):
        ""
        assert bat.compute_num_nodes( 0, None, 2 ) == 1
        assert bat.compute_num_nodes( 1, None, 2 ) == 1
        assert bat.compute_num_nodes( 2, None, 2 ) == 1
        assert bat.compute_num_nodes( 3, None, 2 ) == 2
        assert bat.compute_num_nodes( 4, None, 2 ) == 2
        assert bat.compute_num_nodes( 5, None, 2 ) == 3

    def test_requested_cores_per_node_equals_one(self):
        ""
        assert bat.compute_num_nodes( 1, 1, 8 ) == 1
        assert bat.compute_num_nodes( 2, 1, 8 ) == 2
        assert bat.compute_num_nodes( 0, 1, 8 ) == 1

    def test_requested_cores_per_node_equals_two(self):
        ""
        assert bat.compute_num_nodes( 0, 2, 8 ) == 1
        assert bat.compute_num_nodes( 1, 2, 8 ) == 1
        assert bat.compute_num_nodes( 2, 2, 8 ) == 1
        assert bat.compute_num_nodes( 3, 2, 8 ) == 2
        assert bat.compute_num_nodes( 4, 2, 8 ) == 2
        assert bat.compute_num_nodes( 5, 2, 8 ) == 3

    def test_platform_ppn_is_None(self):
        ""
        assert bat.compute_num_nodes( 0, 2, None ) == 1
        assert bat.compute_num_nodes( 1, 2, None ) == 1
        assert bat.compute_num_nodes( 2, 2, None ) == 1
        assert bat.compute_num_nodes( 3, 2, None ) == 2

        assert bat.compute_num_nodes( 0, None, None ) == 1
        assert bat.compute_num_nodes( 1, None, None ) == 1
        assert bat.compute_num_nodes( 2, None, None ) == 1
        assert bat.compute_num_nodes( 3, None, None ) == 1


class Function_format_time_to_HMS( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test( cleanout=False )

    def test_string_with_a_colon_is_returned_unchanged(self):
        ""
        hms = bat.format_time_to_HMS( '0:01' )
        assert hms == '0:01'

    def test_string_without_a_colon_is_converted_to_seconds(self):
        ""
        hms = bat.format_time_to_HMS( '66' )
        assert hms == '0:01:06'

    def test_less_than_a_minute(self):
        ""
        hms = bat.format_time_to_HMS( '59' )
        assert hms == '0:00:59'

        hms = bat.format_time_to_HMS( '09' )
        assert hms == '0:00:09'

        hms = bat.format_time_to_HMS( 9 )
        assert hms == '0:00:09'

        hms = bat.format_time_to_HMS( 0 )
        assert hms == '0:00:00'

    def test_less_than_an_hour(self):
        ""
        hms = bat.format_time_to_HMS( 5*60 )
        assert hms == '0:05:00'

        hms = bat.format_time_to_HMS( 5*60+34 )
        assert hms == '0:05:34'

        hms = bat.format_time_to_HMS( 59*60+59 )
        assert hms == '0:59:59'

    def test_less_than_a_day(self):
        ""
        hms = bat.format_time_to_HMS( 60*60+1 )
        assert hms == '1:00:01'

        hms = bat.format_time_to_HMS( 60*60+11*60 )
        assert hms == '1:11:00'

        hms = bat.format_time_to_HMS( 60*60+11*60+11 )
        assert hms == '1:11:11'

    def test_more_than_a_day(self):
        ""
        hms = bat.format_time_to_HMS( 25*60*60+60 )
        assert hms == '25:01:00'

        hms = bat.format_time_to_HMS( 25*60*60+6 )
        assert hms == '25:00:06'

        hms = bat.format_time_to_HMS( 25*60*60+6*60+6 )
        assert hms == '25:06:06'


class Function_parse_date_string( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test( cleanout=False )

    def test_invalid_form(self):
        ""
        tm = bat.parse_date_string( 'foo bar' )
        assert tm == None

    def test_RHEL6_date_format(self):
        ""
        tm = bat.parse_date_string( 'Sun Mar  4 10:29:22 MST 2018' )
        assert abs( tm - 1520184562 ) < 2

        tm = bat.parse_date_string( 'Wed Jul  4 10:29:22 MDT 2018' )
        assert abs( tm - 1530721762 ) < 2


class Class_JobQueueTable( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test( cleanout=False )

    def test_set_job_info_then_get_job_info(self):
        ""
        t0 = time.time()

        tab = bat.JobQueueTable()

        tab.setJobInfo( '123', 'pending', None, None )
        assert tab.numJobs() == 1
        assert tab.hasJob( '123' )
        assert tab.getState( '123' ) == 'pending'
        assert tab.getStartDate( '123' ) == None
        assert tab.getTimeUsed( '123' ) == None

        tab.setJobInfo( '123', 'running', t0, None )
        assert tab.numJobs() == 1
        assert tab.hasJob( '123' )
        assert tab.getState( '123' ) == 'running'
        assert tab.getStartDate( '123' ) == t0
        assert tab.getTimeUsed( '123' ) == None

        tab.setJobInfo( '123', 'complete', t0, t0+5 )
        assert tab.numJobs() == 1
        assert tab.hasJob( '123' )
        assert tab.getState( '123' ) == 'complete'
        assert tab.getStartDate( '123' ) == t0
        assert tab.getTimeUsed( '123' ) == t0+5

        tab.setJobInfo( '123', 'done', t0, t0+5 )
        assert tab.numJobs() == 1
        assert tab.hasJob( '123' )
        assert tab.getState( '123' ) == 'done'
        assert tab.getStartDate( '123' ) == t0
        assert tab.getTimeUsed( '123' ) == t0+5

        tab.setJobInfo( '12', 'running', t0+2, None )
        assert tab.numJobs() == 2
        assert tab.hasJob( '123' ) and tab.hasJob( '12' )
        assert tab.getState( '123' ) == 'done'
        assert tab.getStartDate( '123' ) == t0
        assert tab.getTimeUsed( '123' ) == t0+5
        assert tab.getState( '12' ) == 'running'
        assert tab.getStartDate( '12' ) == t0+2
        assert tab.getTimeUsed( '12' ) == None

    def test_errors(self):
        ""
        tab = bat.JobQueueTable()

        self.assertRaises( Exception, tab.setJobInfo,
                           '123', 'stopped', None, None )

        tab.setJobInfo( '12', 'running', time.time(), None )
        assert tab.getState( '12' ) == 'running'
        self.assertRaises( Exception, tab.getState, '21' )
        self.assertRaises( Exception, tab.getStartDate, '21' )
        self.assertRaises( Exception, tab.getTimeUsed, '21' )


class BatchInterface_parseScriptDates_and_writeScriptFile( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

    def test_write_hollow_script_and_run_it(self):
        ""
        bi = bat.BatchInterface()
        job = BatchJob()

        fname = job.getBatchFileName()

        write_job_script( fname, bi, job )
        time.sleep(1)

        x,out,err = bat.run_shell_command( '/bin/bash '+fname )
        assert x == 0

    def test_write_script_run_then_parse_dates(self):
        ""
        bi = bat.BatchInterface()
        job = BatchJob()

        fname = job.getBatchFileName()

        write_job_script( fname, bi, job, 'sleep 5' )
        time.sleep(1)

        x,out,err = bat.run_shell_command( '/bin/bash '+fname )
        assert x == 0

        util.writefile( 'log.txt', out )
        time.sleep(1)

        start,stop = bi.parseScriptDates( 'log.txt' )

        assert time.time() - start < 10
        assert stop - start < 8

    def test_parsing_a_file_that_does_not_exist_returns_Nones(self):
        ""
        bi = bat.BatchInterface()

        start,stop = bi.parseScriptDates( 'log.txt' )

        assert start == None and stop == None

    def test_parse_a_file_without_a_stop_date(self):
        ""
        util.writefile( 'log.txt', """
            SCRIPT START DATE: Fri May 25 14:31:50 MDT 2018
            UNAME: Linux ceerws1803 2.6.32-642.1.1.el6.x8...
            cd .
            """ )
        time.sleep(1)

        bi = bat.BatchInterface()
        start,stop = bi.parseScriptDates( 'log.txt' )
        assert start != None and stop == None

    def test_parsing_a_corrupt_file(self):
        ""
        util.writefile( 'log1.txt', """
            SCRIPT START DATE: Fri May 25 14:31:50 MDT 2018
            UNAME: Linux ceerws1803 2.6.32-642.1.1.el6.x8...
            cd .
            SCRIPT STOP DATE: Fri May 25 14:31:55 MDT 2018
            """ )
        util.writefile( 'log2.txt', """
            SCRIPT START DATE: foo bar
            UNAME: Linux ceerws1803 2.6.32-642.1.1.el6.x8...
            cd .
            SCRIPT STOP DATE: Fri May 25 14:31:55 MDT 2018
            """ )
        util.writefile( 'log3.txt', """
            SCRIPT START DATE: Fri May 25 14:31:50 MDT 2018
            UNAME: Linux ceerws1803 2.6.32-642.1.1.el6.x8...
            cd .
            SCRIPT STOP DATE: foo bar
            """ )
        time.sleep(1)

        bi = bat.BatchInterface()
        start,stop = bi.parseScriptDates( 'log1.txt' )
        assert start != None and stop != None
        assert stop - start < 8

        bi = bat.BatchInterface()
        start,stop = bi.parseScriptDates( 'log2.txt' )
        assert start == None and stop != None

        bi = bat.BatchInterface()
        start,stop = bi.parseScriptDates( 'log3.txt' )
        assert start != None and stop == None

    def test_use_write_script_function(self):
        ""
        class SubBatchInterface( bat.BatchInterface ):
            def writeScriptHeader(self, job, fileobj):
                pass

        bi = SubBatchInterface()
        job = BatchJob()

        bi.writeScriptFile( job )
        time.sleep(1)

        fname = job.getBatchFileName()
        x,out,err = bat.run_shell_command( '/bin/bash '+fname )
        assert x == 0

        util.writefile( 'log.txt', out )
        time.sleep(1)

        start,stop = bi.parseScriptDates( 'log.txt' )

        assert time.time() - start < 10
        assert stop - start < 8


def write_job_script( fname, bitf, job, *command_lines ):
    """
    """
    fp = open( fname, 'w' )

    try:
        bitf.writeScriptShebang( job, fp )
        bitf.writeScriptBegin( job, fp )
        fp.write( '\n' + '\n'.join( command_lines ) +'\n' )
        bitf.writeScriptFinish( job, fp )

    finally:
        fp.close()


class Functions_update_job_dates( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test( cleanout=False )

    def test_updateJobQueueDates_on_nominal_queue_sequence(self):
        ""
        bi = bat.BatchInterface()
        job = BatchJob()
        tab = bat.JobQueueTable()

        t0 = time.time()
        job.setQueueDates( submit=t0 )

        tab.setJobInfo( job.getJobId(), 'pending', None, None )
        bi.updateJobQueueDates( job, tab, t0+1 )
        check_queue_dates( job, submit=t0, pending=t0+1 )

        tab.setJobInfo( job.getJobId(), 'running', t0+5, None )
        bi.updateJobQueueDates( job, tab, t0+10 )
        check_queue_dates( job, submit=t0, pending=t0+1, run=t0+5 )

        tab.setJobInfo( job.getJobId(), 'complete', t0+5, 20 )
        bi.updateJobQueueDates( job, tab, t0+30 )
        check_queue_dates( job, submit=t0, pending=t0+1, run=t0+5,
                                complete=t0+25, done=t0+30 )

    def test_updateJobExit_when_stop_date_is_set(self):
        ""
        bi = bat.BatchInterface()
        job = BatchJob()

        t0 = time.time()
        job.setScriptDates( start=t0, stop=t0+5 )

        bi.updateJobExit( job, t0+8 )
        check_script_dates( job, start=t0, stop=t0+5, done=t0+8 )


def check_queue_dates( job, submit=None, pending=None,
                            run=None, complete=None, done=None ):
    """
    """
    jsub,jpend,jrun,jcomp,jdone = job.getQueueDates()

    assert jsub == submit
    assert jpend == pending
    assert jrun  == run
    assert jcomp == complete
    assert jdone == done


def check_script_dates( job, start=None, stop=None, done=None ):
    """
    """
    jstart,jstop,jdone = job.getScriptDates()

    assert jstart == start
    assert jstop == stop
    assert jdone == done


############################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
