#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import time
import shutil
import glob
import shlex

import libvvtest.cmdline as cmdline
import libvvtest.vvplatform as vvplatform
import libvvtest.misc as misc
import libvvtest.TestSpec as TestSpec
import libvvtest.TestExec as TestExec
import libvvtest.TestList as TestList
from libvvtest.execlist import TestExecList
import libvvtest.batchutils as batchutils
import libvvtest.FilterExpressions as FilterExpressions
from libvvtest.RuntimeConfig import RuntimeConfig
import results
import libvvtest.testlistio as testlistio
import libvvtest.utesthooks as utesthooks
import libvvtest.resultswriter as resultswriter
import libvvtest.consolewriter as consolewriter
from libvvtest.outpututils import XstatusString, pretty_time, make_date_stamp
import libvvtest.pathutil as pathutil
from libvvtest.teststatus import TestStatusHandler, RESULTS_KEYWORDS
from libvvtest.printinfo import TestInformationPrinter
from libvvtest.TestSpecCreator import TestCreator
import libvvtest.userplugin as userplugin
from libvvtest.filtering import TestFilter


version = '1.2'

search_fnmatch = ['*.inp','*.apr','*.i']

testlist_name = 'testlist'

USER_PLUGIN_MODULE_NAME = 'vvtest_user_plugin'


class MainEntry:

    def __init__(self, argv):
        ""
        self.argv = argv

    def constructObjects(self):
        ""
        start_time = time.time()

        check_for_bootstrap_file()

        # this may call sys.exit (for help or errors)
        self.opts, self.optD, self.dirs = \
            cmdline.parse_command_line( self.argv[1:], version )

        self.rtdata = RuntimeData( self.argv, get_tools_directory() )

        self.constructConfiguration()

        insert_configdir_into_sys_path( self.rtdata )

        test_cache_dir = self.readCacheData()

        self.constructPlatform()

        self.constructTestSubdirectory()

        self.rtdata.setTestResultsDir( test_cache_dir )

        self.rtdata.setPermissionsObject( self.opts, self.optD )

        self.rtdata.setTestStatusHandler( TestStatusHandler() )

        self.constructResultsWriter( start_time )

        self.rtdata.setFilterPath()

        self.constructFilteringObjects()

    def execute(self):
        ""
        exitstat = 0

        if self.opts.dash_i or self.opts.keys or self.opts.files:
            mode = InformationMode( self.opts, self.optD, self.rtdata )
            exitstat = mode.run( self.dirs )

        elif self.opts.dash_g:
            generateTestList( self.opts, self.optD, self.dirs, self.rtdata )

        elif self.opts.dash_b:

            if self.opts.dash_R or self.opts.dash_w:
                print3( "*** error: cannot use -R or -w with -b (baseline)" )
                sys.exit(1)

            baselineTests( self.opts, self.optD, self.rtdata )

        elif self.opts.extract:
            extractTestFiles( self.opts, self.optD,
                              self.dirs, self.opts.extract, self.rtdata )

        else:

            # if no results keywords are specified, then add -k notrun/notdone
            if not self.opts.dash_w and not self.opts.dash_R:
                rtconfig = self.rtdata.getRuntimeConfig()
                rtconfig.addResultsKeywordExpression( 'notrun or notdone' )

            if self.rtdata.isRestartMode():
                exitstat = restartTests( self.opts, self.optD, self.rtdata )
            else:
                exitstat = runTests( self.opts, self.optD,
                                     self.rtdata, self.dirs )

        if self.opts.encode_exit_status:
            return exitstat

    def constructConfiguration(self):
        ""
        config = create_configuration( self.opts, self.optD,
                                       self.rtdata.getToolsDir() )
        self.rtdata.setConfiguration( config )

    def readCacheData(self):
        ""
        # non-None only if the CWD is in a TestResults.* directory
        test_cache_dir = readCommandInfo( self.opts, self.optD, self.rtdata )

        if test_cache_dir and self.optD['param_dict']:
            print3( "*** error: cannot use -S in a TestResults directory" )
            sys.exit(1)

        if test_cache_dir and self.opts.dash_g:
            print3( "*** error: cannot use -g in a TestResults directory" )
            sys.exit(1)

        # this is scheduled for deprecation
        if self.opts.check:
            for n in self.opts.check:
                os.environ[ 'CHECK_' + n.upper() ] = ''

        return test_cache_dir

    def constructPlatform(self):
        ""
        plat = construct_platform_instance( self.rtdata.getToolsDir(),
                                            self.opts, self.optD )
        self.rtdata.setPlatformObject( plat )

    def constructTestSubdirectory(self):
        ""
        sd = test_results_subdir_name( self.opts.run_dir,
                                       self.optD['onopts'], self.optD['offopts'],
                                       self.rtdata.getPlatformObject().getName() )
        self.rtdata.setTestSubdir( sd )

    def constructResultsWriter(self, start_time):
        ""
        resw = make_results_writer( self.opts, self.optD, start_time,
                                    self.rtdata.getToolsDir(),
                                    self.rtdata.getTestResultsDir(),
                                    self.rtdata.getPermissionsObject(),
                                    self.rtdata.getPlatformObject(),
                                    self.rtdata.cmdL,
                                    self.rtdata.getTestStatusHandler() )
        self.rtdata.setResultsWriter( resw )

    def constructFilteringObjects(self):
        ""
        platobj = self.rtdata.getPlatformObject()

        rtconfig = construct_RuntimeConfig( platobj, self.opts, self.optD )
        self.rtdata.setRuntimeConfig( rtconfig )

        creator = TestCreator( rtconfig )
        self.rtdata.setTestCreator( creator )

        plugmod = import_plugin_module()
        plug = userplugin.UserPluginBridge( rtconfig, plugmod )
        self.rtdata.setUserPlugin( plug )

        statushandler = self.rtdata.getTestStatusHandler()
        testfilter = TestFilter( rtconfig, statushandler, plug )
        self.rtdata.setTestFilter( testfilter )

        timehandler = TimeHandler( statushandler, plug, platobj,
                                   self.opts.dash_T,
                                   self.opts.timeout_multiplier,
                                   self.opts.max_timeout )
        self.rtdata.setTestTimeHandler( timehandler )


def import_plugin_module():
    ""
    try:
        plugmod = userplugin.import_module_by_name( USER_PLUGIN_MODULE_NAME )

    except userplugin.UserPluginError:
        print3( '*** error in user plugin script:',
                str( sys.exc_info()[1] ).strip() )
        print3( '*** user plugin disabled\n' )
        plugmod = None

    return plugmod


class Configuration:
    
    defaults = { \
                 'toolsdir':None,  # the top level tools directory
                 'configdir':None,  # the configuration directory
                 'exepath':None,  # the path to the executables
                 'onopts':[],
                 'offopts':[],
                 'refresh':1,
                 'postclean':0,
                 'timeout':None,
                 'multiplier':1.0,
                 'preclean':1,
                 'analyze':0,
                 'logfile':1,
                 'testargs':[],
               }
    
    def get(self, name):
        ""
        return self.attrs[name]
    
    def set(self, name, value):
        ""
        if value == None:
          self.attrs[name] = Configuration.defaults[name]
        else:
          self.attrs[name] = value
    
    def __init__(self):
        self.attrs = {}
        for n,v in Configuration.defaults.items():
          self.attrs[n] = v


def create_configuration( opts, optD, toolsdir ):
    ""
    config = Configuration()

    config.set( 'toolsdir', toolsdir )

    if optD['onopts']:
        config.set( 'onopts', optD['onopts'] )
    if optD['offopts']:
        config.set( 'offopts', optD['offopts'] )

    if opts.bin_dir:
        config.set( 'exepath', opts.bin_dir )

    if opts.config:
        config.set( 'configdir', opts.config[-1] )
    else:
        d = os.getenv( 'VVTEST_CONFIGDIR' )
        if d == None:
            d = os.path.join( toolsdir, 'config' )
        config.set( 'configdir', os.path.abspath(d) )

    config.set( 'refresh', not opts.dash_m )
    config.set( 'postclean', opts.postclean == True )

    if opts.dash_T != None:
        config.set( 'timeout', opts.dash_T )
    if opts.timeout_multiplier != None:
        config.set( 'multiplier', opts.timeout_multiplier )

    config.set( 'preclean', not opts.dash_m )
    config.set( 'analyze', opts.analyze == True )
    config.set( 'logfile', not opts.dash_L )

    if opts.test_args:
        argL = []
        for args in opts.test_args:
            argL.extend( shlex.split( args ) )
        config.set( 'testargs', argL )

    return config


class RuntimeData:

    def __init__(self, cmdL, toolsdir):
        """
        The 'toolsdir' is the directory containing this script.
        """
        self.cmdL = [ os.path.abspath( cmdL[0] ) ]
        self.cmdL.extend( cmdL[1:] )

        self.toolsdir = toolsdir

    def getToolsDir(self): return self.toolsdir

    def setConfiguration(self, config): self.config = config
    def getConfiguration(self): return self.config

    def setPlatformObject(self, platobj): self.plat = platobj
    def getPlatformObject(self): return self.plat

    def setRuntimeConfig(self, rtconfig): self.rtconfig = rtconfig
    def getRuntimeConfig(self): return self.rtconfig

    def setTestCreator(self, creator): self.creator = creator
    def getTestCreator(self): return self.creator

    def setUserPlugin(self, plugin): self.plugin = plugin
    def getUserPlugin(self): return self.plugin

    def setTestFilter(self, testfilter): self.testfilter = testfilter
    def getTestFilter(self): return self.testfilter

    def setTestSubdir(self, subdir): self.testsubdir = subdir
    def getTestSubdir(self): return self.testsubdir

    def setTestResultsDir(self, test_cache_dir):
        ""
        if test_cache_dir:
            assert os.path.isabs( test_cache_dir )
            self.test_dir = test_cache_dir
            self.is_restart = True
        else:
            self.test_dir = os.path.abspath( self.testsubdir )
            self.is_restart = False

    def getTestResultsDir(self): return self.test_dir

    def isRestartMode(self):
        """
        True if the CWD is within an existing test results directory
        """
        return self.is_restart

    def setPermissionsObject(self, opts, optD):
        self.perms = make_PermissionSetter( self.test_dir, opts.perms )
    def getPermissionsObject(self): return self.perms

    def setTestStatusHandler(self, statushandler):
        self.statushandler = statushandler
    def getTestStatusHandler(self): return self.statushandler

    def setResultsWriter(self, writer): self.results_writer = writer
    def getResultsWriter(self): return self.results_writer

    def setTestTimeHandler(self, timehandler): self.timehandler = timehandler
    def getTestTimeHandler(self): return self.timehandler

    def setFilterPath(self):
        ""
        cwd = os.getcwd()
        if pathutil.issubdir( self.test_dir, cwd ):
            d = pathutil.compute_relative_path( self.test_dir, cwd )
            self.filterdir = d
        else:
            self.filterdir = None

    def getFilterPath(self):
        """
        If the current working directory is a subdir of an existing test
        results directory, then this returns the relative path from the
        top of the test results directory to the current working directory.
        """
        return self.filterdir


def construct_platform_instance( toolsdir, opts, optD ):
    ""
    plat = vvplatform.create_Platform_instance(
                toolsdir,
                opts.plat,
                optD['platopt_dict'],  # --platopt
                opts.dash_e,
                opts.dash_n,
                opts.dash_N,
                optD['onopts'],        # -o
                optD['offopts'],       # -O
                opts.qsub_id )         # --qsub-id

    return plat


def construct_RuntimeConfig( plat, opts, optD ):
    ""
    rtconfig = RuntimeConfig( \
                  param_expr_list=optD['param_list'],
                  keyword_expr=optD['keyword_expr'],
                  option_list=( optD['onopts'] + [plat.getCompiler()] ),
                  platform_name=plat.getName(),
                  ignore_platforms=( opts.dash_A == True ),
                  set_platform_expr=optD['platform_expr'],
                  search_file_globs=search_fnmatch,
                  search_regexes=optD['search_regexes'],
                  include_tdd=( opts.include_tdd == True ),
                  runtime_range=[ opts.tmin, opts.tmax ],
                  runtime_sum=opts.tsum,
                  maxprocs=plat.getMaxProcs() )

    if opts.qsub_id != None:
        rtconfig.setAttr( 'include_all', True )

    return rtconfig


class InformationMode:

    def __init__(self, opts, optD, rtdata):
        ""
        self.opts = opts
        self.optD = optD
        self.rtdata = rtdata

    def run(self, scan_dirs):
        ""
        exitcode = 0

        # always include tdd in info mode
        self.rtdata.getRuntimeConfig().setAttr( 'include_tdd', True )

        plat = self.rtdata.getPlatformObject()

        tlist = self.loadTestList( scan_dirs )

        test_dir = self.rtdata.getTestResultsDir()

        if self.opts.keys:
            self.printKeywordUnion( tlist )

        elif self.opts.files:
            self.printTestFiles( tlist )

        else:
            self.rtdata.getResultsWriter().info( tlist )
            exitcode = tlist.encodeIntegerWarning()

        return exitcode

    def loadTestList(self, scan_dirs):
        ""
        test_dir = self.rtdata.getTestResultsDir()

        tlist = self.createTestList()

        if self.rtdata.isRestartMode():
            tlist.readTestList()
            tlist.readTestResults()

        elif self.opts.keys or self.opts.files:
            scan_test_source_directories( tlist, scan_dirs,
                                          self.optD['param_dict'] )

        elif os.path.exists( test_dir ):
            tlist.readTestList()
            tlist.readTestResults()

        tlist.determineActiveTests( filter_dir=self.rtdata.getFilterPath() )

        return tlist

    def createTestList(self):
        ""
        test_dir = self.rtdata.getTestResultsDir()

        tfile = os.path.join( test_dir, testlist_name )
        if not os.path.exists( tfile ):
            tfile = None

        return make_TestList( self.rtdata, tfile )

    def printKeywordUnion(self, tlist):
        ""
        print3( "\nresults keywords: " + ' '.join( RESULTS_KEYWORDS ) )
        kd = {}
        for t in tlist.getActiveTests():
            for k in t.getKeywords( include_implicit=False ):
                kd[k] = None
        L = list( kd.keys() )
        L.sort()
        print3( "\ntest keywords: " )
        while len(L) > 0:
            k1 = L.pop(0)
            if len(L) > 0: k2 = L.pop(0)
            else:          k2 = ''
            if len(L) > 0: k3 = L.pop(0)
            else:          k3 = ''
            print3( "  %-20s %-20s %-20s" % (k1,k2,k3) )

    def printTestFiles(self, tlist):
        ""
        D = {}
        for t in tlist.getActiveTests():
            d = os.path.normpath( t.getFilename() )
            D[d] = None
        L = list( D.keys() )
        L.sort()
        for d in L:
            print3( d )


def make_TestList( rtdata, filename ):
    ""
    rtconfig = rtdata.getRuntimeConfig()
    statushandler = rtdata.getTestStatusHandler()
    creator = rtdata.getTestCreator()
    testfilter = rtdata.getTestFilter()

    return TestList.TestList( statushandler, filename,
                              rtconfig, creator, testfilter )


##############################################################################
#
# generation of tests


def scan_test_source_directories( tlist, scan_dirs, setparams ):
    ""
    # default scan directory is the current working directory
    if len(scan_dirs) == 0:
        scan_dirs = ['.']

    for d in scan_dirs:
        if not os.path.exists(d):
            sys.stderr.write(
                '*** error: directory does not exist: ' + str(d) + '\n')
            sys.exit(1);
        tlist.scanDirectory( d, setparams )


def generateTestList( opts, optD, dirs, rtdata ):
    """
    """
    config = rtdata.getConfiguration()
    plat = rtdata.getPlatformObject()
    testsubdir = rtdata.getTestSubdir()
    perms = rtdata.getPermissionsObject()
    statushandler = rtdata.getTestStatusHandler()
    timehandler = rtdata.getTestTimeHandler()
    plugin = rtdata.getUserPlugin()

    test_dir = os.path.abspath( testsubdir )

    tfile = os.path.join( test_dir, testlist_name )

    tlist = make_TestList( rtdata, tfile )

    scan_test_source_directories( tlist, dirs, optD['param_dict'] )

    timehandler.load( tlist )

    tlist.applyPermanentFilters()

    rtdata.getResultsWriter().prerun( tlist, abbreviate=False )
    print3()

    createTestDir( testsubdir, perms, opts.dash_M )
    writeCommandInfo( opts, optD, rtdata, test_dir, plat, perms )

    tlist.stringFileWrite()
    perms.set( os.path.abspath( tfile ) )

    xlist = TestExecList( statushandler, plugin, tlist )
    xlist.createTestExecs( test_dir, plat, config, perms )

    print3( "Test directory:", testsubdir )


def extractTestFiles( opts, optD, dirs, target_dir, rtdata ):
    """
    Uses all the regular filtering mechanisms to gather tests from a test
    source area and copies the files used for each test into a separate
    directory.
    """
    plat = rtdata.getPlatformObject()
    statushandler = rtdata.getTestStatusHandler()
    timehandler = rtdata.getTestTimeHandler()

    tlist = make_TestList( rtdata, None )

    scan_test_source_directories( tlist, dirs, optD['param_dict'] )

    timehandler.load( tlist )

    tlist.applyPermanentFilters()

    if not os.path.isabs(target_dir):
        target_dir = os.path.abspath(target_dir)
    if not os.path.exists(target_dir):
        os.makedirs( target_dir )
    
    uniqD = {}
    
    def wvisit( arg, dname, dirs, files ):
        """
        copy a directory tree, but leave out version control files
        """
        for n in ['CVS','.cvsignore','.svn','.git','.gitignore']:
            while (n in dirs): dirs.remove(n)
            while (n in files): files.remove(n)
        fd = os.path.normpath( os.path.join( arg[0], dname ) )
        td = os.path.normpath( os.path.join( arg[1], dname ) )
        if not os.path.exists(td):
            os.makedirs(td)
        for f1 in files:
            f2 = os.path.join(fd,f1)
            tf = os.path.join(td,f1)
            shutil.copy2( f2, tf )
    
    for t in tlist.getActiveTests():

        tname = t.getName()
        T = (tname, t.getFilename())

        from_dir = os.path.dirname( t.getFilename() )
        p = os.path.dirname( t.getFilepath() )
        if p: to_dir = os.path.normpath( os.path.join( target_dir, p ) )
        else: to_dir = target_dir

        if not os.path.exists( to_dir ):
            os.makedirs( to_dir )
        tof = os.path.join( target_dir, t.getFilepath() )

        if tof not in uniqD:
            uniqD[tof] = None
            try: shutil.copy2( t.getFilename(), tof )
            except IOError: pass

        for srcf in t.getSourceFiles():

            if os.path.exists( os.path.join( from_dir, srcf ) ):
                fL = [ srcf ]
            else:
                cwd = os.getcwd()
                try:
                    os.chdir( from_dir )
                    fL = glob.glob( srcf )
                except Exception:
                    fL = []
                os.chdir( cwd )

            for f in fL:
                fromf = os.path.join( from_dir, f )
                tof = os.path.join( to_dir, f )
                tod = os.path.dirname(tof)
                if tof not in uniqD:
                    uniqD[tof] = None
                    if not os.path.exists(tod):
                        os.makedirs(tod)
                    
                    if os.path.isdir(fromf):
                        cwd = os.getcwd()
                        os.chdir(fromf)
                        for root,dirs,files in os.walk( '.' ):
                            wvisit( (fromf, tof), root, dirs, files )
                        os.chdir(cwd)
                      
                    else:
                        try: shutil.copy2( fromf, tof )
                        except IOError: pass


##############################################################################


def test_results_subdir_name( rundir, onopts, offopts, platform_name ):
    """
    Generates and returns the subdirectory name to hold test results, which is
    unique up to the platform and on/off options.
    """
    if rundir:
        testdirname = rundir

    else:
        testdirname = 'TestResults.' + platform_name
        if onopts and len(onopts) > 0:
          testdirname += '.ON=' + '_'.join( onopts )
        if offopts and len(offopts) > 0:
          testdirname += '.OFF=' + '_'.join( offopts )
    
    return testdirname


def createTestDir( testdirname, perms, mirdir ):
    """
    Create the given directory name.  If -M is given in the command line
    options, then a mirror directory is created and 'testdirname' will be
    created as a soft link pointing to the mirror directory.
    """
    if mirdir and makeMirrorDirectory( mirdir, testdirname, perms ):
        pass

    else:
        if os.path.exists( testdirname ):
            if not os.path.isdir( testdirname ):
                # replace regular file with a directory
                os.remove( testdirname )
                os.mkdir( testdirname )
        else:
            if os.path.islink( testdirname ):
                os.remove( testdirname )  # remove broken softlink
            os.mkdir( testdirname )

        perms.set( os.path.abspath( testdirname ) )


def makeMirrorDirectory( Mval, testdirname, perms ):
    """
    Create a directory in another location then soft link 'testdirname' to it.
    Returns False only if 'Mval' is the word "any" and a suitable scratch
    directory could not be found.
    """
    assert testdirname == os.path.basename( testdirname )

    if Mval == 'any':
      
        usr = getUserName()
        for d in ['/var/scratch', '/scratch', '/var/scratch1', '/scratch1', \
                  '/var/scratch2', '/scratch2', '/var/scrl1', '/gpfs1']:
            if os.path.exists(d) and os.path.isdir(d):
                ud = os.path.join( d, usr )
                if os.path.exists(ud):
                    if os.path.isdir(ud) and \
                       os.access( ud, os.X_OK ) and os.access( ud, os.W_OK ):
                        Mval = ud
                        break
                elif os.access( d, os.X_OK ) and os.access( d, os.W_OK ):
                    try:
                        os.mkdir(ud)
                    except Exception:
                        pass
                    else:
                        Mval = ud
                        break
        
        if Mval == 'any':
            return False  # a scratch dir could not be found
        
        # include the current directory name in the mirror location
        curdir = os.path.basename( os.getcwd() )
        Mval = os.path.join( Mval, curdir )

        if not os.path.exists( Mval ):
            os.mkdir( Mval )

    else:
        Mval = os.path.abspath( Mval )
    
    if not os.path.exists( Mval ) or not os.path.isdir( Mval ) or \
       not os.access( Mval, os.X_OK ) or not os.access( Mval, os.W_OK ):
        raise Exception( "invalid or non-existent mirror directory: "+Mval )

    if os.path.samefile( Mval, os.getcwd() ):
        raise Exception( "mirror directory and current working directory " + \
                "are the same: "+Mval+' == '+os.getcwd() )

    mirdir = os.path.join( Mval, testdirname )

    if os.path.exists( mirdir ):
        if not os.path.isdir( mirdir ):
            # replace regular file with a directory
            os.remove( mirdir )
            os.mkdir( mirdir )
    else:
        if os.path.islink( mirdir ):
            os.remove( mirdir )  # remove broken softlink
        os.mkdir( mirdir )
    
    perms.set( os.path.abspath( mirdir ) )

    if os.path.islink( testdirname ):
        path = os.readlink( testdirname )
        if path != mirdir:
            os.remove( testdirname )
            os.symlink( mirdir, testdirname )

    else:
        if os.path.exists( testdirname ):
            if os.path.isdir( testdirname ):
                shutil.rmtree( testdirname )
            else:
                os.remove( testdirname )
        os.symlink( mirdir, testdirname )
    
    return True


def writeCommandInfo( opts, optD, rtdata, test_dir, plat, perms ):
    """
    Creates the test results information file.
    """
    config = rtdata.getConfiguration()

    f = os.path.join(test_dir, 'test.cache')
    if not os.path.exists( f ):
        fp = open( f, "w" )
        fp.write( 'VERSION=' + str(version) + '\n' )
        fp.write( 'DIR=' + os.getcwd() + '\n' )
        if opts.plat:
              fp.write( 'PLATFORM=' + opts.plat.strip() + '\n' )
        else:
              fp.write( 'PLATFORM=' + plat.getName() + '\n' )
        if optD['param_list']:
            fp.write( 'PARAMETERS=' + str( optD['param_list'] ) + '\n' )
        if config.get('exepath'):
            fp.write( \
                'PROJECT=' + os.path.abspath( config.get('exepath') ) + '\n' )
        if optD['onopts']:
            fp.write( 'ONOPTS=' + '+'.join( optD['onopts'] ) + '\n' )
        if optD['offopts']:
            fp.write( 'OFFOPTS=' + '+'.join( optD['offopts'] ) + '\n' )
        if opts.dash_T != None:
            fp.write( 'TIMEOUT=' + str(opts.dash_T).strip() + '\n' )
        if opts.timeout_multiplier != None:
            fp.write( 'TIMEOUT_MULTIPLIER=' + \
                                   str(opts.timeout_multiplier).strip() + '\n' )
        if opts.dash_e:
            fp.write( 'USE_ENV=1\n' )
        if opts.dash_A:
            fp.write( 'ALL_PLATFORMS=1\n' )
        if opts.include_tdd:
            fp.write( 'INCLUDE_TDD=True\n' )
        if opts.check:
            fp.write( 'CHECK=' + ' '.join( opts.check ) + '\n' )
        fp.close()

    perms.set( os.path.abspath(f) )


def readCommandInfo( opts, optD, rtdata ):
    """
    Check for a file called 'test.cache' that indicates whether the
    current working directory is a TestResults directory (or subdirectory)
    then open that file for information.  The test results directory is
    returned, or None if not in a TestRestults directory.
    """
    config = rtdata.getConfiguration()

    # an environment variable is used to identify vvtest run recursion
    troot = os.environ.get( 'VVTEST_TEST_ROOT', None )

    test_cache = misc.find_vvtest_test_root_file(
                                        os.getcwd(), troot, 'test.cache' )

    if test_cache != None:

        if optD['onopts'] or optD['offopts'] or opts.dash_g:
            sys.stderr.write('*** error: ' + \
                'the -g, -o, and -O options are not allowed ' + \
                'in a TestResults directory\n')
            sys.exit(1);

        fp = open( test_cache, "r" )
        write_version = 0
        for line in fp.readlines():
            line = line.strip()
            kvpair = line.split( '=', 1 )
            if kvpair[0] == 'VERSION':
                write_version = kvpair[1]
            elif kvpair[0] == 'DIR':
                previous_run_dir = kvpair[1]
            elif kvpair[0] == 'PLATFORM':
                opts.plat = kvpair[1]
            elif kvpair[0] == 'PARAMETERS':
                L = eval( kvpair[1] )
                if optD['param_list']: optD['param_list'].extend(L)
                else:                  optD['param_list'] = L
            elif kvpair[0] == 'PROJECT':
                # do not replace if the command line contains -j
                if not opts.bin_dir:
                    opts.bin_dir = kvpair[1]
                    config.set( 'exepath', kvpair[1] )
            elif kvpair[0] == 'ONOPTS':
                optD['onopts'] = kvpair[1].split( '+' )
                config.set( 'onopts', optD['onopts'] )
            elif kvpair[0] == 'OFFOPTS':
                optD['offopts'] = kvpair[1].split( '+' )
                config.set( 'offopts', optD['offopts'] )
            elif kvpair[0] == 'TIMEOUT':
                # do not replace if the command line contains -T
                if opts.dash_T == None:
                    opts.dash_T = kvpair[1]
                    config.set( 'timeout', float(opts.dash_T) )
            elif kvpair[0] == 'TIMEOUT_MULTIPLIER':
                if not opts.timeout_multiplier:
                    opts.timeout_multiplier = float(kvpair[1])
                    config.set( 'multiplier', opts.timeout_multiplier )
            elif kvpair[0] == 'USE_ENV':
                opts.dash_e = True
            elif kvpair[0] == 'ALL_PLATFORMS':
                opts.dash_A = True
            elif kvpair[0] == 'INCLUDE_TDD':
                opts.include_tdd = True
            elif kvpair[0] == 'CHECK':
                opts.check = kvpair[1].split()
        fp.close()

    if test_cache != None:
        return os.path.dirname( test_cache )
    return None


def exec_path( testspec, test_dir ):
    ""
    xdir = testspec.getExecuteDirectory()
    return pathutil.relative_execute_directory( xdir, test_dir, os.getcwd() )


def runTests( opts, optD, rtdata, dirs ):
    """
    Executes a list of tests.
    """
    config = rtdata.getConfiguration()
    plat = rtdata.getPlatformObject()
    testsubdir = rtdata.getTestSubdir()
    statushandler = rtdata.getTestStatusHandler()
    timehandler = rtdata.getTestTimeHandler()
    plugin = rtdata.getUserPlugin()

    # determine the directory that stores the test results then create it
    test_dir = os.path.abspath( testsubdir )
    tfile = os.path.join( test_dir, testlist_name )

    tlist = make_TestList( rtdata, tfile )

    check_for_currently_running_vvtest( tlist.getResultsFilenames(), opts.force )

    # this variable allows vvtest tests to run vvtest (ie, allows recursion)
    os.environ['VVTEST_TEST_ROOT'] = os.path.normpath( test_dir )

    perms = rtdata.getPermissionsObject()

    createTestDir( testsubdir, perms, opts.dash_M )

    if opts.dash_w:
        pathutil.remove_directory_contents( testsubdir )

    writeCommandInfo( opts, optD, rtdata, test_dir, plat, perms )

    scan_test_source_directories( tlist, dirs, optD['param_dict'] )

    tlist.readTestList()

    timehandler.load( tlist )

    tlist.applyPermanentFilters()

    # save the test list in the TestResults directory
    tlist.stringFileWrite()
    perms.set( os.path.abspath( tfile ) )

    tlist.readTestResults()
    tlist.ensureInlinedTestResultIncludes()

    tlist.determineActiveTests()

    results_writer = rtdata.getResultsWriter()

    results_writer.prerun( tlist )
    print3()

    if tlist.numActive() > 0:

        xlist = TestExecList( statushandler, plugin, tlist )
        xlist.createTestExecs( test_dir, plat, config, perms )

        if not opts.batch:
            executeTestList( opts, optD, rtdata,
                             tlist, xlist, test_dir, plat, perms, tfile,
                             results_writer )

        else:
            batchTestList( opts, optD, rtdata,
                           tlist, xlist, test_dir, plat, perms,
                           results_writer )

        print3( "Test directory:", testsubdir )

    results_writer.final( tlist )

    return tlist.encodeIntegerWarning()


def check_for_currently_running_vvtest( resultsfiles, optforce ):
    ""
    if not optforce:

        msg = '*** error: tests are currently running in another process\n' + \
              '    (or a previous run was killed); use --force to run anyway'

        if len(resultsfiles) > 0:

            rfile = resultsfiles[-1]

            tlr = testlistio.TestListReader( rfile )
            fin = tlr.scanForFinishDate()
            if fin == None:
                print3( msg )
                sys.exit(1)


def determine_verbose_integer( dash_v ):
    ""
    if dash_v:
        verb = 1 + dash_v
    else:
        verb = 1

    return verb


def make_results_writer( opts, optD,
                         start_time, toolsdir,
                         test_dir, perms,
                         platobj, cmdL, statushandler ):
    ""
    verb = determine_verbose_integer( opts.dash_v )

    conobj = consolewriter.ConsoleWriter( statushandler, sys.stdout, test_dir,
                                          verbose=verb )
    conobj.setSortingSpecification( optD['sort_letters'] )

    htmlobj = None
    junitobj = None
    gitlabobj = None
    wlistobj = None

    if opts.qsub_id == None:

        if opts.html:
            import libvvtest.htmlwriter as htmlwriter
            htmlobj = htmlwriter.HTMLWriter( statushandler,
                                             perms,
                                             opts.html,
                                             test_dir )

        if opts.junit:
            import libvvtest.junitwriter as junitwriter
            junitobj = junitwriter.JUnitWriter( statushandler,
                                                perms,
                                                opts.junit,
                                                test_dir )
            junitobj.setOutputDate( opts.results_date )

        if opts.gitlab:
            import libvvtest.gitlabwriter as gitlabwriter
            gitlabobj = gitlabwriter.GitLabWriter( statushandler,
                                                   perms,
                                                   opts.gitlab,
                                                   test_dir )
            gitlabobj.setSortingSpecification( optD['sort_letters'] )

        if opts.save_results:
            import libvvtest.listwriter as listwriter
            wlistobj = listwriter.ListWriter( statushandler,
                                              perms,
                                              platobj.testingDirectory(),
                                              test_dir )
            wlistobj.setOutputDate( opts.results_date )
            wlistobj.setNamingTags( optD['onopts'], opts.results_tag )

    writer = resultswriter.ResultsWriter( conobj, htmlobj, junitobj,
                                          gitlabobj, wlistobj )

    writer.setRunAttr( startdate=str(start_time)+' / '+time.ctime(start_time) )
    writer.setRunAttr( platform=platobj.getName() )
    writer.setRunAttr( compiler=platobj.getCompiler() )
    writer.setRunAttr( commandline=' '.join( cmdL ) )
    writer.setRunAttr( hostname=os.uname()[1] )
    writer.setRunAttr( rundir=test_dir )
    writer.setRunAttr( curdir=os.getcwd() )
    writer.setRunAttr( python=sys.executable )
    writer.setRunAttr( vvtest=toolsdir )
    writer.setRunAttr( PYTHONPATH=os.environ.get( 'PYTHONPATH', '' ) )
    writer.setRunAttr( PATH=os.environ.get( 'PATH', '' ) )
    writer.setRunAttr( LOADEDMODULES=os.environ.get( 'LOADEDMODULES', '' ) )

    return writer


def executeTestList( opts, optD, rtdata,
                     tlist, xlist, test_dir, plat, perms, tfile,
                     results_writer ):
    """
    """
    statushandler = rtdata.getTestStatusHandler()

    plat.display()
    starttime = time.time()
    print3( "Start time:", time.ctime() )

    uthook = utesthooks.construct_unit_testing_hook( 'run', opts.qsub_id )

    rfile = tlist.initializeResultsFile()

    try:

        info = TestInformationPrinter( statushandler, sys.stdout, xlist )

        # execute tests

        perms.set( os.path.abspath( rfile ) )

        cwd = os.getcwd()

        while True:

            tnext = xlist.popNext( plat )

            if tnext != None:
                print3( 'Starting:', exec_path( tnext.atest, test_dir ) )
                tnext.start()
                tlist.appendTestResult( tnext.atest )
            
            elif xlist.numRunning() == 0:
                break

            else:
                info.checkPrint()
                time.sleep(1)

            showprogress = False
            for tx in list( xlist.getRunning() ):
                if tx.poll():
                    xs = XstatusString( statushandler, tx, test_dir, cwd )
                    print3( "Finished:", xs )
                    xlist.testDone( tx )
                    showprogress = True
          
            uthook.check( xlist.numRunning(), xlist.numDone() )

            if showprogress:
                ndone = xlist.numDone()
                ntot = tlist.numActive()
                pct = 100 * float(ndone) / float(ntot)
                div = str(ndone)+'/'+str(ntot)
                dt = pretty_time( time.time() - starttime )
                print3( "Progress: " + div+" = %%%.1f"%pct + ', time = '+dt )

    finally:
        tlist.writeFinished()

    # any remaining tests cannot run, so print warnings
    tL = xlist.popRemaining()
    if len(tL) > 0:
        print3()
    for tx in tL:
        depset = tx.getDependencySet()
        deptx = depset.getBlocking()
        assert depset.numDependencies() > 0 and deptx != None
        if isinstance( deptx, TestExec.TestExec ):
            xdir = deptx.atest.getExecuteDirectory()
        else:
            xdir = deptx.getExecuteDirectory()
        print3( '*** Warning: test "'+tx.atest.getExecuteDirectory()+'"',
                'notrun due to dependency "' + xdir + '"' )

    print3()
    results_writer.postrun( tlist )

    elapsed = pretty_time( time.time() - starttime )
    print3( "\nFinish date:", time.ctime() + " (elapsed time "+elapsed+")" )


def batchTestList( opts, optD, rtdata,
                   tlist, xlist, test_dir, plat, perms,
                   results_writer ):
    """
    The 'tlist' is a TestList class instance.
    """
    assert opts.qsub_id == None

    statushandler = rtdata.getTestStatusHandler()

    qsublimit = opts.batch_limit
    if qsublimit == None:
        qsublimit = plat.getDefaultQsubLimit()

    batch = Batcher( rtdata, opts, optD,
                     plat, tlist, xlist, perms,
                     test_dir, qsublimit )

    plat.display()
    starttime = time.time()
    print3( "Start time:", time.ctime() )

    results_suffix = tlist.setResultsSuffix()

    # write testlist files for each qsub
    numjobs = batch.writeQsubScripts( results_suffix )

    print3( 'Total number of batch jobs: ' + str(numjobs) + \
            ', maximum concurrent jobs: ' + str(qsublimit) )

    if opts.dash_g:
      return
    
    schedule = batch.getScheduler()

    cwd = os.getcwd()
    qsleep = int( os.environ.get( 'VVTEST_BATCH_SLEEP_LENGTH', 15 ) )

    uthook = utesthooks.construct_unit_testing_hook( 'batch' )

    rfile = tlist.initializeResultsFile()
    for inclf in batch.getIncludeFiles():
        tlist.addIncludeFile( inclf )

    info = TestInformationPrinter( statushandler, sys.stdout, tlist, batch )

    try:
        while True:

            qid = schedule.checkstart()
            if qid != None:
                # nothing to print here because the qsubmit prints
                pass
            elif schedule.numInFlight() == 0:
                break
            else:
                sleep_with_info_check( info, qsleep )

            qidL,doneL = schedule.checkdone()
            
            if len(qidL) > 0:
                ids = ' '.join( [ str(qid) for qid in qidL ] )
                print3( 'Finished batch IDS:', ids )
            for t in doneL:
                ts = XstatusString( statushandler, t, test_dir, cwd )
                print3( "Finished:", ts )

            uthook.check( schedule.numInFlight(), schedule.numPastQueue() )

            if len(doneL) > 0:
                jpct = 100 * float(schedule.numDone()) / float(numjobs)
                jdiv = 'jobs '+str(schedule.numDone())+'/'+str(numjobs)
                jflt = '(in flight '+str(schedule.numStarted())+')'
                ndone = xlist.numDone()
                ntot = tlist.numActive()
                tpct = 100 * float(ndone) / float(ntot)
                tdiv = 'tests '+str(ndone)+'/'+str(ntot)
                dt = pretty_time( time.time() - starttime )
                print3( "Progress: " + \
                        jdiv+" = %%%.1f"%jpct + ' '+jflt+', ' + \
                        tdiv+" = %%%.1f"%tpct + ', ' + \
                        'time = '+dt )

        # any remaining tests cannot be run; flush then print warnings
        NS, NF, nrL = schedule.flush()

    finally:
        tlist.writeFinished()

    tlist.inlineIncludeFiles()

    perms.set( os.path.abspath( rfile ) )

    if len(NS)+len(NF)+len(nrL) > 0:
        print3()
    if len(NS) > 0:
      print3( "*** Warning: these batch numbers did not seem to start:",
              ' '.join(NS) )
    if len(NF) > 0:
      print3( "*** Warning: these batch numbers did not seem to finish:",
              ' '.join(NF) )
    for tx,deptx in nrL:
        depset = tx.getDependencySet()
        assert depset.numDependencies() > 0 and deptx != None
        if isinstance( deptx, TestExec.TestExec ):
            xdir = deptx.atest.getExecuteDirectory()
        else:
            xdir = deptx.getExecuteDirectory()
        print3( '*** Warning: test "'+tx.atest.getExecuteDirectory()+'"',
                'notrun due to dependency "' + xdir + '"' )

    print3()
    results_writer.postrun( tlist )
    
    elapsed = pretty_time( time.time() - starttime )
    print3( "\nFinish date:", time.ctime() + " (elapsed time "+elapsed+")" )


def sleep_with_info_check( info, qsleep ):
    ""
    for i in range( int( qsleep + 0.5 ) ):
        info.checkPrint()
        time.sleep( 1 )


class TimeHandler:

    def __init__(self, statushandler, userplugin, platobj, cmdline_timeout,
                       timeout_multiplier, max_timeout):
        ""
        self.statushandler = statushandler
        self.plugin = userplugin
        self.platobj = platobj
        self.cmdline_timeout = cmdline_timeout
        self.tmult = timeout_multiplier
        self.maxtime = max_timeout

    def load(self, tlist):
        """
        For each test, a 'runtimes' file will be read (if it exists) and the
        run time for this platform extracted.  This run time is saved as the
        test execute time.  Also, a timeout is calculated for each test and
        placed in the 'timeout' attribute.
        """
        pname = self.platobj.getName()
        cplr = self.platobj.getCompiler()

        cache = results.LookupCache( pname, cplr, self.platobj.testingDirectory() )

        for t in tlist.getTests():

            tout = self.plugin.testTimeout( t )
            if tout == None:
                # grab explicit timeout value, if the test specifies it
                tout = t.getTimeout()

            # look for a previous runtime value
            tlen,tresult = cache.getRunTime( t )

            if tlen != None:

                rt = self.statushandler.getRuntime( t, None )
                if rt == None:
                    self.statushandler.setRuntime( t, int(tlen) )

                if tout == None:
                    if tresult == "timeout":
                        tout = self._timeout_if_test_timed_out( tlen )
                    else:
                        tout = self._timeout_from_previous_runtime( tlen )

            elif tout == None:
                tout = self._default_timeout( t )

            tout = self._apply_timeout_options( tout )

            t.setAttr( 'timeout', tout )

        cache = None

    def _timeout_if_test_timed_out(self, runtime):
        ""
        # for tests that timed out, make timeout much larger
        if t.hasKeyword( "long" ):
            # only long tests get timeouts longer than an hour
            if runtime < 60*60:
                tm = 4*60*60
            elif runtime < 5*24*60*60:  # even longs are capped
                tm = 4*runtime
            else:
                tm = 5*24*60*60
        else:
            tm = 60*60

        return tm

    def _timeout_from_previous_runtime(self, runtime):
        ""
        # pick timeout to allow for some runtime variability
        if runtime < 120:
            tm = max( 120, 2*runtime )
        elif runtime < 300:
            tm = max( 300, 1.5*runtime )
        elif runtime < 4*60*60:
            tm = int( float(runtime)*1.5 )
        else:
            tm = int( float(runtime)*1.3 )

        return tm

    def _default_timeout(self, tspec):
        ""
        # with no information, the default depends on 'long' keyword
        if tspec.hasKeyword("long"):
            tm = 5*60*60  # five hours
        else:
            tm = 60*60  # one hour

        return tm

    def _apply_timeout_options(self, timeout):
        ""
        if self.cmdline_timeout != None:
            timeout = int( float(self.cmdline_timeout) )

        if self.tmult != None:
            timeout = int( float(timeout) * self.tmult )

        if self.maxtime != None:
            timeout = min( timeout, float(self.maxtime) )

        return timeout


class Batcher:
    
    def __init__(self, rtdata, opts, optD,
                       plat, tlist, xlist, perms,
                       test_dir, qsublimit):
        """
        The 'tlist' is a TestList class instance.
        """
        self.rtdata = rtdata
        self.opts = opts
        self.optD = optD
        self.plat = plat
        self.tlist = tlist
        self.xlist = xlist
        self.perms = perms

        clean_exit_marker = "queue job finished cleanly"
        statushandler = rtdata.getTestStatusHandler()

        self.accountant = batchutils.BatchAccountant()

        self.namer = batchutils.BatchFileNamer( test_dir, testlist_name )

        self.scheduler = batchutils.BatchScheduler(
                            tlist, xlist,
                            statushandler,
                            self.accountant, self.namer,
                            perms, plat, qsublimit,
                            clean_exit_marker )

        config = self.rtdata.getConfiguration()

        cmd_opts = ''
        if self.opts.dash_e: cmd_opts += ' -e'
        if self.opts.dash_m: cmd_opts += ' -m'
        if self.opts.postclean: cmd_opts += ' -C'
        if self.opts.analyze: cmd_opts += ' -a'
        if self.opts.perms:
            cmd_opts += ' --perms '+','.join( self.opts.perms )
        if config.get('configdir'):
            cmd_opts += ' --config='+config.get('configdir')
        if self.optD['platopt_dict']:
            for k,v in self.optD['platopt_dict'].items():
                if v:
                    cmd_opts += ' --platopt ' + k + '=' + v
                else:
                    cmd_opts += ' --platopt ' + k 
        for arg in config.get('testargs'):
            cmd_opts += ' --test-args="'+arg+'"'

        self.batscriptor = batchutils.BatchScriptWriter(
                                              self.rtdata, self.namer,
                                              self.accountant, self.perms,
                                              self.xlist, self.plat,
                                              cmd_opts,
                                              self.opts.batch_length,
                                              self.opts.max_timeout,
                                              clean_exit_marker )
        self.batscriptor.createTestGroups()

    def getScheduler(self):
        return self.scheduler

    def getAccountant(self):
        return self.accountant

    def writeQsubScripts(self, results_suffix):
        ""
        return self.batscriptor.writeQsubScripts( results_suffix )

    def getIncludeFiles(self):
        ""
        return self.batscriptor.getIncludeFiles()


def restartTests( opts, optD, rtdata ):
    ""
    config = rtdata.getConfiguration()
    plat = rtdata.getPlatformObject()
    test_dir = rtdata.getTestResultsDir()
    statushandler = rtdata.getTestStatusHandler()
    plugin = rtdata.getUserPlugin()

    # this variable allows vvtest tests to run vvtest (ie, allows recursion)
    os.environ['VVTEST_TEST_ROOT'] = test_dir

    qid = opts.qsub_id
    if qid == None:
        tfile = os.path.join( test_dir, testlist_name )
    else:
        # batch jobs have --qsub-id set and land here
        namer = batchutils.BatchFileNamer( test_dir, testlist_name )
        tfile = namer.getTestListName( qid )
        # prevent the run scripts from being written again
        config.set( 'refresh', False )

    tlist = make_TestList( rtdata, tfile )

    tlist.readTestList()
    tlist.readTestResults()
    tlist.ensureInlinedTestResultIncludes()

    check_for_currently_running_vvtest( tlist.getResultsFilenames(), opts.force )

    if qid == None:
        timehandler = rtdata.getTestTimeHandler()
        timehandler.load( tlist )

    reld = rtdata.getFilterPath()

    tlist.determineActiveTests( filter_dir=reld )

    perms = rtdata.getPermissionsObject()

    perms.set( os.path.abspath( tfile ) )

    results_writer = rtdata.getResultsWriter()

    results_writer.prerun( tlist )
    print3()

    if tlist.numActive() > 0:

        xlist = TestExecList( statushandler, plugin, tlist )
        xlist.createTestExecs( test_dir, plat, config, perms )

        if not opts.batch:
            executeTestList( opts, optD, rtdata,
                             tlist, xlist, test_dir, plat, perms, tfile,
                             results_writer )

        else:
            batchTestList( opts, optD, rtdata,
                           tlist, xlist, test_dir, plat, perms,
                           results_writer )

    results_writer.final( tlist )

    return tlist.encodeIntegerWarning()


def baselineTests( opts, optD, rtdata ):
    ""
    rtconfig = rtdata.getRuntimeConfig()
    config = rtdata.getConfiguration()
    plat = rtdata.getPlatformObject()
    test_dir = rtdata.getTestResultsDir()
    statushandler = rtdata.getTestStatusHandler()
    plugin = rtdata.getUserPlugin()

    tfile = os.path.join( test_dir, testlist_name )

    tlist = make_TestList( rtdata, tfile )

    tlist.readTestList()
    tlist.readTestResults()
    tlist.ensureInlinedTestResultIncludes()

    # if the keyword expression does not include a results keyword, then
    # add the 'diff' keyword so that only diffs are rebaselined by default
    rtconfig.addResultsKeywordExpression( 'diff' )

    tlist.determineActiveTests( filter_dir=rtdata.getFilterPath(),
                                baseline=True )

    rtdata.getResultsWriter().prerun( tlist, abbreviate=False )
    print3()

    if tlist.numActive() > 0:

        perms = rtdata.getPermissionsObject()

        xlist = TestExecList( statushandler, plugin, tlist )
        xlist.createTestExecs( test_dir, plat, config, perms )

        failures = False
        for tx in xlist.getTestExecList():

            if isinstance(tx, TestExec.TestExec):
                ref = tx.atest
            else:
                ref = tx

            sys.stdout.write( "baselining "+ref.getExecuteDirectory()+"..." )

            tx.start( baseline=1 )

            tm = int( os.environ.get( 'VVTEST_BASELINE_TIMEOUT', 30 ) )
            for i in range(tm):

                time.sleep(1)

                if tx.poll():
                    if statushandler.passed( tx.atest ):
                        print3( "done" )
                    else:
                        failures = True
                        print3("FAILED")
                    break

            if not tx.isDone():
                tx.killJob()
                failures = True
                print3( "TIMED OUT" )

        if failures:
          print3( "\n\n !!!!!!!!!!!  THERE WERE FAILURES  !!!!!!!!!! \n\n" )


###########################################################################

def getUserName():
    """
    Retrieves the user name associated with this process.
    """
    usr = None
    try:
        import getpass
        usr = getpass.getuser()
    except Exception:
        usr = None
    
    if usr == None:
        try:
            uid = os.getuid()
            import pwd
            usr = pwd.getpwuid( uid )[0]
        except Exception:
            usr = None
    
    if usr == None:
        try:
            p = os.path.expanduser( '~' )
            if p != '~':
                usr = os.path.basename( p )
        except Exception:
            usr = None
    
    if usr == None:
        # try manually checking the environment
        for n in ['USER', 'LOGNAME', 'LNAME', 'USERNAME']:
            if os.environ.get(n,'').strip():
                usr = os.environ[n]
                break

    if usr == None:
        raise Exception( "could not determine this process's user name" )

    return usr


def print3( *args, **kwargs ):
    s = ' '.join( [ str(x) for x in args ] )
    if len(kwargs) > 0:
        s += ' ' + ' '.join( [ str(k)+'='+str(v) for k,v in kwargs.items() ] )
    sys.stdout.write( s + os.linesep )
    sys.stdout.flush()


###########################################################################

def get_tools_directory():
    ""
    d = sys.path[0]
    if not d:                  d = os.getcwd()
    elif not os.path.isabs(d): d = os.path.abspath(d)
    return d


def check_for_bootstrap_file():
    """
    if vvtest_bootstrap.py exists in the same directory as vvtest,
    then import it (which may set os.environ variables)
    """
    try:
        import vvtest_bootstrap

    except ImportError:
        # to allow for vvtest to be a soft link to an installed vvtest area,
        # look for a bootstrap file in the directory containing the soft link
        bindir = os.path.dirname( os.path.abspath( sys.argv[0] ) )
        boot = os.path.join( bindir, 'vvtest_bootstrap.py' )
        if os.path.exists( boot ):
            sys.path.append( bindir )
            import vvtest_bootstrap


def insert_configdir_into_sys_path( rtdata ):
    ""
    d1 = os.path.normpath( os.path.join( rtdata.getToolsDir(), 'config' ) )

    d2 = rtdata.getConfiguration().get( 'configdir' )
    if d2:
        d2 = os.path.normpath( d2 )

        if d1 != d2:
            sys.path.insert( 1, d1 )

        sys.path.insert( 1, d2 )

    else:
        sys.path.insert( 1, d1 )


def make_PermissionSetter( test_dir, optperms ):
    ""
    if optperms:
        from libvvtest.permsetter import PermissionSetter
        perms = PermissionSetter( test_dir, optperms )

    else:
        class DummyPermissionSetter:
            def __init__(self): pass
            def set(self, path): pass
            def recurse(self, path): pass

        perms = DummyPermissionSetter()

    return perms


##############################################################################

if __name__ == '__main__':
    ""
    main = MainEntry( sys.argv )
    main.constructObjects()

    exitstat = main.execute()
    if exitstat:
        sys.exit( exitstat )
