#!/usr/bin/env python
#RUNTEST:
#OPTION: realssh

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import time
import shutil
import subprocess
import re
import traceback
import stat
import getopt
import signal

# this will os.chdir() to a subdirectory
from testutils import *

# the module being tested
import command
from command import Command

# For the tests that use ssh, a "fake" ssh script is used that acts like ssh.
# To use an actual ssh, add the -s option to the unit test command line.  In
# this case, make sure you can ssh to the current machine without a password.
use_real_ssh = False

localpy = sys.executable


def main():

    optL,argL = getopt.getopt( sys.argv[1:], 's' )

    if ('-s','') in optL:
        global use_real_ssh
        use_real_ssh = True

    if len(argL) == 0:
        argL = """expand01 expand02 expand03 expand04
                  args01 args02
                  cmd01 cmd02 cmd03 cmd04 cmd05 cmd06
                  repr01
                  frame01 frame02
                  vars01 vars02
                  redirect01 redirect02 redirect03 redirect04 redirect05
                  redirect06
                  echo01 echo02 echo03 echo04
                  dirswap01
                  makecmd01 makecmd02 makecmd03 makecmd04
                  dry01
                  run01 run02 run03 run04 run05 run06
                  runout01 runout02 runout03 runout04
                  timeout01 timeout02 timeout03 timeout04 timeout05
               """.split()

    savedir = os.getcwd()
    for func in argL:
        os.chdir( savedir )
        rmallfiles()
        if 'COMMAND_DRYRUN' in os.environ:
            del os.environ['COMMAND_DRYRUN']
        time.sleep(1)
        print3( '====> ', func )
        eval( func+'()' )


######################################################################

def expand01():
    """
    single variable substitution
    """
    vx = command.VariableExpander()

    s = vx.expand( 'nothing', {} )
    assert s == 'nothing'
    s = vx.expand( 'nothing', {'var':'val'} )
    assert s == 'nothing'

    s = vx.expand( '$vname', {} )
    assert s == '$vname'
    s = vx.expand( '$vname', {'vname':'value'} )
    assert s == 'value'

    s = vx.expand( '${vname}', {} )
    assert s == '${vname}'
    s = vx.expand( '${vname}', {'vname':'value'} )
    assert s == 'value'

    s = vx.expand( ' $vname', {'foo':'bar'} )
    assert s == ' $vname'
    s = vx.expand( ' $vname', {'vname':'value'} )
    assert s == ' value'

    s = vx.expand( ' ${vname}', {'foo':'bar'} )
    assert s == ' ${vname}'
    s = vx.expand( ' ${vname}', {'vname':'value'} )
    assert s == ' value'

    s = vx.expand( '$vname ', {'foo':'bar'} )
    assert s == '$vname '
    s = vx.expand( '$vname ', {'vname':'value'} )
    assert s == 'value '

    s = vx.expand( '${vname} ', {'foo':'bar'} )
    assert s == '${vname} '
    s = vx.expand( '${vname} ', {'vname':'value'} )
    assert s == 'value '

    s = vx.expand( ' $vname ', {'foo':'bar'} )
    assert s == ' $vname '
    s = vx.expand( ' $vname ', {'vname':'value'} )
    assert s == ' value '

    s = vx.expand( ' ${vname} ', {'foo':'bar'} )
    assert s == ' ${vname} '
    s = vx.expand( ' ${vname} ', {'vname':'value'} )
    assert s == ' value '


def expand02():
    """
    escape dollar
    """
    vx = command.VariableExpander()

    s = vx.expand( r' \${vname} ', {'foo':'bar'} )
    assert s == r' ${vname} '
    s = vx.expand( r' \$vname ', {'foo':'bar'} )
    assert s == r' $vname '

    s = vx.expand( r' \${vname} ', {'vname':'value'} )
    assert s == r' ${vname} '
    s = vx.expand( r' \$vname ', {'vname':'value'} )
    assert s == r' $vname '

    s = vx.expand( r' \${vname}$foo ', {'vname':'value','foo':'bar'} )
    assert s == r' ${vname}bar '
    s = vx.expand( r' \$vname${foo} ', {'vname':'value','foo':'bar'} )
    assert s == r' $vnamebar '


def expand03():
    """
    two variable substitutions
    """
    vx = command.VariableExpander()

    s = vx.expand( '$var1$var2', {'foo':'bar'} )
    assert s == '$var1$var2'
    s = vx.expand( '${var1}${var2}', {'foo':'bar'} )
    assert s == '${var1}${var2}'

    s = vx.expand( '$var1$var2', {'var1':'bar'} )
    assert s == 'bar$var2'
    s = vx.expand( '${var1}${var2}', {'var1':'bar'} )
    assert s == 'bar${var2}'

    s = vx.expand( '$var1$var2', {'var2':'bar'} )
    assert s == '$var1bar'
    s = vx.expand( '${var1}${var2}', {'var2':'bar'} )
    assert s == '${var1}bar'

    s = vx.expand( '$var1$var2', {'var2':'bar', 'var1':'foo'} )
    assert s == 'foobar'
    s = vx.expand( '${var1}${var2}', {'var2':'bar', 'var1':'foo'} )
    assert s == 'foobar'

    s = vx.expand( '$var1${var2}', {'var2':'bar', 'var1':'foo'} )
    assert s == 'foobar'
    s = vx.expand( '${var1}$var2', {'var2':'bar', 'var1':'foo'} )
    assert s == 'foobar'

    s = vx.expand( '$var1 ${var2}', {'var2':'bar', 'var1':'foo'} )
    assert s == 'foo bar'
    s = vx.expand( '${var1} $var2', {'var2':'bar', 'var1':'foo'} )
    assert s == 'foo bar'

    s = vx.expand( '$var1$blah${var2}', {'var2':'bar', 'var1':'foo'} )
    assert s == 'foo$blahbar'
    s = vx.expand( '${var1}$blah$var2', {'var2':'bar', 'var1':'foo'} )
    assert s == 'foo$blahbar'

    D = { 'foo':'bar', 'ext':'txt' }
    s = vx.expand( '${foo}bar$nope.$ext', D )
    assert s == 'barbar$nope.txt'


def expand04():
    """
    same variable substitution twice
    """
    vx = command.VariableExpander()

    s = vx.expand( '$var1$var1', {'var1':'valA'} )
    assert s == 'valAvalA'
    s = vx.expand( '${var1}${var1}', {'var1':'valA'} )
    assert s == 'valAvalA'

    s = vx.expand( '$var1$var2$var1', {'var1':'valA'} )
    assert s == 'valA$var2valA'
    s = vx.expand( '${var1}${var2}${var1}', {'var1':'valA'} )
    assert s == 'valA${var2}valA'

    s = vx.expand( '$var1$var2$var1', {'var1':'valA', 'var2':'valB'} )
    assert s == 'valAvalBvalA'
    s = vx.expand( '${var1}${var2}${var1}', {'var1':'valA', 'var2':'valB'} )
    assert s == 'valAvalBvalA'


def args01():
    """
    the EscapedArgument class

    Note that this test is somewhat fragile because it relies on the output
    from pipes.quote(), which can vary a little over python versions.
    """
    cmd = command.EscapedArgument( 'hello' )
    assert cmd.getArgument() == 'hello'
    assert cmd.shellStringForExpansion() == 'hello'
    assert cmd.shellStringWithoutExpansion() == 'hello'

    cmd = command.EscapedArgument( 'hello world' )
    assert cmd.getArgument() == "'hello world'"
    assert cmd.shellStringForExpansion() == "'hello world'"
    assert cmd.shellStringWithoutExpansion() == "'hello world'"

    cmd = command.EscapedArgument( 'hello$world' )
    assert cmd.getArgument() == "'hello$world'"
    assert cmd.shellStringForExpansion() == "'hello$world'"
    assert cmd.shellStringWithoutExpansion() == "'hello$world'"

    cmd = command.EscapedArgument( '~/dirname/file.*' )
    assert cmd.getArgument() == "'~/dirname/file.*'"
    assert cmd.shellStringForExpansion() == "'~/dirname/file.*'"
    assert cmd.shellStringWithoutExpansion() == "'~/dirname/file.*'"

    # test the repr() function
    from command import EscapedArgument
    cmd = command.EscapedArgument( 'hello' )
    s = repr(cmd)
    cmd2 = eval( s )
    assert cmd.getArgument() == cmd2.getArgument()


def args02():
    """
    the SingleArgument class
    """
    cmd = command.SingleArgument( 'hello' )
    assert cmd.getArgument() == 'hello'
    assert cmd.shellStringForExpansion() == 'hello'
    assert cmd.shellStringWithoutExpansion() == 'hello'

    cmd = command.SingleArgument( 'hello world' )
    assert cmd.getArgument() == 'hello world'
    assert cmd.shellStringForExpansion() == 'hello\\ world'
    assert cmd.shellStringWithoutExpansion() == "'hello world'"

    cmd = command.SingleArgument( '"hello world"' )
    assert cmd.getArgument() == '"hello world"'
    assert cmd.shellStringForExpansion() == '\\"hello\\ world\\"'
    assert cmd.shellStringWithoutExpansion() == '\'"hello world"\''

    cmd = command.SingleArgument( '~/dir/""' )
    assert cmd.getArgument() == '~/dir/""'
    assert cmd.shellStringForExpansion() == '~/dir/\\"\\"'
    assert cmd.shellStringWithoutExpansion() == '\'~/dir/""\''

    # test the repr() function
    from command import SingleArgument
    cmd = command.SingleArgument( 'hello' )
    s = repr(cmd)
    cmd2 = eval( s )
    assert cmd.getArgument() == cmd2.getArgument()


def cmd01():
    """
    using add()
    """
    cmd = Command()
    cmd.add( 'ls' )
    assert cmd.asShellString( shell=False ) == 'ls'
    assert cmd.asShellString() == 'ls'

    cmd = Command()
    cmd.add( 'echo hello' )
    assert cmd.asShellString( shell=False ) == 'echo hello'
    assert cmd.asShellString() == 'echo hello'

    cmd = Command()
    cmd.add( 'echo "hello world"' )
    assert cmd.asShellString( shell=False ) == "echo 'hello world'"
    assert cmd.asShellString() == "echo hello\\ world"

    cmd = Command()
    cmd.add( 'ls ~/bin/junk1 /usr/local/bin/junk2' )
    assert cmd.asShellString( shell=False ) == \
            "ls '~/bin/junk1' /usr/local/bin/junk2"
    assert cmd.asShellString() == "ls ~/bin/junk1 /usr/local/bin/junk2"

    cmd = Command()
    cmd.add( 'echo' ).add( '~/bin/junk1', '/usr/local/bin/junk2' )
    assert cmd.asShellString( shell=False ) == \
            "echo '~/bin/junk1' /usr/local/bin/junk2"
    assert cmd.asShellString() == "echo ~/bin/junk1 /usr/local/bin/junk2"

    cmd = Command()
    cmd.add( 'echo' ).add( '~/bin/junk1' ).add( '/usr/local/bin/junk2' )
    assert cmd.asShellString( shell=False ) == \
            "echo '~/bin/junk1' /usr/local/bin/junk2"
    assert cmd.asShellString() == "echo ~/bin/junk1 /usr/local/bin/junk2"


def cmd02():
    """
    giving Command() constructor arguments
    """
    cmd = Command( 'ls' )
    assert cmd.asShellString( shell=False ) == 'ls'
    assert cmd.asShellString() == 'ls'

    cmd = Command( 'echo hello' )
    assert cmd.asShellString( shell=False ) == 'echo hello'
    assert cmd.asShellString() == 'echo hello'

    cmd = Command( 'echo "hello world"' )
    assert cmd.asShellString( shell=False ) == "echo 'hello world'"
    assert cmd.asShellString() == "echo hello\\ world"

    cmd = Command( 'echo ~/bin/junk1 /usr/local/bin/junk2' )
    assert cmd.asShellString( shell=False ) == \
            "echo '~/bin/junk1' /usr/local/bin/junk2"
    assert cmd.asShellString() == "echo ~/bin/junk1 /usr/local/bin/junk2"

    cmd = Command( 'echo' )
    cmd.add( '~/bin/junk1', '/usr/local/bin/junk2' )
    assert cmd.asShellString( shell=False ) == \
            "echo '~/bin/junk1' /usr/local/bin/junk2"
    assert cmd.asShellString() == "echo ~/bin/junk1 /usr/local/bin/junk2"

    cmd = Command( 'echo' )
    cmd.add( '~/bin/junk1' ).add( '/usr/local/bin/junk2' )
    assert cmd.asShellString( shell=False ) == \
            "echo '~/bin/junk1' /usr/local/bin/junk2"
    assert cmd.asShellString() == "echo ~/bin/junk1 /usr/local/bin/junk2"


def cmd03():
    """
    using arg()
    """
    cmd = Command().arg( 'ls' )
    assert cmd.asShellString( shell=False ) == 'ls'
    assert cmd.asShellString() == 'ls'

    cmd = Command().arg( 'ls', 'file1', 'file2' )
    assert cmd.asShellString( shell=False ) == 'ls file1 file2'
    assert cmd.asShellString() == 'ls file1 file2'

    cmd = Command().arg( 'ls', 'file name' )
    assert cmd.asShellString( shell=False ) == "ls 'file name'"
    assert cmd.asShellString() == 'ls file\\ name'

    cmd = Command().arg( 'ls' ).arg( 'file name' )
    assert cmd.asShellString( shell=False ) == "ls 'file name'"
    assert cmd.asShellString() == 'ls file\\ name'

    cmd = Command( 'ls' )
    cmd.add( '~/bin/file name' ).arg( '/usr/local/bin/file name' )
    assert cmd.asShellString( shell=False ) == \
            "ls '~/bin/file' name '/usr/local/bin/file name'"
    assert cmd.asShellString() == \
            "ls ~/bin/file name /usr/local/bin/file\\ name"


def cmd04():
    """
    using raw()
    """
    cmd = Command().raw( 'ls' )
    assert cmd.asShellString( shell=False ) == 'ls'
    assert cmd.asShellString() == 'ls'

    cmd = Command().raw( 'ls', 'file1', 'file2' )
    assert cmd.asShellString( shell=False ) == 'ls file1 file2'
    assert cmd.asShellString() == 'ls file1 file2'

    cmd = Command().raw( 'ls', 'file1 file2' )
    assert cmd.asShellString( shell=False ) == "ls 'file1 file2'"
    assert cmd.asShellString() == 'ls file1\\ file2'

    cmd = Command().raw( 'ls' ).raw( 'file1 file2' )
    assert cmd.asShellString( shell=False ) == "ls 'file1 file2'"
    assert cmd.asShellString() == 'ls file1\\ file2'

    cmd = Command( 'ls' )
    cmd.add( '~/bin/file name'
        ).arg( '/usr/local/bin/file name'
        ).raw( './file name' )
    assert cmd.asShellString( shell=False ) == \
            "ls '~/bin/file' name '/usr/local/bin/file name' './file name'"
    assert cmd.asShellString() == \
            "ls ~/bin/file name /usr/local/bin/file\\ name ./file\\ name"


def cmd05():
    """
    using escape()
    """
    cmd = Command().escape( 'ls' )
    assert cmd.asShellString( shell=False ) == 'ls'
    assert cmd.asShellString() == 'ls'

    cmd = Command().escape( 'ls', '*' )
    assert cmd.asShellString( shell=False ) == "ls '*'"
    assert cmd.asShellString() == "ls '*'"

    cmd = Command().escape( 'ls' ).escape( '*' )
    assert cmd.asShellString( shell=False ) == "ls '*'"
    assert cmd.asShellString() == "ls '*'"

    cmd = Command().escape( 'ls' ).escape( '*' ).escape( 'filename' )
    assert cmd.asShellString( shell=False ) == "ls '*' filename"
    assert cmd.asShellString() == "ls '*' filename"

    cmd = Command( 'ls' ).raw( '*' ).escape( '*' ).arg( '*' ).add( '*' )
    assert cmd.asShellString( shell=False ) == "ls '*' '*' '*' '*'"
    assert cmd.asShellString() == "ls * '*' * *"


def cmd06():
    """
    giving a Command() instance as an argument
    """
    cmd1 = Command( 'ls -ltr' )
    cmd2 = Command( cmd1, 'filename' )
    assert cmd1.asShellString( shell=False ) == 'ls -ltr'
    assert cmd1.asShellString() == 'ls -ltr'
    assert cmd2.asShellString( shell=False ) == 'ls -ltr filename'
    assert cmd2.asShellString() == 'ls -ltr filename'

    cmd1 = Command( 'ls -ltr' )
    cmd2 = Command().add( cmd1, 'filename' )
    assert cmd1.asShellString( shell=False ) == 'ls -ltr'
    assert cmd1.asShellString() == 'ls -ltr'
    assert cmd2.asShellString( shell=False ) == 'ls -ltr filename'
    assert cmd2.asShellString() == 'ls -ltr filename'

    cmd1 = Command( 'ls -ltr' )
    cmd2 = Command().arg( cmd1, 'filename' )
    assert cmd1.asShellString( shell=False ) == 'ls -ltr'
    assert cmd1.asShellString() == 'ls -ltr'
    assert cmd2.asShellString( shell=False ) == 'ls -ltr filename'
    assert cmd2.asShellString() == 'ls -ltr filename'

    cmd1 = Command( 'ls -ltr' )
    cmd2 = Command().raw( cmd1, 'filename' )
    assert cmd1.asShellString( shell=False ) == 'ls -ltr'
    assert cmd1.asShellString() == 'ls -ltr'
    assert cmd2.asShellString( shell=False ) == 'ls -ltr filename'
    assert cmd2.asShellString() == 'ls -ltr filename'

    cmd1 = Command( 'ls -ltr' )
    cmd2 = Command().escape( cmd1, 'filename' )
    assert cmd1.asShellString( shell=False ) == 'ls -ltr'
    assert cmd1.asShellString() == 'ls -ltr'
    assert cmd2.asShellString( shell=False ) == 'ls -ltr filename'
    assert cmd2.asShellString() == 'ls -ltr filename'

    cmd1 = Command( '-ltr' )
    cmd2 = Command( 'ls', cmd1, 'filename' )
    assert cmd1.asShellString( shell=False ) == '-ltr'
    assert cmd1.asShellString() == '-ltr'
    assert cmd2.asShellString( shell=False ) == 'ls -ltr filename'
    assert cmd2.asShellString() == 'ls -ltr filename'

    cmd1 = Command( '-ltr' )
    cmd2 = Command().add( 'ls', cmd1, 'filename' )
    assert cmd1.asShellString( shell=False ) == '-ltr'
    assert cmd1.asShellString() == '-ltr'
    assert cmd2.asShellString( shell=False ) == 'ls -ltr filename'
    assert cmd2.asShellString() == 'ls -ltr filename'

    cmd1 = Command( '-ltr' )
    cmd2 = Command().arg( 'ls', cmd1, 'filename' )
    assert cmd1.asShellString( shell=False ) == '-ltr'
    assert cmd1.asShellString() == '-ltr'
    assert cmd2.asShellString( shell=False ) == 'ls -ltr filename'
    assert cmd2.asShellString() == 'ls -ltr filename'

    cmd1 = Command( '-ltr' )
    cmd2 = Command().raw( 'ls', cmd1, 'filename' )
    assert cmd1.asShellString( shell=False ) == '-ltr'
    assert cmd1.asShellString() == '-ltr'
    assert cmd2.asShellString( shell=False ) == 'ls -ltr filename'
    assert cmd2.asShellString() == 'ls -ltr filename'

    cmd1 = Command( '-ltr' )
    cmd2 = Command().escape( 'ls', cmd1, 'filename' )
    assert cmd1.asShellString( shell=False ) == '-ltr'
    assert cmd1.asShellString() == '-ltr'
    assert cmd2.asShellString( shell=False ) == 'ls -ltr filename'
    assert cmd2.asShellString() == 'ls -ltr filename'


def repr01():
    """
    convert a Command to and from a string using repr()
    """
    cmd1 = Command( 'ls -ltr' )
    s = repr( cmd1 )
    cmd2 = command.make_Command_from_repr(s)
    assert cmd1.asShellString() == cmd2.asShellString()
    assert cmd1.asShellString( shell=False ) == \
           cmd2.asShellString( shell=False )


frameglobal = 'some value'

def frame01():
    """
    check the function that gets calling function local variables
    """
    localvar = 1
    lD,gD = command.get_calling_frame_variables( 1 )
    assert 'localvar' in lD and lD['localvar'] == 1
    assert 'frameglobal' in gD and gD['frameglobal'] == 'some value'

    cls = SomeClass()
    cls.somefunc2( 'first', 'second' )

class SomeClass:
    def somefunc2(self, arg0, arg1 ):
        func2var = 2.2
        samevar = 'what?'
        somefunc1( 'zero' )

def somefunc1( argzero ):
    func1var = 1.1
    samevar = 'huh?'

    lD,gD = command.get_calling_frame_variables( 1 )
    assert 'argzero' in lD and lD['argzero'] == 'zero'
    assert 'func1var' in lD and lD['func1var'] == 1.1
    assert 'samevar' in lD and lD['samevar'] == 'huh?'
    assert 'frameglobal' in gD and gD['frameglobal'] == 'some value'
    
    lD,gD = command.get_calling_frame_variables( 2 )
    assert 'arg0' in lD and lD['arg0'] == 'first'
    assert 'arg1' in lD and lD['arg1'] == 'second'
    assert 'func2var' in lD and lD['func2var'] == 2.2
    assert 'samevar' in lD and lD['samevar'] == 'what?'
    assert 'self' in lD
    assert 'frameglobal' in gD and gD['frameglobal'] == 'some value'
    
    lD,gD = command.get_calling_frame_variables( 3 )
    assert 'cls' in lD and hasattr( lD['cls'], 'somefunc2' )
    assert 'localvar' in lD and lD['localvar'] == 1


def frame02():
    """
    calling frame error
    """
    try:
        lD,gD = command.get_calling_frame_variables( 0 )
    except: pass
    else: raise Exception( "expected an exception" )

    try:
        lD,gD = command.get_calling_frame_variables( -1 )
    except: pass
    else: raise Exception( "expected an exception" )

globalvar = 'glob/value'

def vars01():
    """
    substituting local and global variable values
    """
    localvar = 'loc/value'

    cmd = Command( 'ls $globalvar $localvar' )
    assert cmd.asShellString( shell=False ) == 'ls glob/value loc/value'

    cmd = Command().add( 'ls $globalvar', '$localvar' )
    assert cmd.asShellString( shell=False ) == 'ls glob/value loc/value'

    cmd = Command().arg( 'ls', '$globalvar $localvar' )
    assert cmd.asShellString( shell=False ) == "ls 'glob/value loc/value'"

    cmd = Command().raw( 'ls', '$globalvar $localvar' )
    assert cmd.asShellString( shell=False ) == "ls '$globalvar $localvar'"

    cmd = Command().escape( 'ls', '$globalvar $localvar' )
    assert cmd.asShellString( shell=False ) == "ls '$globalvar $localvar'"


def vars02():
    """
    substituting environment variables
    """
    cmd = Command( 'hello $SHELL' )
    assert cmd.asShellString(shell=True) == 'hello '+os.environ['SHELL']

    cmd = Command().arg( 'hello', '$SHELL' )
    assert cmd.asShellString(shell=True) == 'hello '+os.environ['SHELL']

    cmd = Command().raw( 'hello', '$SHELL' )
    assert cmd.asShellString(shell=True) == 'hello $SHELL'

    cmd = Command().escape( 'hello', '$SHELL' )
    assert cmd.asShellString(shell=True) == "hello '$SHELL'"

    os.environ['UNIT_TEST_VAR'] = 'unit test value'

    # whitespace expansion should happen after variable substitution
    cmd = Command( 'hello $UNIT_TEST_VAR' )
    assert cmd.asShellString(shell=True) == 'hello unit test value'

    cmd = Command().arg( 'hello', '$UNIT_TEST_VAR' )
    assert cmd.asShellString(shell=True) == 'hello unit\\ test\\ value'


def redirect01():
    """
    no redirection
    """
    streams = command.SubprocessStreams( None, None, None )
    fd = streams.openStdout()
    assert fd == None
    fd = streams.openStderr()
    assert fd == None
    streams.close()  # check no exception occurs


def redirect02():
    """
    redirect to a filename
    """
    obj = command.RedirectToFilename( 'file.log' )
    fd = obj.open()
    os.write( fd, _BYTES_('hello world\n') )
    obj.close()
    time.sleep(1)
    assert readfile('file.log') == 'hello world\n'

    obj = command.RedirectToFilename( '>>file.log' )
    fd = obj.open()
    os.write( fd, _BYTES_('goodbye now\n') )
    obj.close()
    time.sleep(1)
    assert readfile('file.log') == 'hello world\ngoodbye now\n'

    obj = command.RedirectToFilename( 'file.log' )
    fd = obj.open()
    os.write( fd, _BYTES_('this data rules\n') )
    obj.close()
    time.sleep(1)
    assert readfile('file.log') == 'this data rules\n'

    try:
        obj = command.RedirectToFilename( '>>' )
    except: pass
    else: raise Exception( 'expected an exception' )


def redirect03():
    """
    redirect to an open file descriptor
    """
    fp = open( 'file.log', 'w' )
    fp.write( 'hello world\n' )
    fp.flush()
    obj = command.RedirectToFileDescriptor( fp.fileno() )
    fd = obj.open()
    assert fd == fp.fileno()
    os.write( fd, _BYTES_('goodbye now\n') )
    obj.close()
    fp.write( 'no, really\n' )
    fp.close()
    time.sleep(1)

    data = readfile( 'file.log' )
    assert data == 'hello world\ngoodbye now\nno, really\n'


def redirect04():
    """
    SubprocessStreams: specify one of 'redirect' or stdout or stderr
    """
    streams = command.SubprocessStreams( 'file1.txt', None, None )
    ofd = streams.openStdout()
    efd = streams.openStderr()
    os.write( ofd, _BYTES_('to stdout\n') )
    assert efd == subprocess.STDOUT
    streams.close()
    time.sleep(1)
    assert readfile('file1.txt') == 'to stdout\n'

    streams = command.SubprocessStreams( None, 'file2.txt', None )
    ofd = streams.openStdout()
    efd = streams.openStderr()
    os.write( ofd, _BYTES_('to stdout\n') )
    assert efd == None
    streams.close()
    time.sleep(1)
    assert readfile('file2.txt') == 'to stdout\n'

    streams = command.SubprocessStreams( None, None, 'file3.txt' )
    ofd = streams.openStdout()
    efd = streams.openStderr()
    assert ofd == None
    os.write( efd, _BYTES_('to stderr\n') )
    streams.close()
    time.sleep(1)
    assert readfile('file3.txt') == 'to stderr\n'


def redirect05():
    """
    SubprocessStreams: specify stdout and stderr
    """
    streams = command.SubprocessStreams( None, 'file1.txt', 'file2.txt' )
    ofd = streams.openStdout()
    efd = streams.openStderr()
    os.write( ofd, _BYTES_('to stdout\n') )
    os.write( efd, _BYTES_('to stderr\n') )
    streams.close()
    time.sleep(1)
    assert readfile('file1.txt') == 'to stdout\n'
    assert readfile('file2.txt') == 'to stderr\n'

    fp = open( 'file4.txt', 'w' )
    streams = command.SubprocessStreams( None, 'file3.txt', fp.fileno() )
    ofd = streams.openStdout()
    efd = streams.openStderr()
    os.write( ofd, _BYTES_('to stdout\n') )
    os.write( efd, _BYTES_('to stderr\n') )
    streams.close()
    fp.close()
    time.sleep(1)
    assert readfile('file3.txt') == 'to stdout\n'
    assert readfile('file4.txt') == 'to stderr\n'

    fp = open( 'file5.txt', 'w' )
    streams = command.SubprocessStreams( None, fp.fileno(), 'file6.txt' )
    ofd = streams.openStdout()
    efd = streams.openStderr()
    os.write( ofd, _BYTES_('to stdout\n') )
    os.write( efd, _BYTES_('to stderr\n') )
    streams.close()
    fp.close()
    time.sleep(1)
    assert readfile('file5.txt') == 'to stdout\n'
    assert readfile('file6.txt') == 'to stderr\n'


def redirect06():
    """
    SubprocessStreams: specify 'redirect' and stdout/stderr
    """
    fp = open( 'file.txt', 'w' )
    streams = command.SubprocessStreams( fp.fileno(), None, None )
    ofd = streams.openStdout()
    efd = streams.openStderr()
    os.write( ofd, _BYTES_('to stdout\n') )
    assert efd == subprocess.STDOUT
    streams.close()
    fp.close()
    time.sleep(1)
    assert readfile('file.txt') == 'to stdout\n'

    fp1 = open( 'file1.txt', 'w' )
    fp2 = open( 'file2.txt', 'w' )
    streams = command.SubprocessStreams( fp1.fileno(), None, fp2.fileno() )
    ofd = streams.openStdout()
    efd = streams.openStderr()
    os.write( ofd, _BYTES_('to stdout\n') )
    os.write( efd, _BYTES_('to stderr\n') )
    streams.close()
    fp1.close()
    fp2.close()
    time.sleep(1)
    assert readfile('file1.txt') == 'to stdout\n'
    assert readfile('file2.txt') == 'to stderr\n'

    streams = command.SubprocessStreams( 'file4.txt', 'file3.txt', None )
    ofd = streams.openStdout()
    efd = streams.openStderr()
    os.write( ofd, _BYTES_('to stdout\n') )
    assert efd == subprocess.STDOUT
    streams.close()
    time.sleep(1)
    assert readfile('file3.txt') == 'to stdout\n'
    assert not os.path.exists( 'file4.txt' )

    streams = command.SubprocessStreams( 'file5.txt', None, 'file6.txt' )
    ofd = streams.openStdout()
    efd = streams.openStderr()
    os.write( ofd, _BYTES_('to stdout\n') )
    os.write( efd, _BYTES_('to stderr\n') )
    streams.close()
    time.sleep(1)
    assert readfile('file5.txt') == 'to stdout\n'
    assert readfile('file6.txt') == 'to stderr\n'


def echo01():
    """
    command echoing: CommanNoEcho
    """
    redir = RedirectStdout('stdout.log')
    try:
        echo = command.CommandNoEcho()
        echo.preExecute()
        echo.postExecute( 1 )
    finally:
        redir.close()
    time.sleep(1)
    s = readfile('stdout.log').strip()
    assert not s.strip()


def echo02():
    """
    command echoing: CommandEcho
    """
    redir = RedirectStdout('stdout.log')
    try:
        echo = command.CommandEcho( 'my command' )
        echo.preExecute()
        echo.postExecute( 1 )
    finally:
        redir.close()
    time.sleep(1)
    assert readfile('stdout.log') == 'my command\n'

    # command must be a string
    try:
        echo = command.CommandEcho( ['my','command'] )
        echo.preExecute()
        echo.postExecute( 1 )
    except:
        pass
    else:
        raise Exception( "expected an exception" )


def echo03():
    """
    command echoing: CommandLogging
    """
    redir = RedirectStdout('stdout.log')
    try:
        echo = command.CommandLogging( 'my command', None, None )
        echo.preExecute()
        echo.postExecute( 1 )
    finally:
        redir.close()
    time.sleep(1)
    fp = open( 'stdout.log', 'r' )
    lines = extract_log_lines(fp)
    fp.close()
    assert len(lines) == 2

    # check first log line
    assert lines[0][1] == 'runcmd'
    L = lines[0][2]
    assert 'dir='+os.getcwd() in L
    assert 'cmd=my command' in L
    sL = list( filter( lambda s: s.startswith('start='), L ) )
    assert len(sL) == 1
    startid = sL[0]

    # check second log line
    assert lines[1][1] == 'return'
    L = lines[1][2]
    assert startid in L
    assert 'exit=1' in L
    assert 'cmd=my command' in L

    # add in a chdir argument

    os.mkdir( 'tmpdir' )
    time.sleep(1)

    redir = RedirectStdout('stdout.log')
    try:
        saved = os.getcwd()
        os.chdir( 'tmpdir' )
        echo = command.CommandLogging( 'my command', None, None )
        echo.preExecute()
        echo.postExecute( None )
    finally:
        redir.close()
        os.chdir( saved )
    time.sleep(1)
    fp = open( 'stdout.log', 'r' )
    lines = extract_log_lines(fp)
    fp.close()
    assert len(lines) == 2

    # check first log line
    assert lines[0][1] == 'runcmd'
    L = lines[0][2]
    assert 'dir='+os.path.abspath('tmpdir') in L
    assert 'cmd=my command' in L
    sL = list( filter( lambda s: s.startswith('start='), L ) )
    assert len(sL) == 1
    startid = sL[0]

    # check second log line
    assert lines[1][1] == 'return'
    L = lines[1][2]
    assert startid in L
    assert 'exit=None' in L
    assert 'cmd=my command' in L

    # add in a logfile argument

    redir = RedirectStdout('stdout.log')
    try:
        echo = command.CommandLogging( 'my command', 'logname', None )
        echo.preExecute()
        echo.postExecute( None )
    finally:
        redir.close()
    time.sleep(1)
    fp = open( 'stdout.log', 'r' )
    lines = extract_log_lines(fp)
    fp.close()
    assert len(lines) == 2

    # check first log line
    assert lines[0][1] == 'runcmd'
    L = lines[0][2]
    assert 'dir='+os.getcwd() in L
    assert 'cmd=my command' in L
    assert 'logfile=logname' in L
    sL = list( filter( lambda s: s.startswith('start='), L ) )
    assert len(sL) == 1
    startid = sL[0]

    # check second log line
    assert lines[1][1] == 'return'
    L = lines[1][2]
    assert startid in L
    assert 'exit=None' in L
    assert 'cmd=my command' in L

    # absolute path logfile argument

    abslogf = os.path.abspath('logname')
    redir = RedirectStdout('stdout.log')
    try:
        echo = command.CommandLogging( 'my command', abslogf, None )
        echo.preExecute()
        echo.postExecute( None )
    finally:
        redir.close()
    time.sleep(1)
    fp = open( 'stdout.log', 'r' )
    lines = extract_log_lines(fp)
    fp.close()
    assert len(lines) == 2

    # check first log line
    assert lines[0][1] == 'runcmd'
    L = lines[0][2]
    assert 'dir='+os.getcwd() in L
    assert 'cmd=my command' in L
    assert 'logfile='+abslogf in L
    sL = list( filter( lambda s: s.startswith('start='), L ) )
    assert len(sL) == 1
    startid = sL[0]

    # check second log line
    assert lines[1][1] == 'return'
    L = lines[1][2]
    assert startid in L
    assert 'exit=None' in L
    assert 'cmd=my command' in L

    # adding a timeout

    redir = RedirectStdout('stdout.log')
    try:
        echo = command.CommandLogging( 'my command', None, None )
        echo.preExecute()
        echo.postExecute( 1 )
    finally:
        redir.close()
    time.sleep(1)
    fp = open( 'stdout.log', 'r' )
    lines = extract_log_lines(fp)
    fp.close()
    assert len(lines) == 2
    L = list( filter( lambda x: str(x).startswith('timeout='), lines[0][2] ) )
    assert len(L) == 0
    L = list( filter( lambda x: str(x).startswith('timeout='), lines[1][2] ) )
    assert len(L) == 0

    redir = RedirectStdout('stdout.log')
    try:
        echo = command.CommandLogging( 'my command', None, 1.2 )
        echo.preExecute()
        echo.postExecute( 1 )
    finally:
        redir.close()
    time.sleep(1)
    fp = open( 'stdout.log', 'r' )
    lines = extract_log_lines(fp)
    fp.close()
    assert len(lines) == 2
    L = list( filter( lambda x: str(x).startswith('timeout='), lines[0][2] ) )
    assert len(L) == 1
    assert L[0].startswith('timeout=1.2')
    L = list( filter( lambda x: str(x).startswith('timeout='), lines[1][2] ) )
    assert len(L) == 0


def echo04():
    """
    command echoing: construct_echo_object
    """
    obj = command.construct_echo_object( 'echo', 'shell command', None )
    assert isinstance( obj, command.CommandEcho )

    obj = command.construct_echo_object( 'log', 'shell command', None )
    assert isinstance( obj, command.CommandLogging )

    obj = command.construct_echo_object( 'log', 'shell command', 1.2 )
    assert isinstance( obj, command.CommandLogging )

    obj = command.construct_echo_object( 'none', 'shell command', None )
    assert isinstance( obj, command.CommandNoEcho )

    obj = command.construct_echo_object( None, 'shell command', None )
    assert isinstance( obj, command.CommandNoEcho )


def dirswap01():
    """
    the ChangeDirectory class
    """
    d = os.getcwd()
    cd = command.ChangeDirectory( None )
    assert os.getcwd() == d
    cd.changeToOriginal()
    assert os.getcwd() == d

    d = os.getcwd()
    # an empty string behaves same as None
    cd = command.ChangeDirectory( '' )
    assert os.getcwd() == d
    cd.changeToOriginal()
    assert os.getcwd() == d

    os.mkdir( 'tmpdir' )
    time.sleep(1)

    d = os.getcwd()
    newdir = os.path.abspath( 'tmpdir' )
    cd = command.ChangeDirectory( 'tmpdir' )
    assert os.getcwd() == newdir
    cd.changeToOriginal()
    assert os.getcwd() == d

    # change to bad directory raises an Exception
    d = os.getcwd()
    try:
        cd = command.ChangeDirectory( 'existentialcrisis' )
    except:
        pass
    else:
        raise Exception( 'expected an exception' )
    assert os.getcwd() == d


def makecmd01():
    """
    getCommands(): no shell expansion
    """
    cmd = Command( sys.executable, 'args1' )
    py,sh = cmd.getCommands( False )
    check_commands( py, sh, 'args1' )

    cmd = Command( sys.executable, 'args2', '-s', 'foo' )
    py,sh = cmd.getCommands( False )
    check_commands( py, sh, 'args2', '-s', 'foo' )

    cmd = Command( sys.executable, 'args3', '~', '*' )
    py,sh = cmd.getCommands( False )
    check_commands( py, sh, 'args3', '~', '*' )


def makecmd02():
    """
    getCommands(): shell expansion
    """
    cmd = Command( sys.executable, 'args1' )
    py,sh = cmd.getCommands( True, None, None )
    check_commands( py, sh, 'args1' )

    cmd = Command( sys.executable, 'args2', '-s', 'foo' )
    py,sh = cmd.getCommands( True, None, None )
    check_commands( py, sh, 'args2', '-s', 'foo' )

    # write two files to test globbing
    writefile( 'file1.ext', 'foo\n' )
    writefile( 'file2.ext', 'bar\n' )
    time.sleep(1)

    cmd = Command( sys.executable, 'args3', '~', 'file*.ext' )
    py,sh = cmd.getCommands( True, None, None )
    check_commands( py, sh, 'args3',
                    os.path.expanduser('~'), 'file1.ext', 'file2.ext' )

    cmd = Command( sys.executable, 'args4' ).escape( 'file*.ext' )
    py,sh = cmd.getCommands( True, None, None )
    check_commands( py, sh, 'args4', 'file*.ext' )


def makecmd03():
    """
    getCommands(): ssh with no shell expansion
    """
    sshprog,sshmach = get_ssh_pair()

    cmd = Command( sys.executable, os.path.abspath('args1') )
    py,sh = cmd.getCommands( False, sshmach, sshprog )
    check_commands( py, sh, 'args1' )

    cmd = Command( sys.executable, os.path.abspath('args2'), '-s', 'foo' )
    py,sh = cmd.getCommands( False, sshmach, sshprog )
    check_commands( py, sh, 'args2', '-s', 'foo' )

    cmd = Command( sys.executable, os.path.abspath('args3'), '~', '*' )
    py,sh = cmd.getCommands( False, sshmach, sshprog )
    check_commands( py, sh, 'args3', '~', '*' )


def makecmd04():
    """
    getCommands(): ssh with shell expansion
    """
    sshprog,sshmach = get_ssh_pair()

    cmd = Command( sys.executable, os.path.abspath('args1') )
    py,sh = cmd.getCommands( True, sshmach, sshprog )
    check_commands( py, sh, 'args1' )

    cmd = Command( sys.executable, os.path.abspath('args2'), '-s', 'foo' )
    py,sh = cmd.getCommands( True, sshmach, sshprog )
    check_commands( py, sh, 'args2', '-s', 'foo' )

    # write two files to test globbing
    writefile( 'file1.ext', 'foo\n' )
    writefile( 'file2.ext', 'bar\n' )
    time.sleep(1)

    # note that this test is not perfect because the ssh is either faked or
    # the machine is the current machine, and therefore it is impossible to
    # know for sure that the globbing is occuring by the local shell or the
    # remote shell
    cmd = Command( sys.executable, os.path.abspath('args3'),
                   '~', os.path.abspath('file*.ext') )
    py,sh = cmd.getCommands( True, sshmach, sshprog )
    check_commands( py, sh, 'args3',
                    os.path.expanduser('~'),
                    os.path.abspath('file1.ext'),
                    os.path.abspath('file2.ext') )

    cmd = Command( sys.executable, os.path.abspath('args4')
                 ).escape( os.path.abspath('file*.ext') )
    py,sh = cmd.getCommands( True, sshmach, sshprog )
    check_commands( py, sh, 'args4', os.path.abspath('file*.ext') )


def check_commands( pycmd, shcmd, pyscript, *args ):
    """
    Checks the output from Command.getCommands() by executing the
    pair of commands it returns (the one meant for subprocess and the one
    for a shell).

    1. The command that produced 'pycmd' and 'shcmd' must execute ./pyscript

    2. The given arguments, 'args', are written into pyscript and checked
       against sys.argv[1:] upon execution
    """
    args = list(args)

    # the program to run is written as a python script;  it checks the args
    writefile( pyscript, """
        import sys, os
        if sys.argv[1:] != """+repr(args)+""":
            raise Exception( 'bad args: '+str(sys.argv[1:]) )
        """ )

    # to test the shell command, embed it in a shell script
    shscript = os.path.abspath( pyscript+'.sh' )
    writescript( shscript, "#!/bin/sh", """
        echo shcmd: """+shcmd+"""
        """+shcmd+""" || exit 1
        """ )

    time.sleep(1)

    # run the python command using subprocess
    if type(pycmd) == type(''):
        print3( 'pycmd:', repr(pycmd) )
        assert subprocess.call( pycmd, shell=True ) == 0
    else:
        print3( 'pycmd:', pycmd )
        assert subprocess.call( pycmd, shell=False ) == 0

    # run the shell command by executing the shell script helper
    assert subprocess.call( [ shscript ], shell=False ) == 0


def dry01():
    """
    the CommandDryRun class
    """
    dr = command.CommandDryRun()
    assert dr.runIt()
    assert dr.runIt( '/hello/world -a foo' )
    assert dr.runIt( ['/hello/world','-a','foo'] )

    os.environ['COMMAND_DRYRUN'] = '1'
    dr = command.CommandDryRun()
    assert not dr.runIt()
    assert not dr.runIt( '/hello/world -a foo' )
    assert not dr.runIt( ['/hello/world','-a','foo'] )

    os.environ['COMMAND_DRYRUN'] = ' '
    dr = command.CommandDryRun()
    assert not dr.runIt()
    assert not dr.runIt( '/hello/world -a foo' )
    assert not dr.runIt( ['/hello/world','-a','foo'] )

    os.environ['COMMAND_DRYRUN'] = 'hello'
    dr = command.CommandDryRun()
    assert not dr.runIt()
    assert not dr.runIt( '/hello/world -a foo' )
    assert not dr.runIt( ['/hello/world','-a','foo'] )

    os.environ['COMMAND_DRYRUN'] = 'world'
    dr = command.CommandDryRun()
    assert not dr.runIt()
    assert dr.runIt( '/hello/world -a foo' )
    assert dr.runIt( ['/hello/world','-a','foo'] )

    os.environ['COMMAND_DRYRUN'] = 'foo/bar'
    dr = command.CommandDryRun()
    assert not dr.runIt()
    assert not dr.runIt( '/hello/world -a foo' )
    assert not dr.runIt( ['/hello/world','-a','foo'] )

    os.environ['COMMAND_DRYRUN'] = 'world/bar'
    dr = command.CommandDryRun()
    assert not dr.runIt()
    assert dr.runIt( '/hello/world -a foo' )
    assert dr.runIt( ['/hello/world','-a','foo'] )

    os.environ['COMMAND_DRYRUN'] = 'foo/world'
    dr = command.CommandDryRun()
    assert not dr.runIt()
    assert dr.runIt( '/hello/world -a foo' )
    assert dr.runIt( ['/hello/world','-a','foo'] )

    os.environ['COMMAND_DRYRUN'] = 'foo/world'
    dr = command.CommandDryRun()
    assert not dr.runIt()
    assert dr.runIt( '/hello/world -a foo' )
    assert dr.runIt( ['/hello/foo','-a','foo'] )


class MockEcho:
    def preExecute(self): pass
    def postExecute(self, x): pass

class MockStreams:
    def openStdout(self): return None
    def openStderr(self): return None
    def close(self): pass



def run01():
    """
    run command, quick check
    """
    cmd = sys.executable + ' -c "fp=open(\'foo.txt\',\'w\'); fp.close()"'
    runr = command.SubprocessRunner( cmd, None, MockStreams(), MockEcho() )
    runr.runCommand()
    time.sleep(1)
    assert os.path.exists( 'foo.txt' )

    cmd = [ sys.executable, '-c', 'fp=open("bar.txt","w"); fp.close()' ]
    runr = command.SubprocessRunner( cmd, None, MockStreams(), MockEcho() )
    runr.runCommand()
    time.sleep(1)
    assert os.path.exists( 'bar.txt' )

    cmd = Command( sys.executable )
    cmd.escape( '-c', 'fp=open("baz.txt","w"); fp.close()' )
    cmd.run()
    assert os.path.exists( 'baz.txt' )

    cmd = Command( sys.executable )
    cmd.arg( '-c', 'fp=open("fore.txt","w"); fp.close()' )
    cmd.run( shell=False )
    assert os.path.exists( 'fore.txt' )


def run02():
    """
    run command, echo check
    """
    # first check without echo
    cmd = [ sys.executable, '-c',
            'import os,sys; sys.stdout.write("hello"+os.linesep); ' + \
            'sys.stderr.write("world"+os.linesep);' ]
    runr = command.SubprocessRunner( cmd, None, MockStreams(), MockEcho() )
    redir = RedirectStdout('stdout.log','stderr.log')
    try:
        runr.runCommand()
    finally:
        redir.close()
    time.sleep(1)
    assert readfile('stdout.log') == 'hello\n'
    assert readfile('stderr.log') == 'world\n'

    echo = command.construct_echo_object( "echo", ' '.join(cmd), None )
    runr = command.SubprocessRunner( cmd, None, MockStreams(), echo )
    redir = RedirectStdout('stdout2.log','stderr2.log')
    try:
        runr.runCommand()
    finally:
        redir.close()
    time.sleep(1)
    L = filegrep( 'stdout2.log', 'sys.stdout' )
    assert len(L) == 1
    L = filegrep( 'stdout2.log', 'hello' )
    assert len(L) == 2
    assert L[1].strip() == 'hello'
    assert readfile('stderr.log') == 'world\n'

    cmd = Command( sys.executable, '-c' )
    cmd.escape( 'import os,sys; sys.stdout.write("hello"+os.linesep); ' + \
                'sys.stderr.write("world"+os.linesep);' )
    redir = RedirectStdout('stdout3.log','stderr3.log')
    try:
        cmd.run()
    finally:
        redir.close()
    time.sleep(1)
    L = filegrep( 'stdout3.log', 'sys.stdout' )
    assert len(L) == 1
    L = filegrep( 'stdout3.log', 'hello' )
    assert len(L) == 2
    assert L[1].strip() == 'hello'
    assert readfile('stderr.log') == 'world\n'

    cmd = Command( sys.executable, '-c' )
    cmd.escape( 'import os,sys; sys.stdout.write("hello"+os.linesep); ' + \
                'sys.stderr.write("world"+os.linesep);' )
    redir = RedirectStdout('stdout4.log','stderr4.log')
    try:
        cmd.run( echo="none" )
    finally:
        redir.close()
    time.sleep(1)
    L = filegrep( 'stdout4.log', 'sys.stdout' )
    assert len(L) == 0
    assert readfile('stdout4.log') == 'hello\n'
    assert readfile('stderr4.log') == 'world\n'


def run03():
    """
    run command, streams check
    """
    # first check without streams
    cmd = [ sys.executable, '-c',
            'import os,sys; sys.stdout.write("hello"+os.linesep); ' + \
            'sys.stderr.write("world"+os.linesep);' ]
    runr = command.SubprocessRunner( cmd, None, MockStreams(), MockEcho() )
    redir = RedirectStdout('stdout.log','stderr.log')
    try:
        runr.runCommand()
    finally:
        redir.close()
    time.sleep(1)
    assert readfile('stdout.log') == 'hello\n'
    assert readfile('stderr.log') == 'world\n'

    streams = command.SubprocessStreams( 'redir.log', None, None )
    runr = command.SubprocessRunner( cmd, None, streams, MockEcho() )
    redir = RedirectStdout('stdout2.log','stderr2.log')
    try:
        runr.runCommand()
    finally:
        redir.close()
    time.sleep(1)
    assert not readfile('stdout2.log').strip()
    assert not readfile('stderr2.log').strip()
    L = filegrep( 'redir.log', 'hello' )
    assert len(L) == 1 and L[0].strip() == 'hello'
    L = filegrep( 'redir.log', 'world' )
    assert len(L) == 1 and L[0].strip() == 'world'

    cmd = Command( sys.executable, '-c' )
    cmd.escape( 'import os,sys; sys.stdout.write("hello"+os.linesep); ' + \
                'sys.stderr.write("world"+os.linesep);' )
    redir = RedirectStdout('stdout3.log','stderr3.log')
    try:
        cmd.run( echo="none", redirect="redir3.log" )
    finally:
        redir.close()
    time.sleep(1)
    assert not readfile('stdout3.log').strip()
    assert not readfile('stderr3.log').strip()
    L = filegrep( 'redir3.log', 'hello' )
    assert len(L) == 1 and L[0].strip() == 'hello'
    L = filegrep( 'redir3.log', 'world' )
    assert len(L) == 1 and L[0].strip() == 'world'


def run04():
    """
    run command, failures
    """
    runr = command.SubprocessRunner( '/path/junk',
                                     None, MockStreams(), MockEcho() )
    x,out,err = call_capture_output( runr.runCommand )
    assert x != 0 and x != None
    assert err.strip()

    runr = command.SubprocessRunner( '/path/junk',
                                     None, MockStreams(), MockEcho() )
    x,out,err = call_capture_output( runr.runCommand, raise_on_error=False )
    assert x != 0 and x != None
    assert err.strip()

    runr = command.SubprocessRunner( '/path/junk',
                                     None, MockStreams(), MockEcho() )
    try:
        x,out,err = call_capture_output( runr.runCommand, raise_on_error=True )
    except:
        pass
    else:
        raise Exception( 'expected an exception' )

    # as a python list, the subprocess.Popen() call will raise exception
    runr = command.SubprocessRunner( ['/path/junk'],
                                     None, MockStreams(), MockEcho() )
    x,out,err = call_capture_output( runr.runCommand )
    assert x != 0 and x != None
    assert err.strip()

    runr = command.SubprocessRunner( ['/path/junk'],
                                     None, MockStreams(), MockEcho() )
    try:
        x,out,err = call_capture_output( runr.runCommand, raise_on_error=True )
    except command.CommandException:
        pass
    else:
        raise Exception( 'expected an exception' )

    cmd = [ sys.executable, '-c', 'raise Exception("fake exception")' ]
    runr = command.SubprocessRunner( cmd, None, MockStreams(), MockEcho() )
    x,out,err = call_capture_output( runr.runCommand )
    assert x != 0 and x != None
    assert err.strip()

    try:
        x,out,err = call_capture_output( runr.runCommand, raise_on_error=True )
    except command.CommandException:
        pass
    else:
        raise Exception( 'expected an exception' )

    cmd = Command( '/path/junk' )
    x,out,err = call_capture_output( cmd.run )
    assert x != 0 and x != None
    assert err.strip()

    try:
        x,out,err = call_capture_output( cmd.run, raise_on_error=True )
    except command.CommandException:
        pass
    else:
        raise Exception( 'expected an exception' )

    # redirect error
    cmd = Command( sys.executable, '-c' )
    cmd.escape( 'import os' )
    x,out,err = call_capture_output( cmd.run,
                                     redirect='/path/noexist/foobar.log' )
    assert x != 0 and x != None
    assert err.strip()

    try:
        x,out,err = call_capture_output( cmd.run,
                                         redirect='/path/noexist/foobar.log',
                                         raise_on_error=True )
    except command.CommandException:
        pass
    else:
        raise Exception( 'expected an exception' )

    # change directory error
    cmd = Command( sys.executable, '-c' )
    cmd.escape( 'import os' )
    x,out,err = call_capture_output( cmd.run, chdir='/path/noexist' )
    assert x != 0 and x != None
    assert err.strip()

    try:
        x,out,err = call_capture_output( cmd.run,
                                         chdir='/path/noexist',
                                         raise_on_error=True )
    except command.CommandException:
        pass
    else:
        raise Exception( 'expected an exception' )


def run05():
    """
    run command, check runit argument
    """
    runr = command.SubprocessRunner( '/path/junk',
                                     None, MockStreams(), MockEcho() )
    x = runr.runCommand( runit=False )
    assert x == 0

    runr = command.SubprocessRunner( ['/path/junk'],
                                     None, MockStreams(), MockEcho() )
    x = runr.runCommand( runit=False )
    assert x == 0

    cmd = [ sys.executable, '-c', 'raise Exception("fake exception")' ]
    runr = command.SubprocessRunner( cmd, None, MockStreams(), MockEcho() )
    x = runr.runCommand( runit=False )
    assert x == 0

    cmd = Command( sys.executable, '-c' )
    cmd.escape( 'raise Exception("fake exception")' )
    os.environ['COMMAND_DRYRUN'] = '1'
    x = cmd.run()
    assert x == 0


def run06():
    """
    run() with chdir
    """
    os.mkdir( 'rundir' )
    time.sleep(1)

    cwd = os.getcwd()
    cmd = Command( sys.executable )
    cmd.arg( '-c', 'fp=open("foo.txt","w"); fp.close()' )
    cmd.run( shell=False, chdir='rundir' )
    time.sleep(1)
    assert os.getcwd() == cwd
    assert os.path.exists( 'rundir/foo.txt' )

    # even with an exception, the final directory should not change
    cmd = Command( '/path/junk' )
    try:
        x,out,err = call_capture_output( cmd.run,
                                         shell=False, raise_on_error=True )
    except command.CommandException:
        pass
    else:
        raise Exception( "expected an exception" )
    assert os.getcwd() == cwd


def runout01():
    """
    OutputSubprocessRunner
    """
    cmd = sys.executable + ' -c ' + \
            '''"import os,sys;''' + \
            '''sys.stdout.write('hello'+os.linesep); sys.stdout.flush();''' + \
            '''sys.stderr.write('world'+os.linesep); sys.stderr.flush()"'''

    ech = MockEcho()

    streams = command.SubprocessStreams( None, None, None )
    runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
    rtn,out,err = call_capture_output( runr.runCommand )
    assert not rtn.strip()
    assert out.strip() == 'hello'
    assert err.strip() == 'world'

    streams = command.SubprocessStreams( None, None, None, capture=None )
    runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
    rtn,out,err = call_capture_output( runr.runCommand )
    assert not rtn.strip()
    assert out.strip() == 'hello'
    assert err.strip() == 'world'

    streams = command.SubprocessStreams( None, None, None, capture='stdout' )
    runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
    rtn,out,err = call_capture_output( runr.runCommand )
    assert rtn == 'hello'+os.linesep
    assert not out.strip()
    assert err.strip() == 'world'

    streams = command.SubprocessStreams( None, None, None, capture='stdouterr' )
    runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
    rtn,out,err = call_capture_output( runr.runCommand )
    assert 'hello' in rtn
    assert 'world' in rtn
    assert not out.strip()
    assert not err.strip()


def runout02():
    """
    OutputSubprocessRunner mixed with redirects
    """
    cmd = sys.executable + ' -c ' + \
            '''"import os,sys;''' + \
            '''sys.stdout.write('hello'+os.linesep); sys.stdout.flush();''' + \
            '''sys.stderr.write('world'+os.linesep); sys.stderr.flush()"'''

    ech = MockEcho()

    # capture takes precedence
    streams = command.SubprocessStreams( None, 'ofile1.txt', None,
                                         capture="stdout" )
    runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
    rtn,out,err = call_capture_output( runr.runCommand )
    assert rtn.strip() == 'hello'
    assert not out.strip()
    assert err.strip() == 'world'
    assert not os.path.exists('ofile1.txt')

    streams = command.SubprocessStreams( None, None, 'efile2.txt',
                                         capture="stdout" )
    runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
    rtn,out,err = call_capture_output( runr.runCommand )
    assert rtn.strip() == 'hello'
    assert not out.strip()
    assert readfile('efile2.txt').strip() == 'world'

    streams = command.SubprocessStreams( None, 'ofile3.txt', None,
                                         capture="stderr" )
    runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
    rtn,out,err = call_capture_output( runr.runCommand )
    assert rtn.strip() == 'world'
    assert not out.strip()
    assert not err.strip()
    assert readfile('ofile3.txt').strip() == 'hello'

    streams = command.SubprocessStreams( None, None, 'efile4.txt',
                                         capture="stderr" )
    runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
    rtn,out,err = call_capture_output( runr.runCommand )
    assert rtn.strip() == 'world'
    assert out.strip() == 'hello'
    assert not err.strip()
    assert not os.path.exists( 'efile4.txt' )

    streams = command.SubprocessStreams( None, 'ofile5.txt', None,
                                         capture="stdouterr" )
    runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
    rtn,out,err = call_capture_output( runr.runCommand )
    assert 'hello' in rtn
    assert 'world' in rtn
    assert not out.strip()
    assert not err.strip()
    assert not os.path.exists('ofile5.txt')

    streams = command.SubprocessStreams( None, None, 'efile6.txt',
                                         capture="stdouterr" )
    runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
    rtn,out,err = call_capture_output( runr.runCommand )
    assert 'hello' in rtn
    assert 'world' in rtn
    assert not out.strip()
    assert not err.strip()
    assert not os.path.exists( 'efile6.txt' )


def runout03():
    """
    run_output, check capturing
    """
    cmd = Command( sys.executable, '-c' )
    cmd.escape(
        "import os,sys;" + \
        "sys.stdout.write('hello'+os.linesep); sys.stdout.flush();" + \
        "sys.stderr.write('world'+os.linesep); sys.stderr.flush()" )

    rtn,out,err = call_capture_output( cmd.run_output )
    assert rtn.strip() == 'hello'
    assert 'hello' in out  # the command gets echoed
    assert err.strip() == 'world'

    rtn,out,err = call_capture_output( cmd.run_output, 'stdout' )
    assert rtn.strip() == 'hello'
    assert 'hello' in out
    assert err.strip() == 'world'

    rtn,out,err = call_capture_output( cmd.run_output, capture='stdout' )
    assert rtn.strip() == 'hello'
    assert 'hello' in out
    assert err.strip() == 'world'

    rtn,out,err = call_capture_output( cmd.run_output, 'stderr' )
    assert rtn.strip() == 'world'
    assert 'hello' in out
    assert not err.strip()

    rtn,out,err = call_capture_output( cmd.run_output, 'stdouterr' )
    assert 'hello' in rtn.strip()
    assert 'world' in rtn.strip()
    assert 'hello' in out
    assert not err.strip()


def runout04():
    """
    run_output, exercise options
    """
    sshprog,sshmach = get_ssh_pair()
    os.mkdir( 'temp' )
    time.sleep(1)

    cmd = Command( sys.executable, '-c' )
    cmd.escape(
        "import os,sys;" + \
        "sys.stderr.write(os.getcwd()+os.linesep); sys.stderr.flush()" )

    rtn,out,err = call_capture_output( cmd.run_output, capture="stderr",
                                       chdir='temp', echo="none" )
    assert os.path.basename( rtn.strip() ) == 'temp'
    assert os.path.basename( os.getcwd() ) != 'temp'
    assert not out.strip()
    assert not err.strip()

    cmd = Command( sys.executable, '-c' )
    cmd.arg(
        "import os,sys;" + \
        "sys.stderr.write('foobarbaz'+os.linesep); sys.stderr.flush()" )

    rtn,out,err = call_capture_output( cmd.run_output, capture="stderr",
                                       shell=False,
                                       machine=sshmach, sshexe=sshprog )
    assert 'foobarbaz' in rtn.strip()
    assert 'flush' in out
    assert not err.strip()

    cmd = Command( sys.executable, '-c' )
    cmd.arg( "raise Exception('fake error')" )

    try:
        rtn,out,err = call_capture_output( cmd.run_output, capture="stderr",
                                           shell=False,
                                           raise_on_error=True )
    except:
        pass
    else:
        raise Exception( 'expected an exception' )


def timeout01():
    """
    compute_timeout_value
    """
    try:
        t = command.compute_timeout_value( None, None )
    except:
        pass
    else:
        raise Exception( "expected an exception" )

    command.compute_timeout_value( '2', None )
    command.compute_timeout_value( None, '3' )
    command.compute_timeout_value( '2.1', None )
    command.compute_timeout_value( None, '3.2' )

    t = command.compute_timeout_value( 5, None )
    assert abs( t - 5 ) < 1

    t = command.compute_timeout_value( 5.5, None )
    assert abs( t - 5.5 ) < 1

    t = command.compute_timeout_value( '5.5', None )
    assert abs( t - 5.5 ) < 1

    t = command.compute_timeout_value( -5, None )
    assert t > 0 and t < 1

    d = time.time() + 10
    t = command.compute_timeout_value( None, d )
    assert abs( t - 10 ) < 2

    d = time.time() - 10
    t = command.compute_timeout_value( None, d )
    assert t > 0 and t < 1

    d = time.time() + 10
    t = command.compute_timeout_value( 10, d )
    assert abs( t - 10 ) < 2

    d = time.time() + 20
    t = command.compute_timeout_value( 10, d )
    assert abs( t - 10 ) < 2

    d = time.time() + 10
    t = command.compute_timeout_value( 20, d )
    assert abs( t - 10 ) < 2

    d = time.time() + 10
    t = command.compute_timeout_value( -10, d )
    assert t > 0 and t < 1


def write_subproc_helper():
    """
    writes a python script with helper functions for import into test scripts
    """
    writefile( 'subhelper.py', """
        import os, sys, time, subprocess
        def log( filename, *args ):
            fp = open( filename, 'a' )
            fp.write( ' '.join( [ str(x) for x in args ] ) + os.linesep )
            fp.close()
        """ )


def timeout02():
    """
    KillableSubprocess, kill a subprocess
    """
    cwd = os.getcwd()

    write_subproc_helper()

    # first, check running a subprocess

    writefile( 'sub1.py', """
        import os, sys, time, subprocess
        sys.path.insert( 0, '"""+cwd+"""' )
        from subhelper import *
        log( 'sub1.log', 'START', os.getpid(), time.time() )
        time.sleep(1)
        log( 'sub1.log', 'DONE', time.time() )
        """ )

    time.sleep(1)

    ksp = command.KillableSubprocess( [sys.executable,'sub1.py'] )
    time.sleep(3)
    assert ksp.checkIfDone(1)
    assert ksp.getSubproc().returncode == 0
    assert len( filegrep( 'sub1.log', 'START' ) ) == 1
    assert len( filegrep( 'sub1.log', 'DONE' ) ) == 1

    # next, timeout a subprocess

    writefile( 'sub2.py', """
        import os, sys, time, subprocess
        sys.path.insert( 0, '"""+cwd+"""' )
        from subhelper import *
        log( 'sub2.log', 'START', os.getpid(), time.time() )
        time.sleep(20)
        log( 'sub2.log', 'DONE', time.time() )
        """ )

    time.sleep(1)

    ksp = command.KillableSubprocess( [sys.executable,'sub2.py'] )
    time.sleep(2)
    t0 = time.time()
    assert not ksp.checkIfDone(1)
    ksp.kill( signal.SIGTERM, signal.SIGKILL )
    t1 = time.time()
    assert t1 - t0 < 6
    assert len( filegrep( 'sub2.log', 'START' ) ) == 1
    assert len( filegrep( 'sub2.log', 'DONE' ) ) == 0


def timeout03():
    """
    KillableSubprocess, kill a subprocess that runs a subprocess
    """
    cwd = os.getcwd()

    write_subproc_helper()

    writefile( 'sub1.py', """
        import os, sys, time, subprocess
        sys.path.insert( 0, '"""+cwd+"""' )
        from subhelper import *
        log( 'sub1.log', 'START', os.getpid(), time.time() )
        subprocess.call( [sys.executable,'"""+cwd+"""/sub2.py'] )
        time.sleep(1)
        log( 'sub1.log', 'DONE', time.time() )
        """ )

    writefile( 'sub2.py', """
        import os, sys, time, subprocess
        sys.path.insert( 0, '"""+cwd+"""' )
        from subhelper import *
        log( 'sub2.log', 'START', os.getpid(), time.time() )
        time.sleep(20)
        log( 'sub2.log', 'DONE', time.time() )
        """ )

    time.sleep(1)

    ksp = command.KillableSubprocess( [sys.executable,'sub1.py'] )
    time.sleep(2)

    plist1 = get_process_list()

    t0 = time.time()
    assert not ksp.checkIfDone(1)
    ksp.kill( signal.SIGTERM, signal.SIGKILL )
    t1 = time.time()
    time.sleep(1)

    plist2 = get_process_list()

    assert t1 - t0 < 6
    L = filegrep( 'sub1.log', 'START' )
    assert len(L) == 1
    pid1 = int( L[0].split()[1] )

    L = filegrep( 'sub2.log', 'START' )
    assert len(L) == 1
    pid2 = int( L[0].split()[1] )
    assert pid2 != pid1

    assert len( filegrep( 'sub1.log', 'DONE' ) ) == 0
    assert len( filegrep( 'sub2.log', 'DONE' ) ) == 0

    assert find_process_in_list( plist1, pid1 ) != None
    assert find_process_in_list( plist1, pid2 ) != None
    assert find_process_in_list( plist2, pid1 ) == None
    assert find_process_in_list( plist2, pid2 ) == None



def timeout04():
    """
    run_timeout, a single subprocess
    """
    cwd = os.getcwd()

    write_subproc_helper()

    # first, check running a subprocess

    writefile( 'sub1.py', """
        import os, sys, time, subprocess
        sys.path.insert( 0, '"""+cwd+"""' )
        from subhelper import *
        log( 'sub1.log', 'START', os.getpid(), time.time() )
        time.sleep(1)
        log( 'sub1.log', 'DONE', time.time() )
        """ )

    time.sleep(1)

    cmd = Command( sys.executable, 'sub1.py' )

    t1 = time.time()
    x = cmd.run_timeout( 60 )
    t2 = time.time()

    assert t2-t1 < 5
    assert x == 0
    assert len( filegrep( 'sub1.log', 'START' ) ) == 1
    assert len( filegrep( 'sub1.log', 'DONE' ) ) == 1

    # next, timeout a subprocess

    writefile( 'sub2.py', """
        import os, sys, time, subprocess
        sys.path.insert( 0, '"""+cwd+"""' )
        from subhelper import *
        log( 'sub2.log', 'START', os.getpid(), time.time() )
        time.sleep(20)
        log( 'sub2.log', 'DONE', time.time() )
        """ )

    time.sleep(1)

    cmd = Command( sys.executable, 'sub2.py' )

    t1 = time.time()
    x = cmd.run_timeout( 3 )
    t2 = time.time()

    assert t2-t1 < 6
    assert x == None
    assert len( filegrep( 'sub2.log', 'START' ) ) == 1
    assert len( filegrep( 'sub2.log', 'DONE' ) ) == 0


def timeout05():
    """
    run_timeout, a subprocess that runs a subprocess
    """
    cwd = os.getcwd()

    write_subproc_helper()

    writefile( 'sub1.py', """
        import os, sys, time, subprocess
        sys.path.insert( 0, '"""+cwd+"""' )
        from subhelper import *
        log( 'sub1.log', 'START', os.getpid(), time.time() )
        subprocess.call( [sys.executable,'"""+cwd+"""/sub2.py'] )
        time.sleep(1)
        log( 'sub1.log', 'DONE', time.time() )
        """ )

    writefile( 'sub2.py', """
        import os, sys, time, subprocess
        sys.path.insert( 0, '"""+cwd+"""' )
        from subhelper import *
        log( 'sub2.log', 'START', os.getpid(), time.time() )
        time.sleep(20)
        log( 'sub2.log', 'DONE', time.time() )
        """ )

    time.sleep(1)

    cmd = Command( sys.executable, 'sub1.py' )

    t1 = time.time()
    x = cmd.run_timeout( 3 )
    t2 = time.time()
    plist = get_process_list()

    assert t2-t1 < 6
    assert x == None

    L = filegrep( 'sub1.log', 'START' )
    assert len(L) == 1
    pid1 = int( L[0].split()[1] )

    L = filegrep( 'sub2.log', 'START' )
    assert len(L) == 1
    pid2 = int( L[0].split()[1] )
    assert pid2 != pid1

    assert len( filegrep( 'sub1.log', 'DONE' ) ) == 0
    assert len( filegrep( 'sub2.log', 'DONE' ) ) == 0

    assert find_process_in_list( plist, pid1 ) == None
    assert find_process_in_list( plist, pid2 ) == None


######################################################################


def extract_log_lines( fp ):
    """
    Loops over lines in a file and extracts the lines with log markers.
    Returns a list of

        [ epoch time, marker name, data list ]
    """
    lines = []
    for line in fp.readlines():
        L = parse_log_line( line )
        if L:
            lines.append( [ L[0], L[1], eval(L[2]) ] )

    return lines

def parse_log_line( line ):
    """
    This parses log files the same way triglog.py does it.  It should really
    be generalized somehow, but I don't really have a good design yet (and
    haven't put enough effort into doing so).

    For now, this logic will be duplicated and has to be manually synchronized.
    """
    logline = None

    markers = [ 'runcmd: ', 'return: ' ]

    line = _STRING_(line).rstrip()
    datemark = re.compile(
        r'\[(Mon|Tue|Wed|Thu|Fri|Sat|Sun)([^]]*20[0-9][0-9]\])+?' )
    m = datemark.match( line )
    if m != None:
        try:
            ts = line[:m.end()].strip().strip('[').strip(']')
            tm = time.mktime( time.strptime( ts ) )
            line = line[m.end():].strip()
            for n in markers:
                if line.startswith(n):
                    data = line.split(n,1)[1].strip()
                    L = [ tm, n.strip().rstrip(':'), data ]
                    logline = L
                    break
        except:
            #traceback.print_exc()  # uncomment to debug
            pass

    return logline


######################################################################

class RedirectStdout:
    """
    A convenience class to redirect the current process's stdout to a file.
    Constructor initiates the redirection, close() stops it.
    """

    def __init__(self, filename, stderr_filename=None):
        """
        If 'stderr_filename' is not None, stderr goes to that filename.
        """
        self.filep = open( filename, 'w' )
        self.save_stdout_fd = os.dup(1)
        os.dup2( self.filep.fileno(), 1 )
        self.filep2 = None
        if stderr_filename:
            self.filep2 = open( stderr_filename, 'w' )
            self.save_stderr_fd = os.dup(2)
            os.dup2( self.filep2.fileno(), 2 )

    def close(self):
        sys.stdout.flush()
        os.dup2( self.save_stdout_fd, 1 )
        os.close( self.save_stdout_fd )
        self.filep.close()
        if self.filep2 != None:
            sys.stderr.flush()
            os.dup2( self.save_stderr_fd, 2 )
            os.close( self.save_stderr_fd )
            self.filep2.close()

call_capture_id = 0

def call_capture_output( func, *args, **kwargs ):
    """
    """
    global call_capture_id
    outid = call_capture_id
    call_capture_id += 1

    of = 'stdout'+str(outid)+'.log'
    ef = 'stderr'+str(outid)+'.log'

    redir = RedirectStdout( of, ef )
    try:
        rtn = func( *args, **kwargs )
    finally:
        redir.close()
    time.sleep(1)

    return rtn, readfile(of), readfile(ef)


def get_process_list():
    """
    Return a python list of all processes on the current machine, where each
    entry is a length three list of form

        [ user, pid, ppid ]
    """
    plat = sys.platform.lower()
    if plat.startswith( 'darwin' ):
        cmd = 'ps -o user,pid,ppid'
    else:
        cmd = 'ps -o user,pid,ppid'
    cmd += ' -e'

    p = subprocess.Popen( 'ps -o user,pid,ppid -e',
                          shell=True, stdout=subprocess.PIPE )
    sout,serr = p.communicate()

    sout = _STRING_(sout)

    # strip off first non-empty line (the header)

    first = True
    lineL = []
    for line in sout.split( os.linesep ):
        line = line.strip()
        if line:
            if first:
                first = False
            else:
                L = line.split()
                if len(L) == 3:
                    try:
                        L[1] = int(L[1])
                        L[2] = int(L[2])
                    except:
                        pass
                    else:
                        lineL.append( L )

    return lineL


def find_process_in_list( proclist, pid ):
    """
    Searches for the given 'pid' in 'proclist' (which should be the output
    from get_process_list().  If not found, None is returned.  Otherwise a
    list

        [ user, pid, ppid ]
    """
    for L in proclist:
        if pid == L[1]:
            return L
    return None


if sys.version_info[0] < 3:
    # with python 2.x, files, pipes, and sockets work naturally
    def _BYTES_(s): return s
    def _STRING_(b): return b

else:
    # with python 3.x, read/write to files, pipes, and sockets is tricky
    bytes_type = type( ''.encode() )

    def _BYTES_(s):
        if type(s) == bytes_type:
            return s
        return s.encode( 'ascii' )

    def _STRING_(b):
        if type(b) == bytes_type:
            return b.decode()
        return b


def writefile( fname, content, header=None ):
    """
    Open and write 'content' to file 'fname'.  The content is modified to
    remove leading spaces on each line.  The first non-empty line is used
    to determine how many spaces to remove.
    """
    # determine indent pad of the given content
    pad = None
    lineL = []
    for line in content.split( '\n' ):
        line = line.rstrip( '\r' )
        lineL.append( line )
        if pad == None and line.strip():
            for i in range(len(line)):
                if line[i] != ' ':
                    pad = i
                    break
    # make the directory to contain the file, if not already exist
    d = os.path.dirname( fname )
    if os.path.normpath(d) not in ['','.']:
      if not os.path.exists(d):
        os.makedirs(d)
    # open and write contents
    fp = open( fname, 'w' )
    if header != None:
        fp.write( header.strip() + '\n' )
    for line in lineL:
        if pad != None: fp.write( line[pad:] + '\n' )
        else:           fp.write( line + '\n' )
    fp.close()


def writescript( fname, header, content ):
    """
    The 'header' is something like "#!/bin/sh" and 'content' is the same as
    for writefile().
    """
    writefile( fname, content, header )
    perm = stat.S_IMODE( os.stat(fname)[stat.ST_MODE] )
    perm = perm | stat.S_IXUSR
    try: os.chmod(fname, perm)
    except: pass


def filegrep(fname, pat):
    """
    returns list of lines that match 'pat'
    """
    L = []
    fp = open(fname,"r")
    repat = re.compile(pat)
    for line in fp.readlines():
      line = line.rstrip()
      if repat.search(line):
        L.append(line)
    fp.close()
    return L


def readfile( fname ):
    """
    Read and return the contents of the given filename.
    """
    fp = open(fname,'r')
    try:
        s = fp.read()
    finally:
        fp.close()
    return s


def get_ssh_pair( fake_ssh_pause=None ):
    """
    Returns a pair ( ssh program, ssh machine ).
    """
    if use_real_ssh and fake_ssh_pause == None:
        sshprog = 'ssh'
        import socket
        sshmach = socket.gethostname()
    
    else:
        st = str(1)
        if fake_ssh_pause != None:
            st = str(fake_ssh_pause)
        writescript( 'fakessh', "#!"+localpy+" -E", """
            import os, sys, getopt, time
            optL,argL = getopt.getopt( sys.argv[1:], 'xTv' )
            argL.pop(0)  # remove the machine name
            time.sleep( """+st+""" )
            os.execl( '/bin/bash', '/bin/bash', '-c', ' '.join( argL ) )
            """ )
        sshprog = os.path.abspath( 'fakessh' )
        sshmach = 'sparky'

    return sshprog, sshmach


######################################################################

def rmallfiles( not_these=None ):
    for f in os.listdir("."):
        if not_these == None or not fnmatch.fnmatch( f, not_these ):
            if os.path.islink(f):
                os.remove(f)
            elif os.path.isdir(f):
                shutil.rmtree(f)
            else:
                os.remove(f)

def print3( *args ):
    """
    Python 2 & 3 compatible print function.
    """
    s = ' '.join( [ str(x) for x in args ] )
    sys.stdout.write( s + '\n' )
    sys.stdout.flush()


######################################################################

main()
