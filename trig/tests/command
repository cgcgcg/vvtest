#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST:
#OPTION: realssh

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import time
import shutil
import subprocess
import re
import traceback
import stat
import getopt
import signal
import unittest

import trigtestutils as trigutil
import testutils as util
from testutils import print3

# the module being tested
import command
from command import Command

# For the tests that use ssh, a "fake" ssh script is used that acts like ssh.
# To use an actual ssh, add the -s option to the unit test command line.  In
# this case, make sure you can ssh to the current machine without a password.
use_real_ssh = False

localpy = sys.executable


class variable_substiution_tests( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test( cleanout=False )

    def test_single_variable_substitution(self):
        ""
        vx = command.VariableExpander()

        assert vx.expand( 'nothing', {} ) == 'nothing'
        assert vx.expand( 'nothing', {'var':'val'} ) == 'nothing'

        assert vx.expand( '$vname', {} ) == '$vname'
        assert vx.expand( '$vname', {'vname':'value'} ) == 'value'

        assert vx.expand( '${vname}', {} ) == '${vname}'
        assert vx.expand( '${vname}', {'vname':'value'} ) == 'value'

        assert vx.expand( ' $vname', {'foo':'bar'} ) == ' $vname'
        assert vx.expand( ' $vname', {'vname':'value'} ) == ' value'

        assert vx.expand( ' ${vname}', {'foo':'bar'} ) == ' ${vname}'
        assert vx.expand( ' ${vname}', {'vname':'value'} ) == ' value'

        assert vx.expand( '$vname ', {'foo':'bar'} ) == '$vname '
        assert vx.expand( '$vname ', {'vname':'value'} ) == 'value '

        assert vx.expand( '${vname} ', {'foo':'bar'} ) == '${vname} '
        assert vx.expand( '${vname} ', {'vname':'value'} ) == 'value '

        assert vx.expand( ' $vname ', {'foo':'bar'} ) == ' $vname '
        assert vx.expand( ' $vname ', {'vname':'value'} ) == ' value '

        assert vx.expand( ' ${vname} ', {'foo':'bar'} ) == ' ${vname} '
        assert vx.expand( ' ${vname} ', {'vname':'value'} ) == ' value '

    def test_dollar_escape(self):
        ""
        vx = command.VariableExpander()

        assert vx.expand( r' \${vname} ', {'foo':'bar'} ) == r' ${vname} '
        assert vx.expand( r' \$vname ', {'foo':'bar'} ) == r' $vname '

        assert vx.expand( r' \${vname} ', {'vname':'value'} ) == r' ${vname} '
        assert vx.expand( r' \$vname ', {'vname':'value'} ) == r' $vname '

        D = {'vname':'value','foo':'bar'}
        assert vx.expand( r' \${vname}$foo ', D ) == r' ${vname}bar '
        assert vx.expand( r' \$vname${foo} ', D ) == r' $vnamebar '

    def test_two_variable_substitutions(self):
        ""
        vx = command.VariableExpander()

        assert vx.expand( '$var1$var2', {'foo':'bar'} ) == '$var1$var2'
        assert vx.expand( '${var1}${var2}', {'foo':'bar'} ) == '${var1}${var2}'

        assert vx.expand( '$var1$var2', {'var1':'bar'} ) == 'bar$var2'
        assert vx.expand( '${var1}${var2}', {'var1':'bar'} ) == 'bar${var2}'

        assert vx.expand( '$var1$var2', {'var2':'bar'} ) == '$var1bar'
        assert vx.expand( '${var1}${var2}', {'var2':'bar'} ) == '${var1}bar'

        D = {'var2':'bar', 'var1':'foo'}

        assert vx.expand( '$var1$var2', D ) == 'foobar'
        assert vx.expand( '${var1}${var2}', D ) == 'foobar'

        assert vx.expand( '$var1${var2}', D ) == 'foobar'
        assert vx.expand( '${var1}$var2', D ) == 'foobar'

        assert vx.expand( '$var1 ${var2}', D ) == 'foo bar'
        assert vx.expand( '${var1} $var2', D ) == 'foo bar'

        assert vx.expand( '$var1$blah${var2}', D ) == 'foo$blahbar'
        assert vx.expand( '${var1}$blah$var2', D ) == 'foo$blahbar'

        D = { 'foo':'bar', 'ext':'txt' }
        assert vx.expand( '${foo}bar$nope.$ext', D ) == 'barbar$nope.txt'

    def test_same_variable_substitution_twice(self):
        ""
        vx = command.VariableExpander()

        D = {'var1':'valA'}

        assert vx.expand( '$var1$var1', D ) == 'valAvalA'
        assert vx.expand( '${var1}${var1}', D ) == 'valAvalA'

        assert vx.expand( '$var1$var2$var1', D ) == 'valA$var2valA'
        assert vx.expand( '${var1}${var2}${var1}', D ) == 'valA${var2}valA'

        D = {'var1':'valA', 'var2':'valB'}
        assert vx.expand( '$var1$var2$var1', D ) == 'valAvalBvalA'
        assert vx.expand( '${var1}${var2}${var1}', D ) == 'valAvalBvalA'

    def test_non_string_expansion(self):
        ""
        vx = command.VariableExpander()

        assert vx.expand( 'X=$vname', { 'vname':42 } ) == 'X=42'
        val = vx.expand( 'X=$vname', { 'vname':4.2 } )
        assert val.startswith('X=4.') and abs( float(val[2:]) - 4.2 ) < 0.001
        assert vx.expand( 'X=$vname', { 'vname':None } ) == 'X=None'


def assert_EscapedArgument( in_arg, out_arg, out_shell, out_shell_no_expand ):
    ""
    cmd = command.EscapedArgument( in_arg )
    assert cmd.getArgument() == out_arg
    assert cmd.shellStringForExpansion() == out_shell
    assert cmd.shellStringWithoutExpansion() == out_shell_no_expand

def assert_SingleArgument( in_arg, out_arg, out_shell, out_shell_no_expand ):
    ""
    cmd = command.SingleArgument( in_arg )
    assert cmd.getArgument() == out_arg
    assert cmd.shellStringForExpansion() == out_shell
    assert cmd.shellStringWithoutExpansion() == out_shell_no_expand

def assert_asShell( cmd, shellfalse, shelltrue ):
    ""
    assert cmd.asShellString( shell=False ) == shellfalse
    assert cmd.asShellString() == shelltrue


class building_commands( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test( cleanout=False )

    def test_EscapedArgument_class(self):
        """
        Note that this test is somewhat fragile because it relies on the output
        from pipes.quote(), which can vary a little over python versions.
        """
        assert_EscapedArgument( 'hello', 'hello', 'hello', 'hello' )

        assert_EscapedArgument( 'hello world', "'hello world'",
                                "'hello world'", "'hello world'" )

        assert_EscapedArgument( 'hello$world', "'hello$world'",
                                "'hello$world'", "'hello$world'" )

        assert_EscapedArgument( '~/dirname/file.*', "'~/dirname/file.*'",
                                "'~/dirname/file.*'", "'~/dirname/file.*'" )

    def test_the_EscapedArgument_repr_function(self):
        ""
        from command import EscapedArgument
        cmd = command.EscapedArgument( 'hello' )
        s = repr(cmd)
        cmd2 = eval( s )
        assert cmd.getArgument() == cmd2.getArgument()

    def test_the_SingleArgument_class(self):
        ""
        assert_SingleArgument( 'hello', 'hello', 'hello', 'hello' )

        assert_SingleArgument( 'hello world', 'hello world',
                               'hello\\ world', "'hello world'" )

        assert_SingleArgument( '"hello world"', '"hello world"',
                               '\\"hello\\ world\\"', '\'"hello world"\'' )

        assert_SingleArgument( '~/dir/""', '~/dir/""',
                               '~/dir/\\"\\"', '\'~/dir/""\'' )

    def test_the_SingleArgument_repr_function(self):
        ""
        from command import SingleArgument
        cmd = command.SingleArgument( 'hello' )
        s = repr(cmd)
        cmd2 = eval( s )
        assert cmd.getArgument() == cmd2.getArgument()

    def test_using_the_add_function(self):
        ""
        cmd = Command() ; cmd.add( 'ls' )
        assert_asShell( cmd, 'ls', 'ls' )

        cmd = Command() ; cmd.add( 'echo hello' )
        assert_asShell( cmd, 'echo hello', 'echo hello' )

        cmd = Command() ; cmd.add( 'echo "hello world"' )
        assert_asShell( cmd, "echo 'hello world'", "echo hello\\ world" )

        cmd = Command() ; cmd.add( 'ls ~/bin/junk1 /usr/local/bin/junk2' )
        assert_asShell( cmd, "ls '~/bin/junk1' /usr/local/bin/junk2",
                             "ls ~/bin/junk1 /usr/local/bin/junk2" )

        cmd = Command()
        cmd.add( 'echo' ).add( '~/bin/junk1', '/usr/local/bin/junk2' )
        assert_asShell( cmd, "echo '~/bin/junk1' /usr/local/bin/junk2",
                             "echo ~/bin/junk1 /usr/local/bin/junk2" )

        cmd = Command()
        cmd.add( 'echo' ).add( '~/bin/junk1' ).add( '/usr/local/bin/junk2' )
        assert_asShell( cmd, "echo '~/bin/junk1' /usr/local/bin/junk2",
                             "echo ~/bin/junk1 /usr/local/bin/junk2" )

    def test_giving_Command_ctor_arguments(self):
        ""
        cmd = Command( 'ls' )
        assert_asShell( cmd, 'ls', 'ls' )

        cmd = Command( 'echo hello' )
        assert_asShell( cmd, 'echo hello', 'echo hello' )

        cmd = Command( 'echo "hello world"' )
        assert_asShell( cmd, "echo 'hello world'", "echo hello\\ world" )

        cmd = Command( 'echo ~/bin/junk1 /usr/local/bin/junk2' )
        assert_asShell( cmd, "echo '~/bin/junk1' /usr/local/bin/junk2",
                             "echo ~/bin/junk1 /usr/local/bin/junk2" )

        cmd = Command( 'echo' )
        cmd.add( '~/bin/junk1', '/usr/local/bin/junk2' )
        assert_asShell( cmd, "echo '~/bin/junk1' /usr/local/bin/junk2",
                             "echo ~/bin/junk1 /usr/local/bin/junk2" )

        cmd = Command( 'echo' )
        cmd.add( '~/bin/junk1' ).add( '/usr/local/bin/junk2' )
        assert_asShell( cmd, "echo '~/bin/junk1' /usr/local/bin/junk2",
                             "echo ~/bin/junk1 /usr/local/bin/junk2" )

    def test_using_the_arg_function(self):
        ""
        cmd = Command().arg( 'ls' )
        assert_asShell( cmd, 'ls', 'ls' )

        cmd = Command().arg( 'ls', 'file1', 'file2' )
        assert_asShell( cmd, 'ls file1 file2', 'ls file1 file2' )

        cmd = Command().arg( 'ls', 'file name' )
        assert_asShell( cmd, "ls 'file name'", 'ls file\\ name' )

        cmd = Command().arg( 'ls' ).arg( 'file name' )
        assert_asShell( cmd, "ls 'file name'", 'ls file\\ name' )

        cmd = Command( 'ls' )
        cmd.add( '~/bin/file name' ).arg( '/usr/local/bin/file name' )
        assert_asShell( cmd, "ls '~/bin/file' name '/usr/local/bin/file name'",
                             "ls ~/bin/file name /usr/local/bin/file\\ name" )

    def test_using_the_raw_function(self):
        ""
        cmd = Command().raw( 'ls' )
        assert_asShell( cmd, 'ls', 'ls' )

        cmd = Command().raw( 'ls', 'file1', 'file2' )
        assert_asShell( cmd, 'ls file1 file2', 'ls file1 file2' )

        cmd = Command().raw( 'ls', 'file1 file2' )
        assert_asShell( cmd, "ls 'file1 file2'", 'ls file1\\ file2' )

        cmd = Command().raw( 'ls' ).raw( 'file1 file2' )
        assert_asShell( cmd, "ls 'file1 file2'", 'ls file1\\ file2' )

        cmd = Command( 'ls' )
        cmd.add( '~/bin/file name'
            ).arg( '/usr/local/bin/file name'
            ).raw( './file name' )
        assert_asShell( cmd,
            "ls '~/bin/file' name '/usr/local/bin/file name' './file name'",
            "ls ~/bin/file name /usr/local/bin/file\\ name ./file\\ name" )

    def test_using_the_escape_function(self):
        ""
        cmd = Command().escape( 'ls' )
        assert_asShell( cmd, 'ls', 'ls' )

        cmd = Command().escape( 'ls', '*' )
        assert_asShell( cmd, "ls '*'", "ls '*'" )

        cmd = Command().escape( 'ls' ).escape( '*' )
        assert_asShell( cmd, "ls '*'", "ls '*'" )

        cmd = Command().escape( 'ls' ).escape( '*' ).escape( 'filename' )
        assert_asShell( cmd, "ls '*' filename", "ls '*' filename" )

        cmd = Command( 'ls' ).raw( '*' ).escape( '*' ).arg( '*' ).add( '*' )
        assert_asShell( cmd, "ls '*' '*' '*' '*'", "ls * '*' * *" )

    def test_giving_a_Command_instance_as_an_argument(self):
        ""
        cmd1 = Command( 'ls -ltr' )
        cmd2 = Command( cmd1, 'filename' )
        assert_asShell( cmd2, 'ls -ltr filename', 'ls -ltr filename' )

        cmd1 = Command( 'ls -ltr' )
        cmd2 = Command().add( cmd1, 'filename' )
        assert_asShell( cmd2, 'ls -ltr filename', 'ls -ltr filename' )

        cmd1 = Command( 'ls -ltr' )
        cmd2 = Command().arg( cmd1, 'filename' )
        assert_asShell( cmd2, 'ls -ltr filename', 'ls -ltr filename' )

        cmd1 = Command( 'ls -ltr' )
        cmd2 = Command().raw( cmd1, 'filename' )
        assert_asShell( cmd2, 'ls -ltr filename', 'ls -ltr filename' )

        cmd1 = Command( 'ls -ltr' )
        cmd2 = Command().escape( cmd1, 'filename' )
        assert_asShell( cmd2, 'ls -ltr filename', 'ls -ltr filename' )

        cmd1 = Command( '-ltr' )
        cmd2 = Command( 'ls', cmd1, 'filename' )
        assert_asShell( cmd2, 'ls -ltr filename', 'ls -ltr filename' )

        cmd1 = Command( '-ltr' )
        cmd2 = Command().add( 'ls', cmd1, 'filename' )
        assert_asShell( cmd2, 'ls -ltr filename', 'ls -ltr filename' )

        cmd1 = Command( '-ltr' )
        cmd2 = Command().arg( 'ls', cmd1, 'filename' )
        assert_asShell( cmd2, 'ls -ltr filename', 'ls -ltr filename' )

        cmd1 = Command( '-ltr' )
        cmd2 = Command().raw( 'ls', cmd1, 'filename' )
        assert_asShell( cmd2, 'ls -ltr filename', 'ls -ltr filename' )

        cmd1 = Command( '-ltr' )
        cmd2 = Command().escape( 'ls', cmd1, 'filename' )
        assert_asShell( cmd2, 'ls -ltr filename', 'ls -ltr filename' )

    def test_using_invalid_arguments_to_build_the_command(self):
        ""
        self.assertRaises( command.CommandException, Command, ['touch','file'] )

        self.assertRaises( command.CommandException, Command, ('touch','file') )

        self.assertRaises( command.CommandException,
                           Command().add, ['touch','file'] )

        self.assertRaises( command.CommandException,
                           Command().arg, ['touch','file'] )

        self.assertRaises( command.CommandException,
                           Command().escape, ['touch','file'] )

    def test_convert_a_Command_to_and_from_a_string_using_repr(self):
        ""
        cmd1 = Command( 'ls -ltr' )
        s = repr( cmd1 )
        cmd2 = command.make_Command_from_repr(s)
        assert cmd1.asShellString() == cmd2.asShellString()
        assert cmd1.asShellString( shell=False ) == \
               cmd2.asShellString( shell=False )


frameglobal = 'some value'

class SomeClass:
    def somefunc2(self, arg0, arg1 ):
        func2var = 2.2
        samevar = 'what?'
        somefunc1( 'zero' )

def somefunc1( argzero ):
    func1var = 1.1
    samevar = 'huh?'

    lD,gD = command.get_calling_frame_variables( 1 )
    assert 'argzero' in lD and lD['argzero'] == 'zero'
    assert 'func1var' in lD and lD['func1var'] == 1.1
    assert 'samevar' in lD and lD['samevar'] == 'huh?'
    assert 'frameglobal' in gD and gD['frameglobal'] == 'some value'
    
    lD,gD = command.get_calling_frame_variables( 2 )
    assert 'arg0' in lD and lD['arg0'] == 'first'
    assert 'arg1' in lD and lD['arg1'] == 'second'
    assert 'func2var' in lD and lD['func2var'] == 2.2
    assert 'samevar' in lD and lD['samevar'] == 'what?'
    assert 'self' in lD
    assert 'frameglobal' in gD and gD['frameglobal'] == 'some value'
    
    lD,gD = command.get_calling_frame_variables( 3 )
    assert 'cls' in lD and hasattr( lD['cls'], 'somefunc2' )
    assert 'localvar' in lD and lD['localvar'] == 1

globalvar = 'glob/value'


class frame_variable_introspection( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test( cleanout=False )

    def test_get_local_variables_from_calling_function(self):
        ""
        localvar = 1
        lD,gD = command.get_calling_frame_variables( 1 )
        assert 'localvar' in lD and lD['localvar'] == 1
        assert 'frameglobal' in gD and gD['frameglobal'] == 'some value'

        cls = SomeClass()
        cls.somefunc2( 'first', 'second' )

    def test_calling_frame_error(self):
        ""
        self.assertRaises( Exception, command.get_calling_frame_variables, 0 )
        self.assertRaises( Exception, command.get_calling_frame_variables, -1 )

    def test_substituting_local_and_global_variable_values(self):
        ""
        localvar = 'loc/value'

        cmd = Command( 'ls $globalvar $localvar' )
        assert cmd.asShellString( shell=False ) == 'ls glob/value loc/value'

        cmd = Command().add( 'ls $globalvar', '$localvar' )
        assert cmd.asShellString( shell=False ) == 'ls glob/value loc/value'

        cmd = Command().arg( 'ls', '$globalvar $localvar' )
        assert cmd.asShellString( shell=False ) == "ls 'glob/value loc/value'"

        cmd = Command().raw( 'ls', '$globalvar $localvar' )
        assert cmd.asShellString( shell=False ) == "ls '$globalvar $localvar'"

        cmd = Command().escape( 'ls', '$globalvar $localvar' )
        assert cmd.asShellString( shell=False ) == "ls '$globalvar $localvar'"

    def test_substituting_environment_variables(self):
        ""
        cmd = Command( 'hello $SHELL' )
        assert cmd.asShellString(shell=True) == 'hello '+os.environ['SHELL']

        cmd = Command().arg( 'hello', '$SHELL' )
        assert cmd.asShellString(shell=True) == 'hello '+os.environ['SHELL']

        cmd = Command().raw( 'hello', '$SHELL' )
        assert cmd.asShellString(shell=True) == 'hello $SHELL'

        cmd = Command().escape( 'hello', '$SHELL' )
        assert cmd.asShellString(shell=True) == "hello '$SHELL'"

        os.environ['UNIT_TEST_VAR'] = 'unit test value'

        # whitespace expansion should happen after variable substitution
        cmd = Command( 'hello $UNIT_TEST_VAR' )
        assert cmd.asShellString(shell=True) == 'hello unit test value'

        cmd = Command().arg( 'hello', '$UNIT_TEST_VAR' )
        assert cmd.asShellString(shell=True) == 'hello unit\\ test\\ value'


def open_write_close_RedirectToFilename( filename, data ):
    ""
    redir = command.RedirectToFilename( filename )
    fd = redir.open()
    os.write( fd, util._BYTES_(data) )
    redir.close()


def streams_write( streams, to_stdout, to_stderr ):
    ""
    ofd = streams.openStdout()
    efd = streams.openStderr()

    if to_stdout: os.write( ofd, util._BYTES_(to_stdout) )
    if to_stderr: os.write( efd, util._BYTES_(to_stderr) )

    streams.close()
    time.sleep(1)

    return ofd, efd


class redirection_tests( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

    def test_subproc_without_redirection(self):
        ""
        streams = command.SubprocessStreams( None, None, None )
        assert streams.openStdout() == None
        assert streams.openStderr() == None
        streams.close()  # check no exception occurs

    def test_redirecting_to_a_filename(self):
        ""
        open_write_close_RedirectToFilename( 'file.log', 'hello world\n' )
        time.sleep(1)
        assert util.readfile('file.log') == 'hello world\n'

        open_write_close_RedirectToFilename( '>>file.log', 'goodbye now\n' )
        time.sleep(1)
        assert util.readfile('file.log') == 'hello world\ngoodbye now\n'

        open_write_close_RedirectToFilename( 'file.log', 'this data rules\n' )
        time.sleep(1)
        assert util.readfile('file.log') == 'this data rules\n'

        self.assertRaises( Exception, command.RedirectToFilename, '>>' )

    def test_redirect_to_an_open_file_descriptor(self):
        ""
        fp = open( 'file.log', 'w' )
        fp.write( 'hello world\n' )
        fp.flush()
        obj = command.RedirectToFileDescriptor( fp.fileno() )
        fd = obj.open()
        assert fd == fp.fileno()
        os.write( fd, util._BYTES_('goodbye now\n') )
        obj.close()
        fp.write( 'no, really\n' )
        fp.close()
        time.sleep(1)

        data = util.readfile( 'file.log' )
        assert data == 'hello world\ngoodbye now\nno, really\n'

    def test_specify_one_of_redirect_or_stdout_or_stderr(self):
        ""
        streams = command.SubprocessStreams( 'file1.txt', None, None )
        ofd,efd = streams_write( streams, 'to stdout\n', None )
        assert efd == subprocess.STDOUT
        assert util.readfile('file1.txt') == 'to stdout\n'

        streams = command.SubprocessStreams( None, 'file2.txt', None )
        ofd,efd = streams_write( streams, 'to stdout\n', None )
        assert efd == None
        assert util.readfile('file2.txt') == 'to stdout\n'

        streams = command.SubprocessStreams( None, None, 'file3.txt' )
        ofd,efd = streams_write( streams, None, 'to stderr\n' )
        assert ofd == None
        assert util.readfile('file3.txt') == 'to stderr\n'

    def test_specify_stdout_and_stderr(self):
        ""
        streams = command.SubprocessStreams( None, 'file1.txt', 'file2.txt' )
        ofd,efd = streams_write( streams, 'to stdout\n', 'to stderr\n' )
        assert util.readfile('file1.txt') == 'to stdout\n'
        assert util.readfile('file2.txt') == 'to stderr\n'

        fp = open( 'file4.txt', 'w' )
        streams = command.SubprocessStreams( None, 'file3.txt', fp.fileno() )
        ofd,efd = streams_write( streams, 'to stdout\n', 'to stderr\n' )
        fp.close()
        assert util.readfile('file3.txt') == 'to stdout\n'
        assert util.readfile('file4.txt') == 'to stderr\n'

        fp = open( 'file5.txt', 'w' )
        streams = command.SubprocessStreams( None, fp.fileno(), 'file6.txt' )
        ofd,efd = streams_write( streams, 'to stdout\n', 'to stderr\n' )
        fp.close()
        assert util.readfile('file5.txt') == 'to stdout\n'
        assert util.readfile('file6.txt') == 'to stderr\n'

    def test_specify_redirect_and_stdout_stderr(self):
        ""
        fp = open( 'file.txt', 'w' )
        streams = command.SubprocessStreams( fp.fileno(), None, None )
        ofd,efd = streams_write( streams, 'to stdout\n', None )
        assert efd == subprocess.STDOUT
        fp.close()
        assert util.readfile('file.txt') == 'to stdout\n'

        fp1 = open( 'file1.txt', 'w' )
        fp2 = open( 'file2.txt', 'w' )
        streams = command.SubprocessStreams( fp1.fileno(), None, fp2.fileno() )
        ofd,efd = streams_write( streams, 'to stdout\n', 'to stderr\n' )
        fp1.close()
        fp2.close()
        assert util.readfile('file1.txt') == 'to stdout\n'
        assert util.readfile('file2.txt') == 'to stderr\n'

        streams = command.SubprocessStreams( 'file4.txt', 'file3.txt', None )
        ofd,efd = streams_write( streams, 'to stdout\n', None )
        assert efd == subprocess.STDOUT
        assert util.readfile('file3.txt') == 'to stdout\n'
        assert not os.path.exists( 'file4.txt' )

        streams = command.SubprocessStreams( 'file5.txt', None, 'file6.txt' )
        ofd,efd = streams_write( streams, 'to stdout\n', 'to stderr\n' )
        assert util.readfile('file5.txt') == 'to stdout\n'
        assert util.readfile('file6.txt') == 'to stderr\n'


class echo_tests( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

    def test_using_CommandNoEcho(self):
        ""
        out = run_echo( command.CommandNoEcho, postexec=1 )
        assert not out

    def test_using_CommandEcho(self):
        ""
        out = run_echo( command.CommandEcho, 'my command', postexec=1 )
        assert out == 'my command\n'

        # command must be a string
        self.assertRaises( Exception, command.CommandEcho, ['my','command'] )

    def test_using_CommandLogging(self):
        ""
        out = run_echo( command.CommandLogging,
                        'my command', None, None, postexec=1 )
        lines = extract_log_lines( out )
        assert len(lines) == 2

        # check first log line
        assert lines[0][1] == 'runcmd'
        L = lines[0][2]
        assert 'dir='+os.getcwd() in L
        assert 'cmd=my command' in L
        sL = list( filter( lambda s: s.startswith('start='), L ) )
        assert len(sL) == 1
        startid = sL[0]

        # check second log line
        assert lines[1][1] == 'return'
        L = lines[1][2]
        assert startid in L
        assert 'exit=1' in L
        assert 'cmd=my command' in L

        # add in a chdir argument

        os.mkdir( 'tmpdir' )
        time.sleep(1)

        out = run_echo( command.CommandLogging,
                        'my command', None, None, chdir='tmpdir' )
        lines = extract_log_lines( out )
        assert len(lines) == 2

        # check first log line
        assert lines[0][1] == 'runcmd'
        L = lines[0][2]
        assert 'dir='+os.path.abspath('tmpdir') in L
        assert 'cmd=my command' in L
        sL = list( filter( lambda s: s.startswith('start='), L ) )
        assert len(sL) == 1
        startid = sL[0]

        # check second log line
        assert lines[1][1] == 'return'
        L = lines[1][2]
        assert startid in L
        assert 'exit=None' in L
        assert 'cmd=my command' in L

        # add in a logfile argument

        out = run_echo( command.CommandLogging,
                        'my command', 'logname', None )
        lines = extract_log_lines( out )
        assert len(lines) == 2

        # check first log line
        assert lines[0][1] == 'runcmd'
        L = lines[0][2]
        assert 'dir='+os.getcwd() in L
        assert 'cmd=my command' in L
        assert 'logfile=logname' in L
        sL = list( filter( lambda s: s.startswith('start='), L ) )
        assert len(sL) == 1
        startid = sL[0]

        # check second log line
        assert lines[1][1] == 'return'
        L = lines[1][2]
        assert startid in L
        assert 'exit=None' in L
        assert 'cmd=my command' in L

        # absolute path logfile argument

        abslogf = os.path.abspath('logname')
        out = run_echo( command.CommandLogging,
                        'my command', abslogf, None )
        lines = extract_log_lines( out )
        assert len(lines) == 2

        # check first log line
        assert lines[0][1] == 'runcmd'
        L = lines[0][2]
        assert 'dir='+os.getcwd() in L
        assert 'cmd=my command' in L
        assert 'logfile='+abslogf in L
        sL = list( filter( lambda s: s.startswith('start='), L ) )
        assert len(sL) == 1
        startid = sL[0]

        # check second log line
        assert lines[1][1] == 'return'
        L = lines[1][2]
        assert startid in L
        assert 'exit=None' in L
        assert 'cmd=my command' in L

        # adding a timeout

        out = run_echo( command.CommandLogging,
                        'my command', None, None, postexec=1 )
        lines = extract_log_lines( out )
        assert len(lines) == 2
        L = list( filter( lambda x: str(x).startswith('timeout='), lines[0][2] ) )
        assert len(L) == 0
        L = list( filter( lambda x: str(x).startswith('timeout='), lines[1][2] ) )
        assert len(L) == 0

        out = run_echo( command.CommandLogging,
                        'my command', None, 1.2, postexec=1 )
        lines = extract_log_lines( out )
        assert len(lines) == 2
        L = list( filter( lambda x: str(x).startswith('timeout='), lines[0][2] ) )
        assert len(L) == 1
        assert L[0].startswith('timeout=1.2')
        L = list( filter( lambda x: str(x).startswith('timeout='), lines[1][2] ) )
        assert len(L) == 0

    def test_constructing_an_echo_object(self):
        ""
        obj = command.construct_echo_object( 'echo', 'shell command', None )
        assert isinstance( obj, command.CommandEcho )

        obj = command.construct_echo_object( 'log', 'shell command', None )
        assert isinstance( obj, command.CommandLogging )

        obj = command.construct_echo_object( 'log', 'shell command', 1.2 )
        assert isinstance( obj, command.CommandLogging )

        obj = command.construct_echo_object( 'none', 'shell command', None )
        assert isinstance( obj, command.CommandNoEcho )

        obj = command.construct_echo_object( None, 'shell command', None )
        assert isinstance( obj, command.CommandNoEcho )


def run_echo( cmd_type, *logging_args, **kwargs ):
    ""
    cd = kwargs.get( 'chdir', None )

    redir = util.RedirectStdout( 'stdout.log' )
    try:

        if cd:
            cwd = os.getcwd()
            os.chdir( cd )

        echo = cmd_type( *logging_args )
        echo.preExecute()
        echo.postExecute( kwargs.get( 'postexec', None ) )

    finally:
        redir.close()
        if cd:
            os.chdir( cwd )

    time.sleep(1)

    return util.readfile( 'stdout.log' )


class directory_swapping( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

    def test_the_SwapDirectory_class(self):
        ""
        swap_dirs( None )

        # an empty string behaves same as None
        swap_dirs( '' )

        # change to subdirectory
        os.mkdir( 'tmpdir' )
        time.sleep(1)
        swap_dirs( 'tmpdir' )

        # change to bad directory raises an Exception
        d = os.getcwd()
        self.assertRaises( Exception, command.SwapDirectory,
                           'existentialcrisis' )
        assert os.getcwd() == d

        # skip this test if user expansion fails
        home = os.path.expanduser( '~' )
        if home != '~' and os.path.exists(home):
            # expand user is applied to path
            swap_dirs( '~' )


def swap_dirs( todir ):
    ""
    cwd = os.getcwd()

    try:
        if todir:
            toabs = os.path.abspath( os.path.expanduser(todir) )
        else:
            toabs = cwd

        cd = command.SwapDirectory( todir )
        assert os.getcwd() == toabs

        cd.swapBack()
        assert os.getcwd() == cwd

    except Exception:
        os.chdir( cwd )


class making_commands( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

    def test_getCommands_with_no_shell_expansion(self):
        ""
        cmd = Command( sys.executable, 'args1' )
        py,sh = cmd.getCommands( False )
        check_commands( py, sh, 'args1' )

        cmd = Command( sys.executable, 'args2', '-s', 'foo' )
        py,sh = cmd.getCommands( False )
        check_commands( py, sh, 'args2', '-s', 'foo' )

        cmd = Command( sys.executable, 'args3', '~', '*' )
        py,sh = cmd.getCommands( False )
        check_commands( py, sh, 'args3', '~', '*' )

    def test_getCommands_with_shell_expansion(self):
        ""
        cmd = Command( sys.executable, 'args1' )
        py,sh = cmd.getCommands( True, None, None )
        check_commands( py, sh, 'args1' )

        cmd = Command( sys.executable, 'args2', '-s', 'foo' )
        py,sh = cmd.getCommands( True, None, None )
        check_commands( py, sh, 'args2', '-s', 'foo' )

        # write two files to test globbing
        util.writefile( 'file1.ext', 'foo\n' )
        util.writefile( 'file2.ext', 'bar\n' )
        time.sleep(1)

        cmd = Command( sys.executable, 'args3', '~', 'file*.ext' )
        py,sh = cmd.getCommands( True, None, None )
        check_commands( py, sh, 'args3',
                        os.path.expanduser('~'), 'file1.ext', 'file2.ext' )

        cmd = Command( sys.executable, 'args4' ).escape( 'file*.ext' )
        py,sh = cmd.getCommands( True, None, None )
        check_commands( py, sh, 'args4', 'file*.ext' )

    def test_getCommands_using_ssh_and_no_shell_expansion(self):
        ""
        sshprog,sshmach = get_ssh_pair()

        cmd = Command( sys.executable, os.path.abspath('args1') )
        py,sh = cmd.getCommands( False, sshmach, sshprog )
        check_commands( py, sh, 'args1' )

        cmd = Command( sys.executable, os.path.abspath('args2'), '-s', 'foo' )
        py,sh = cmd.getCommands( False, sshmach, sshprog )
        check_commands( py, sh, 'args2', '-s', 'foo' )

        cmd = Command( sys.executable, os.path.abspath('args3'), '~', '*' )
        py,sh = cmd.getCommands( False, sshmach, sshprog )
        check_commands( py, sh, 'args3', '~', '*' )

    def test_getCommands_using_ssh_and_shell_expansion(self):
        ""
        sshprog,sshmach = get_ssh_pair()

        cmd = Command( sys.executable, os.path.abspath('args1') )
        py,sh = cmd.getCommands( True, sshmach, sshprog )
        check_commands( py, sh, 'args1' )

        cmd = Command( sys.executable, os.path.abspath('args2'), '-s', 'foo' )
        py,sh = cmd.getCommands( True, sshmach, sshprog )
        check_commands( py, sh, 'args2', '-s', 'foo' )

        # write two files to test globbing
        util.writefile( 'file1.ext', 'foo\n' )
        util.writefile( 'file2.ext', 'bar\n' )
        time.sleep(1)

        # note that this test is not perfect because the ssh is either faked or
        # the machine is the current machine, and therefore it is impossible to
        # know for sure that the globbing is occuring by the local shell or the
        # remote shell
        cmd = Command( sys.executable, os.path.abspath('args3'),
                       '~', os.path.abspath('file*.ext') )
        py,sh = cmd.getCommands( True, sshmach, sshprog )
        check_commands( py, sh, 'args3',
                        os.path.expanduser('~'),
                        os.path.abspath('file1.ext'),
                        os.path.abspath('file2.ext') )

        cmd = Command( sys.executable, os.path.abspath('args4')
                     ).escape( os.path.abspath('file*.ext') )
        py,sh = cmd.getCommands( True, sshmach, sshprog )
        check_commands( py, sh, 'args4', os.path.abspath('file*.ext') )


def check_commands( pycmd, shcmd, pyscript, *args ):
    """
    Checks the output from Command.getCommands() by executing the
    pair of commands it returns (the one meant for subprocess and the one
    for a shell).

    1. The command that produced 'pycmd' and 'shcmd' must execute ./pyscript

    2. The given arguments, 'args', are written into pyscript and checked
       against sys.argv[1:] upon execution
    """
    args = list(args)

    # the program to run is written as a python script;  it checks the args
    util.writefile( pyscript, """
        import sys, os
        if sys.argv[1:] != """+repr(args)+""":
            raise Exception( 'bad args: '+str(sys.argv[1:]) )
        """ )

    # to test the shell command, embed it in a shell script
    shscript = os.path.abspath( pyscript+'.sh' )
    util.writescript( shscript, """
        #!/bin/sh
        echo shcmd: """+shcmd+"""
        """+shcmd+""" || exit 1
        """ )

    time.sleep(1)

    # run the python command using subprocess
    if type(pycmd) == type(''):
        print3( 'pycmd:', repr(pycmd) )
        assert subprocess.call( pycmd, shell=True ) == 0
    else:
        print3( 'pycmd:', pycmd )
        assert subprocess.call( pycmd, shell=False ) == 0

    # run the shell command by executing the shell script helper
    assert subprocess.call( [ shscript ], shell=False ) == 0


class dryrun_testing( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

    def test_CommandDryRun_class(self):
        ""
        dr = command.CommandDryRun()
        assert dr.runIt()
        assert dr.runIt( '/hello/world -a foo' )
        assert dr.runIt( ['/hello/world','-a','foo'] )

        os.environ['COMMAND_DRYRUN'] = '1'
        dr = command.CommandDryRun()
        assert not dr.runIt()
        assert not dr.runIt( '/hello/world -a foo' )
        assert not dr.runIt( ['/hello/world','-a','foo'] )

        os.environ['COMMAND_DRYRUN'] = ' '
        dr = command.CommandDryRun()
        assert not dr.runIt()
        assert not dr.runIt( '/hello/world -a foo' )
        assert not dr.runIt( ['/hello/world','-a','foo'] )

        os.environ['COMMAND_DRYRUN'] = 'hello'
        dr = command.CommandDryRun()
        assert not dr.runIt()
        assert not dr.runIt( '/hello/world -a foo' )
        assert not dr.runIt( ['/hello/world','-a','foo'] )

        os.environ['COMMAND_DRYRUN'] = 'world'
        dr = command.CommandDryRun()
        assert not dr.runIt()
        assert dr.runIt( '/hello/world -a foo' )
        assert dr.runIt( ['/hello/world','-a','foo'] )

        os.environ['COMMAND_DRYRUN'] = 'foo/bar'
        dr = command.CommandDryRun()
        assert not dr.runIt()
        assert not dr.runIt( '/hello/world -a foo' )
        assert not dr.runIt( ['/hello/world','-a','foo'] )

        os.environ['COMMAND_DRYRUN'] = 'world/bar'
        dr = command.CommandDryRun()
        assert not dr.runIt()
        assert dr.runIt( '/hello/world -a foo' )
        assert dr.runIt( ['/hello/world','-a','foo'] )

        os.environ['COMMAND_DRYRUN'] = 'foo/world'
        dr = command.CommandDryRun()
        assert not dr.runIt()
        assert dr.runIt( '/hello/world -a foo' )
        assert dr.runIt( ['/hello/world','-a','foo'] )

        os.environ['COMMAND_DRYRUN'] = 'foo/world'
        dr = command.CommandDryRun()
        assert not dr.runIt()
        assert dr.runIt( '/hello/world -a foo' )
        assert dr.runIt( ['/hello/foo','-a','foo'] )


class MockEcho:
    def preExecute(self): pass
    def postExecute(self, x): pass

class MockStreams:
    def openStdout(self): return None
    def openStderr(self): return None
    def close(self): pass


class run_command( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

        if 'COMMAND_DRYRUN' in os.environ:
            del os.environ['COMMAND_DRYRUN']

    def test_nominal_use(self):
        ""
        cmd = sys.executable + ' -c "fp=open(\'foo.txt\',\'w\'); fp.close()"'
        runr = command.SubprocessRunner( cmd, None, MockStreams(), MockEcho() )
        runr.runCommand()
        time.sleep(1)
        assert os.path.exists( 'foo.txt' )

        cmd = [ sys.executable, '-c', 'fp=open("bar.txt","w"); fp.close()' ]
        runr = command.SubprocessRunner( cmd, None, MockStreams(), MockEcho() )
        runr.runCommand()
        time.sleep(1)
        assert os.path.exists( 'bar.txt' )

        cmd = Command( sys.executable )
        cmd.escape( '-c', 'fp=open("baz.txt","w"); fp.close()' )
        cmd.run()
        assert os.path.exists( 'baz.txt' )

        cmd = Command( sys.executable )
        cmd.arg( '-c', 'fp=open("fore.txt","w"); fp.close()' )
        cmd.run( shell=False )
        assert os.path.exists( 'fore.txt' )

    def test_using_echo_variations(self):
        ""
        # first check without echo
        cmd = [ sys.executable, '-c',
                'import os,sys; sys.stdout.write("hello"+os.linesep); ' + \
                'sys.stderr.write("world"+os.linesep);' ]
        runr = command.SubprocessRunner( cmd, None, MockStreams(), MockEcho() )
        rtn,out,err = util.call_capture_output( runr.runCommand )

        assert out == 'hello\n' and err == 'world\n'

        echo = command.construct_echo_object( "echo", ' '.join(cmd), None )
        runr = command.SubprocessRunner( cmd, None, MockStreams(), echo )
        rtn,out,err = util.call_capture_output( runr.runCommand )

        L = util.greplines( 'sys.stdout', out )
        assert len(L) == 1
        L = util.greplines( 'hello', out )
        assert len(L) == 2
        assert L[1].strip() == 'hello'
        assert err == 'world\n'

        cmd = Command( sys.executable, '-c' )
        cmd.escape( 'import os,sys; sys.stdout.write("hello"+os.linesep); ' + \
                    'sys.stderr.write("world"+os.linesep);' )
        rtn,out,err = util.call_capture_output( cmd.run )

        L = util.greplines( 'sys.stdout', out )
        assert len(L) == 1
        L = util.greplines( 'hello', out,  )
        assert len(L) == 2
        assert L[1].strip() == 'hello'
        assert err == 'world\n'

        cmd = Command( sys.executable, '-c' )
        cmd.escape( 'import os,sys; sys.stdout.write("hello"+os.linesep); ' + \
                    'sys.stderr.write("world"+os.linesep);' )
        rtn,out,err = util.call_capture_output( cmd.run, echo="none" )

        L = util.greplines( 'sys.stdout', out )
        assert len(L) == 0
        assert out == 'hello\n' and err == 'world\n'

    def test_redirection_streams(self):
        ""
        # first check without streams
        cmd = [ sys.executable, '-c',
                'import os,sys; sys.stdout.write("hello"+os.linesep); ' + \
                'sys.stderr.write("world"+os.linesep);' ]
        runr = command.SubprocessRunner( cmd, None, MockStreams(), MockEcho() )
        rtn,out,err = util.call_capture_output( runr.runCommand )

        assert out == 'hello\n' and err == 'world\n'

        streams = command.SubprocessStreams( 'redir.log', None, None )
        runr = command.SubprocessRunner( cmd, None, streams, MockEcho() )
        rtn,out,err = util.call_capture_output( runr.runCommand )

        assert not out.strip() and not err.strip()
        L = util.grepfiles( 'hello', 'redir.log' )
        assert len(L) == 1 and L[0].strip() == 'hello'
        L = util.grepfiles( 'world', 'redir.log' )
        assert len(L) == 1 and L[0].strip() == 'world'

        cmd = Command( sys.executable, '-c' )
        cmd.escape( 'import os,sys; sys.stdout.write("hello"+os.linesep); ' + \
                    'sys.stderr.write("world"+os.linesep);' )
        rtn,out,err = util.call_capture_output( cmd.run,
                                                echo="none",
                                                redirect="redir3.log" )

        assert not out.strip() and not err.strip()
        L = util.grepfiles( 'hello', 'redir3.log' )
        assert len(L) == 1 and L[0].strip() == 'hello'
        L = util.grepfiles( 'world', 'redir3.log' )
        assert len(L) == 1 and L[0].strip() == 'world'

    def test_command_failures(self):
        ""
        runr = command.SubprocessRunner( '/path/junk',
                                         None, MockStreams(), MockEcho() )
        x,out,err = util.call_capture_output( runr.runCommand,
                                              raise_on_error=False )
        assert x != 0 and x != None
        assert err.strip() and 'CommandException' not in err

        runr = command.SubprocessRunner( '/path/junk',
                                         None, MockStreams(), MockEcho() )
        x,out,err = util.call_capture_output( runr.runCommand,
                                              raise_on_error=False )
        assert x != 0 and x != None
        assert err.strip() and 'CommandException' not in err

        runr = command.SubprocessRunner( '/path/junk',
                                         None, MockStreams(), MockEcho() )
        expect_CommandException( runr.runCommand, raise_on_error=True )

        # as a python list, the subprocess.Popen() call will raise exception
        runr = command.SubprocessRunner( ['/path/junk'],
                                         None, MockStreams(), MockEcho() )
        x,out,err = util.call_capture_output( runr.runCommand,
                                              raise_on_error=False )
        assert x != 0 and x != None
        assert err.strip() and 'CommandException' not in err

        runr = command.SubprocessRunner( ['/path/junk'],
                                         None, MockStreams(), MockEcho() )
        expect_CommandException( runr.runCommand, raise_on_error=True )

        cmd = [ sys.executable, '-c', 'raise Exception("fake exception")' ]
        runr = command.SubprocessRunner( cmd, None, MockStreams(), MockEcho() )
        x,out,err = util.call_capture_output( runr.runCommand,
                                              raise_on_error=False )
        assert x != 0 and x != None
        assert err.strip() and 'CommandException' not in err

        expect_CommandException( runr.runCommand, raise_on_error=True )

        cmd = Command( '/path/junk' )
        x,out,err = util.call_capture_output( cmd.run,
                                              raise_on_error=False )
        assert x != 0 and x != None
        assert err.strip() and 'CommandException' not in err

        expect_CommandException( cmd.run, raise_on_error=True )

        # redirect error
        cmd = Command( sys.executable, '-c' )
        cmd.escape( 'import os' )
        x,out,err = util.call_capture_output( cmd.run,
                                         redirect='/path/noexist/foobar.log',
                                         raise_on_error=False )
        assert x != 0 and x != None
        assert err.strip() and 'CommandException' not in err

        expect_CommandException( cmd.run, redirect='/path/noexist/foobar.log',
                                          raise_on_error=True )

        # change directory error
        cmd = Command( sys.executable, '-c' )
        cmd.escape( 'import os' )
        x,out,err = util.call_capture_output( cmd.run, chdir='/path/noexist',
                                                       raise_on_error=False )
        assert x != 0 and x != None
        assert err.strip() and 'CommandException' not in err

        expect_CommandException( cmd.run, chdir='/path/noexist',
                                          raise_on_error=True )

    def test_using_runit_argument(self):
        ""
        runr = command.SubprocessRunner( '/path/junk',
                                         None, MockStreams(), MockEcho() )
        x = runr.runCommand( runit=False )
        assert x == 0

        runr = command.SubprocessRunner( ['/path/junk'],
                                         None, MockStreams(), MockEcho() )
        x = runr.runCommand( runit=False )
        assert x == 0

        cmd = [ sys.executable, '-c', 'raise Exception("fake exception")' ]
        runr = command.SubprocessRunner( cmd, None, MockStreams(), MockEcho() )
        x = runr.runCommand( runit=False )
        assert x == 0

        cmd = Command( sys.executable, '-c' )
        cmd.escape( 'raise Exception("fake exception")' )
        os.environ['COMMAND_DRYRUN'] = '1'
        x = cmd.run()
        assert x == 0

    def test_using_chdir(self):
        ""
        os.mkdir( 'rundir' )
        time.sleep(1)

        cwd = os.getcwd()
        cmd = Command( sys.executable )
        cmd.arg( '-c', 'fp=open("foo.txt","w"); fp.close()' )
        cmd.run( shell=False, chdir='rundir' )
        time.sleep(1)
        assert os.getcwd() == cwd
        assert os.path.exists( 'rundir/foo.txt' )

        # even with an exception, the final directory should not change
        cmd = Command( '/path/junk' )
        expect_CommandException( cmd.run, shell=False,
                                          raise_on_error=True )
        assert os.getcwd() == cwd


class run_output_command( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

        if 'COMMAND_DRYRUN' in os.environ:
            del os.environ['COMMAND_DRYRUN']

    def test_OutputSubprocessRunner_utility(self):
        ""
        cmd = sys.executable + ' -c ' + \
                '''"import os,sys;''' + \
                '''sys.stdout.write('hello'+os.linesep); sys.stdout.flush();''' + \
                '''sys.stderr.write('world'+os.linesep); sys.stderr.flush()"'''

        ech = MockEcho()

        streams = command.SubprocessStreams( None, None, None )
        runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
        rtn,out,err = util.call_capture_output( runr.runCommand )
        assert not rtn.strip()
        assert out.strip() == 'hello' and err.strip() == 'world'

        streams = command.SubprocessStreams( None, None, None, capture=None )
        runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
        rtn,out,err = util.call_capture_output( runr.runCommand )
        assert not rtn.strip()
        assert out.strip() == 'hello' and err.strip() == 'world'

        streams = command.SubprocessStreams( None, None, None, capture='stdout' )
        runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
        rtn,out,err = util.call_capture_output( runr.runCommand )
        assert rtn == 'hello\n'
        assert not out.strip() and err.strip() == 'world'

        streams = command.SubprocessStreams( None, None, None, capture='stdouterr' )
        runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
        rtn,out,err = util.call_capture_output( runr.runCommand )
        assert 'hello' in rtn and 'world' in rtn
        assert not out.strip() and not err.strip()

    def test_OutputSubprocessRunner_mixed_with_redirects(self):
        ""
        cmd = sys.executable + ' -c ' + \
                '''"import os,sys;''' + \
                '''sys.stdout.write('hello'+os.linesep); sys.stdout.flush();''' + \
                '''sys.stderr.write('world'+os.linesep); sys.stderr.flush()"'''

        ech = MockEcho()

        # capture takes precedence
        streams = command.SubprocessStreams( None, 'ofile1.txt', None,
                                             capture="stdout" )
        runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
        rtn,out,err = util.call_capture_output( runr.runCommand )
        assert rtn.strip() == 'hello'
        assert not out.strip() and err.strip() == 'world'
        assert not os.path.exists('ofile1.txt')

        streams = command.SubprocessStreams( None, None, 'efile2.txt',
                                             capture="stdout" )
        runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
        rtn,out,err = util.call_capture_output( runr.runCommand )
        assert rtn.strip() == 'hello'
        assert not out.strip()
        assert util.readfile('efile2.txt').strip() == 'world'

        streams = command.SubprocessStreams( None, 'ofile3.txt', None,
                                             capture="stderr" )
        runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
        rtn,out,err = util.call_capture_output( runr.runCommand )
        assert rtn.strip() == 'world'
        assert not out.strip() and not err.strip()
        assert util.readfile('ofile3.txt').strip() == 'hello'

        streams = command.SubprocessStreams( None, None, 'efile4.txt',
                                             capture="stderr" )
        runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
        rtn,out,err = util.call_capture_output( runr.runCommand )
        assert rtn.strip() == 'world'
        assert out.strip() == 'hello' and not err.strip()
        assert not os.path.exists( 'efile4.txt' )

        streams = command.SubprocessStreams( None, 'ofile5.txt', None,
                                             capture="stdouterr" )
        runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
        rtn,out,err = util.call_capture_output( runr.runCommand )
        assert 'hello' in rtn and 'world' in rtn
        assert not out.strip() and not err.strip()
        assert not os.path.exists('ofile5.txt')

        streams = command.SubprocessStreams( None, None, 'efile6.txt',
                                             capture="stdouterr" )
        runr = command.OutputSubprocessRunner( cmd, None, streams, ech )
        rtn,out,err = util.call_capture_output( runr.runCommand )
        assert 'hello' in rtn and 'world' in rtn
        assert not out.strip() and not err.strip()
        assert not os.path.exists( 'efile6.txt' )

    def test_run_with_output_capturing(self):
        ""
        cmd = Command( sys.executable, '-c' )
        cmd.escape(
            "import os,sys;" + \
            "sys.stdout.write('hello'+os.linesep); sys.stdout.flush();" + \
            "sys.stderr.write('world'+os.linesep); sys.stderr.flush()" )

        rtn,out,err = util.call_capture_output( cmd.run_output )
        assert rtn.strip() == 'hello'
        assert 'hello' in out  # the command gets echoed
        assert err.strip() == 'world'

        rtn,out,err = util.call_capture_output( cmd.run_output, 'stdout' )
        assert rtn.strip() == 'hello'
        assert 'hello' in out and err.strip() == 'world'

        rtn,out,err = util.call_capture_output( cmd.run_output, capture='stdout' )
        assert rtn.strip() == 'hello'
        assert 'hello' in out and err.strip() == 'world'

        rtn,out,err = util.call_capture_output( cmd.run_output, 'stderr' )
        assert rtn.strip() == 'world'
        assert 'hello' in out and not err.strip()

        rtn,out,err = util.call_capture_output( cmd.run_output, 'stdouterr' )
        assert 'hello' in rtn.strip() and 'world' in rtn.strip()
        assert 'hello' in out and not err.strip()

    def test_excercising_run_output_options(self):
        ""
        sshprog,sshmach = get_ssh_pair()
        os.mkdir( 'temp' )
        time.sleep(1)

        cmd = Command( sys.executable, '-c' )
        cmd.escape(
            "import os,sys;" + \
            "sys.stderr.write(os.getcwd()+os.linesep); sys.stderr.flush()" )

        rtn,out,err = util.call_capture_output( cmd.run_output,
                                                capture="stderr",
                                                chdir='temp', echo="none" )
        assert os.path.basename( rtn.strip() ) == 'temp'
        assert os.path.basename( os.getcwd() ) != 'temp'
        assert not out.strip() and not err.strip()

        cmd = Command( sys.executable, '-c' )
        cmd.arg(
            "import os,sys;" + \
            "sys.stderr.write('foobarbaz'+os.linesep); sys.stderr.flush()" )

        rtn,out,err = util.call_capture_output( cmd.run_output,
                                                capture="stderr",
                                                shell=False,
                                                machine=sshmach,
                                                sshexe=sshprog )
        assert 'foobarbaz' in rtn.strip()
        assert 'flush' in out and not err.strip()

        cmd = Command( sys.executable, '-c' )
        cmd.arg( "raise Exception('fake error')" )

        expect_CommandException( cmd.run_output, capture="stderr",
                                                 shell=False,
                                                 raise_on_error=True )


def expect_CommandException( func, *args, **kwargs ):
    ""
    rtn,out,err = util.call_capture_output( func, *args, **kwargs )
    assert rtn == None
    assert 'Traceback' in err and 'CommandException' in err


class run_timeout_command( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

        if 'COMMAND_DRYRUN' in os.environ:
            del os.environ['COMMAND_DRYRUN']

    def test_compute_timeout_value_function(self):
        ""
        self.assertRaises( Exception, command.compute_timeout_value, None, None )

        command.compute_timeout_value( '2', None )
        command.compute_timeout_value( None, '3' )
        command.compute_timeout_value( '2.1', None )
        command.compute_timeout_value( None, '3.2' )

        t = command.compute_timeout_value( 5, None )
        assert abs( t - 5 ) < 1

        t = command.compute_timeout_value( 5.5, None )
        assert abs( t - 5.5 ) < 1

        t = command.compute_timeout_value( '5.5', None )
        assert abs( t - 5.5 ) < 1

        t = command.compute_timeout_value( -5, None )
        assert t > 0 and t < 1

        d = time.time() + 10
        t = command.compute_timeout_value( None, d )
        assert abs( t - 10 ) < 2

        d = time.time() - 10
        t = command.compute_timeout_value( None, d )
        assert t > 0 and t < 1

        d = time.time() + 10
        t = command.compute_timeout_value( 10, d )
        assert abs( t - 10 ) < 2

        d = time.time() + 20
        t = command.compute_timeout_value( 10, d )
        assert abs( t - 10 ) < 2

        d = time.time() + 10
        t = command.compute_timeout_value( 20, d )
        assert abs( t - 10 ) < 2

        d = time.time() + 10
        t = command.compute_timeout_value( -10, d )
        assert t > 0 and t < 1

    def test_killing_a_subprocess(self):
        ""
        cwd = os.getcwd()

        write_sub_helper()

        # first, check running a subprocess

        write_sub_script( 'sub1.py', 1 )
        time.sleep(1)

        ksp = command.KillableSubprocess( [sys.executable,'sub1.py'] )
        time.sleep(3)
        assert ksp.checkIfDone(1)
        assert ksp.getSubproc().returncode == 0
        assert len( util.grepfiles( 'START', 'sub1.log' ) ) == 1
        assert len( util.grepfiles( 'DONE', 'sub1.log' ) ) == 1

        # next, timeout a subprocess

        write_sub_script( 'sub2.py', 20 )
        time.sleep(1)

        ksp = command.KillableSubprocess( [sys.executable,'sub2.py'] )
        time.sleep(2)
        t0 = time.time()
        assert not ksp.checkIfDone(1)
        ksp.kill( signal.SIGTERM, signal.SIGKILL )
        t1 = time.time()
        assert t1 - t0 < 6
        assert len( util.grepfiles( 'START', 'sub2.log' ) ) == 1
        assert len( util.grepfiles( 'DONE', 'sub2.log' ) ) == 0

    def test_kill_a_subprocess_that_runs_a_subprocess(self):
        ""
        cwd = os.getcwd()

        write_sub_helper()

        write_sub_script( 'sub1.py', 1, 'sub2.py' )
        write_sub_script( 'sub2.py', 20 )

        time.sleep(1)

        ksp = command.KillableSubprocess( [sys.executable,'sub1.py'] )
        time.sleep(2)

        plist1 = trigutil.get_process_list()

        t0 = time.time()
        assert not ksp.checkIfDone(1)
        ksp.kill( signal.SIGTERM, signal.SIGKILL )
        t1 = time.time()
        time.sleep(1)

        plist2 = trigutil.get_process_list()

        assert t1 - t0 < 6
        L = util.grepfiles( 'START', 'sub1.log' )
        assert len(L) == 1
        pid1 = int( L[0].split()[1] )

        L = util.grepfiles( 'START', 'sub2.log' )
        assert len(L) == 1
        pid2 = int( L[0].split()[1] )
        assert pid2 != pid1

        assert len( util.grepfiles( 'DONE', 'sub1.log' ) ) == 0
        assert len( util.grepfiles( 'DONE', 'sub2.log' ) ) == 0

        assert trigutil.find_process_in_list( plist1, pid1 ) != None
        assert trigutil.find_process_in_list( plist1, pid2 ) != None
        assert trigutil.find_process_in_list( plist2, pid1 ) == None
        assert trigutil.find_process_in_list( plist2, pid2 ) == None

    def test_timeout_a_single_subprocess(self):
        ""
        cwd = os.getcwd()

        write_sub_helper()

        # first, check running a subprocess

        write_sub_script( 'sub1.py', 1 )
        time.sleep(1)

        cmd = Command( sys.executable, 'sub1.py' )

        t1 = time.time()
        x = cmd.run_timeout( 60 )
        t2 = time.time()

        assert t2-t1 < 5
        assert x == 0
        assert len( util.grepfiles( 'START', 'sub1.log' ) ) == 1
        assert len( util.grepfiles( 'DONE', 'sub1.log' ) ) == 1

        # next, timeout a subprocess

        write_sub_script( 'sub2.py', 20 )
        time.sleep(1)

        cmd = Command( sys.executable, 'sub2.py' )

        t1 = time.time()
        x = cmd.run_timeout( 3, raise_on_error=False )
        t2 = time.time()

        assert t2-t1 < 6
        assert x == None
        assert len( util.grepfiles( 'START', 'sub2.log' ) ) == 1
        assert len( util.grepfiles( 'DONE''sub2.log' ) ) == 0

    def test_timeout_a_subprocess_that_runs_a_subprocess(self):
        ""
        cwd = os.getcwd()

        write_sub_helper()

        write_sub_script( 'sub1.py', 1, 'sub2.py' )
        write_sub_script( 'sub2.py', 20 )
        time.sleep(1)

        cmd = Command( sys.executable, 'sub1.py' )

        t1 = time.time()
        x = cmd.run_timeout( 3, raise_on_error=False )
        t2 = time.time()
        plist = trigutil.get_process_list()

        assert t2-t1 < 6
        assert x == None

        L = util.grepfiles( 'START', 'sub1.log' )
        assert len(L) == 1
        pid1 = int( L[0].split()[1] )

        L = util.grepfiles( 'START', 'sub2.log' )
        assert len(L) == 1
        pid2 = int( L[0].split()[1] )
        assert pid2 != pid1

        assert len( util.grepfiles( 'DONE', 'sub1.log' ) ) == 0
        assert len( util.grepfiles( 'DONE', 'sub2.log' ) ) == 0

        assert trigutil.find_process_in_list( plist, pid1 ) == None
        assert trigutil.find_process_in_list( plist, pid2 ) == None


######################################################################

def write_sub_helper():
    """
    writes a python script with helper functions for import into test scripts
    """
    util.writefile( 'subhelper.py', """
        import os, sys, time, subprocess
        def log( filename, *args ):
            fp = open( filename, 'a' )
            fp.write( ' '.join( [ str(x) for x in args ] ) + os.linesep )
            fp.close()
        """ )


def write_sub_script( scriptpath, sleeptime, subscript=None ):
    ""
    logpath = os.path.splitext( scriptpath )[0]+'.log'

    subcmd = ''
    if subscript:
        subcmd = 'subprocess.call( [ sys.executable, "' + \
                    os.path.abspath(subscript) + '" ] )'

    util.writefile( scriptpath, """
        import os, sys, time, subprocess
        sys.path.insert( 0, '"""+os.getcwd()+"""' )
        from subhelper import *
        log( '"""+logpath+"""', 'START', os.getpid(), time.time() )
        """+subcmd+"""
        time.sleep( """+str(sleeptime)+""" )
        log( '"""+logpath+"""', 'DONE', time.time() )
        """ )


def extract_log_lines( output ):
    """
    Loops over lines in the given log output and extracts the lines with
    log markers.  Returns a list of

        [ epoch time, marker name, data list ]
    """
    lines = []

    for line in output.splitlines():
        L = parse_log_line( line )
        if L:
            lines.append( [ L[0], L[1], eval(L[2]) ] )

    return lines

def parse_log_line( line ):
    """
    This parses log files the same way triglog.py does it.  It should really
    be generalized somehow, but I don't really have a good design yet (and
    haven't put enough effort into doing so).

    For now, this logic will be duplicated and has to be manually synchronized.
    """
    logline = None

    markers = [ 'runcmd: ', 'return: ' ]

    line = line.rstrip()
    datemark = re.compile(
        r'\[(Mon|Tue|Wed|Thu|Fri|Sat|Sun)([^]]*20[0-9][0-9]\])+?' )
    m = datemark.match( line )
    if m != None:
        try:
            ts = line[:m.end()].strip().strip('[').strip(']')
            tm = time.mktime( time.strptime( ts ) )
            line = line[m.end():].strip()
            for n in markers:
                if line.startswith(n):
                    data = line.split(n,1)[1].strip()
                    L = [ tm, n.strip().rstrip(':'), data ]
                    logline = L
                    break
        except Exception:
            #traceback.print_exc()  # uncomment to debug
            pass

    return logline


######################################################################

def get_ssh_pair( fake_ssh_pause=None ):
    """
    Returns a pair ( ssh program, ssh machine ).
    """
    if use_real_ssh and fake_ssh_pause == None:
        sshprog = 'ssh'
        import socket
        sshmach = socket.gethostname()
    
    else:
        st = str(1)
        if fake_ssh_pause != None:
            st = str(fake_ssh_pause)
        util.writescript( 'fakessh', """
            #!"""+localpy+""" -E
            import os, sys, getopt, time
            optL,argL = getopt.getopt( sys.argv[1:], 'xTv' )
            argL.pop(0)  # remove the machine name
            time.sleep( """+st+""" )
            os.execl( '/bin/bash', '/bin/bash', '-c', ' '.join( argL ) )
            """ )
        sshprog = os.path.abspath( 'fakessh' )
        sshmach = 'sparky'

    return sshprog, sshmach


######################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
