#!/usr/bin/env python

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import getopt

# this will os.chdir() to a subdirectory
from testutils import *

# this is the module we are testing
import runjobs

# list of pythons to test with the -p option
pyL = [ '/home/rrdrake/bin/Linux/py244/bin/python',
        '/home/rrdrake/bin/Linux/py255/bin/python',
        '/home/rrdrake/bin/Linux/py266/bin/python',
        '/home/rrdrake/bin/Linux/py273/bin/python',
        '/home/rrdrake/bin/Linux/py301/bin/python',
        '/home/rrdrake/bin/Linux/py313/bin/python',
        '/home/rrdrake/bin/Linux/py325/bin/python',
        '/home/rrdrake/bin/Linux/py335/bin/python',
        '/home/rrdrake/bin/Linux/py343/bin/python',
        '/home/rrdrake/bin/Linux/py353/bin/python' ]

localpy = sys.executable

# By default, a "fake" ssh script is used that acts like ssh.  To use
# an actual ssh, add the -s option to the unit test command line.  In this
# case, make sure you can ssh to the current machine without a password.
use_real_ssh = False


def main():
    """
    """
    optL,argL = getopt.getopt( sys.argv[1:], 'ps' )
    cwd = os.getcwd()

    if ('-s','') in optL:
        global use_real_ssh
        use_real_ssh = True

    if ('-p','') not in optL:
        runtests( cwd, argL )
    else:
        # run each python version separately
        for py in pyL:
            global localpy
            localpy = py
            print3( 'local python:', localpy )
            runtests( cwd, argL )

def runtests( cwd, argL ):
    """
    """
    if len(argL) == 0:
        argL = """runjob1 runjob1b runjob1c runjob2 runjob3
                  jobfail1 jobfail2 jobfail3 jobfail4 jobfail5 jobfail6
                  multijob1
                  workdir1
                  jobcast1 jobcast2
                  remote1 remote2 remote3
                  timeout1 timeout2
                  remotefail1 remotefail2a remotefail2b
               """.split()
    
    cwd = os.getcwd()
    for func in argL:
        os.chdir( cwd )
        rmallfiles()
        time.sleep(1)
        print3( '====> ', func )
        eval( func+'()' )


#######################################################################

def runjob1():
    """
    run a simple shell command
    """
    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )
        jb = run_shell_job( 'ls', 'echo "hello" ; ls -l job.py ; sleep 2',
                            poll_interval=2 )
        print3( 'exit =', jb.get( 'exit' ) )
        assert jb.get( 'exit' ) == 0
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    print3( out )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1
    assert len( grep( out, 'exit = 0' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'ls-*.log' )
    assert len(fL) == 1
    assert len( filegrep( fL[0], 'hello' ) ) == 1
    assert len( filegrep( fL[0], 'job.py' ) ) == 1


def runjob1b():
    """
    run a command using an argument list
    """
    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )
        jb = run_job( 'ls', '/bin/bash', '-c',
                      'echo "hello" ; ls -l job.py ; sleep 2',
                      poll_interval=2 )
        print3( 'exit =', jb.get( 'exit' ) )
        assert jb.get( 'exit' ) == 0
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1
    assert len( grep( out, 'exit = 0' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'ls-*.log' )
    assert len(fL) == 1
    assert len( filegrep( fL[0], 'hello' ) ) == 1
    assert len( filegrep( fL[0], 'job.py' ) ) == 1


def runjob1c():
    """
    run a shell command using an argument list
    """
    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )
        jb = run_shell_job( 'ls', 'touch', 'file name',
                            poll_interval=2 )
        print3( 'exit =', jb.get( 'exit' ) )
        assert jb.get( 'exit' ) == 0
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    #print3( out )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1
    assert len( grep( out, 'exit = 0' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'ls-*.log' )
    assert len(fL) == 1
    assert os.path.exists( 'file name' )


def runjob2():
    """
    run a command in the background
    """
    writefile( 'job.py', """
        import os, sys, time
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )
        jid = run_shell_job_bg( 'job',
                                'touch hello ; sleep 5 ; touch goodbye',
                                poll_interval=2 )
        print3( 'jobid =', jid )
        time.sleep(1)
        assert not os.path.exists( 'goodbye' )
        # the wait returns the job object
        jb = wait_job( jid )
        assert jb.get( 'exit' ) == 0
        print3( 'exit =', jb.get( 'exit' ) )
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    #print3( out )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1
    assert len( grep( out, 'exit = 0' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'job-*.log' )
    assert len(fL) == 1
    
    assert os.path.exists( 'hello' )
    assert os.path.exists( 'goodbye' )


def runjob3():
    """
    run a command in the background and poll it
    """
    writefile( 'job.py', """
        import os, sys, time
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )
        jid = run_shell_job_bg( 'job',
                                'touch hello ; sleep 5 ; touch goodbye',
                                poll_interval=2 )
        print3( 'jobid =', jid )
        # poll should be false
        b = poll_job( jid )
        print3( 'poll 1', b )
        assert not b
        assert not os.path.exists( 'goodbye' )
        time.sleep(2)
        # poll should still be false, but the first file should exist
        b = poll_job( jid )
        print3( 'poll 2', b )
        assert not b
        assert os.path.exists( 'hello' )
        assert not os.path.exists( 'goodbye' )
        # let the job finish
        time.sleep(6)
        b = poll_job( jid )
        print3( 'poll 3', b )
        assert b
        assert os.path.exists( 'hello' )
        assert os.path.exists( 'goodbye' )
        # the wait returns the job object
        jb = wait_job( jid )
        assert jb.get( 'exit' ) == 0
        print3( 'exit =', jb.get( 'exit' ) )
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    #print3( out )

    assert len( grep( out, 'starting' ) ) == 1
    L = grep( out, 'JobDone:' )
    assert len( L ) == 1
    assert L[0].count( 'exit=0' ) == 1
    assert len( grep( out, 'exit = 0' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'job-*.log' )
    assert len(fL) == 1
    
    assert os.path.exists( 'hello' )
    assert os.path.exists( 'goodbye' )


def jobfail1():
    """
    a job that fails
    """
    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )
        jb = run_shell_job( 'ls', 'echo "fake failure" ; exit 1',
                            poll_interval=2 )
        print3( 'exit =', jb.get( 'exit', None ) )
        print3( 'exc =', jb.get( 'exc', 'unset' ) )
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    #print3( out )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'exit = 1' ) ) == 1
    assert len( grep( out, 'exit = 0' ) ) == 0
    assert len( grep( out, 'Traceback' ) ) == 0
    assert len( grep( out, 'exc = unset' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'ls-*.log' )
    assert len(fL) == 1
    assert len( filegrep( fL[0], 'fake failure' ) ) == 1


def jobfail2():
    """
    a job that fails to even launch
    """
    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )
        jb = run_job( 'bad', '/an/arbitrary/path/badprogram',
                      poll_interval=2 )
        print3( 'exit =', jb.get( 'exit', 'unset' ) )
        print3( 'exc =', jb.get( 'exc', 'unset' ) )
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    #print3( out )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'Traceback' ) ) > 0
    assert len( grep( out, 'Exception running jobid' ) ) == 1
    assert len( grep( out, 'exit = unset' ) ) == 1
    assert len( grep( out, 'exc =' ) ) == 1
    assert len( grep( out, 'exc = unset' ) ) == 0
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'bad-*.log' )
    assert len(fL) == 1


def jobfail3():
    """
    a shell job that fails to launch
    """
    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )
        jb = run_shell_job( 'bad', '/an/arbitrary/path/badprogram',
                            poll_interval=2 )
        print3( 'exit =', jb.get( 'exit', 'unset' ) )
        print3( 'exc =', jb.get( 'exc', 'unset' ) )
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    #print3( out )

    assert len( grep( out, 'starting' ) ) == 1
    L = grep( out, 'JobDone:' )
    assert len( L ) == 1
    assert L[0].count( 'exit=' ) == 1 and L[0].count( 'exit= ' ) == 0
    assert len( grep( out, 'Traceback' ) ) == 0
    assert len( grep( out, 'exit =' ) ) == 1
    assert len( grep( out, 'exit = 0' ) ) == 0
    assert len( grep( out, 'exc = unset' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'bad-*.log' )
    assert len(fL) == 1


def jobfail4():
    """
    a background job that fails to launch
    """
    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )
        jid = run_job_bg( 'bad', '/an/arbitrary/path/badprogram',
                          poll_interval=2 )
        jb = wait_job( jid )
        print3( 'exit =', jb.get( 'exit', 'unset' ) )
        print3( 'exc =', jb.get( 'exc', 'unset' ) )
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    #print3( out )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'Traceback' ) ) > 0
    L = grep( out, 'JobDone:' )
    assert len( L ) == 1
    assert L[0].count( 'exit= ' ) == 1
    assert L[0].count( 'exc=[' ) == 1
    assert len( grep( out, 'exit = unset' ) ) == 1
    assert len( grep( out, 'exc =' ) ) == 1
    assert len( grep( out, 'exc = unset' ) ) == 0
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'bad-*.log' )
    assert len(fL) == 1


def jobfail5():
    """
    an ill formed job
    """
    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )
        jb = run_job( 'bad1', poll_interval=2 )
        print3( 'exit1 =', jb.get( 'exit', 'unset' ) )
        print3( 'exc1 =', jb.get( 'exc', 'unset' ) )
        jid = run_job_bg( 'bad2', poll_interval=2 )
        jb = wait_job( jid )
        print3( 'exit2 =', jb.get( 'exit', 'unset' ) )
        print3( 'exc2 =', jb.get( 'exc', 'unset' ) )
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    #print3( out )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'Traceback' ) ) > 0
    assert len( grep( out, 'RunJob: bad1' ) ) == 1
    assert len( grep( out, 'RunJob: bad2' ) ) == 1
    assert len( grep( out, 'exit1 = unset' ) ) == 1
    assert len( grep( out, 'exc1 =' ) ) == 1
    assert len( grep( out, 'exc1 = unset' ) ) == 0
    assert len( grep( out, 'exit2 = unset' ) ) == 1
    assert len( grep( out, 'exc2 =' ) ) == 1
    assert len( grep( out, 'exc2 = unset' ) ) == 0
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'bad1-*.log' )
    assert len(fL) == 0
    fL = fnmatch.filter( os.listdir( '.' ), 'bad2-*.log' )
    assert len(fL) == 0


def jobfail6():
    """
    bad attributes to job specification
    """
    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )
        jb = run_job( 'bad1', 'ls', machine=' sparky.gov' )
        print3( 'exit1 =', jb.get( 'exit', 'unset' ) )
        print3( 'exc1 =', jb.get( 'exc', 'unset' ) )
        jid = run_job_bg( 'bad2 ', 'ls' )
        jb = wait_job( jid )
        print3( 'exit2 =', jb.get( 'exit', 'unset' ) )
        print3( 'exc2 =', jb.get( 'exc', 'unset' ) )
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    #print3( out )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'Traceback' ) ) > 0
    assert len( grep( out, 'RunJob: bad1' ) ) == 1
    assert len( grep( out, 'RunJob: bad2' ) ) == 1
    assert len( grep( out, 'exit1 = unset' ) ) == 1
    assert len( grep( out, 'exc1 =' ) ) == 1
    assert len( grep( out, 'exc1 = unset' ) ) == 0
    assert len( grep( out, 'exit2 = unset' ) ) == 1
    assert len( grep( out, 'exc2 =' ) ) == 1
    assert len( grep( out, 'exc2 = unset' ) ) == 0
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'bad1-*.log' )
    assert len(fL) == 0
    fL = fnmatch.filter( os.listdir( '.' ), 'bad2-*.log' )
    assert len(fL) == 0


def multijob1():
    """
    running two jobs in background
    """
    writefile( 'job.py', """
        import os, sys, time
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )

        # the first job stalls before touching a file
        jid1 = run_shell_job_bg( 'job1', 'sleep 8 ; touch file1',
                                 poll_interval=2 )
        print3( 'jobid 1 =', jid1 )
        time.sleep(1)
        assert not os.path.exists( 'file1' )

        # the second job touches a file quickly
        jid2 = run_shell_job_bg( 'job2', 'sleep 1 ; touch file2',
                                 poll_interval=2 )
        print3( 'jobid 2 =', jid2 )
        time.sleep(1)
        assert not os.path.exists( 'file1' )
        assert os.path.exists( 'file2' )

        time.sleep(1)
        assert not poll_job( jid1 )
        assert poll_job( jid2 )

        jb2 = wait_job( jid2 )
        assert jb2.get( 'exit' ) == 0

        jb1 = wait_job( jid1 )
        assert jb1.get( 'exit' ) == 0

        assert os.path.exists( 'file1' )
        assert os.path.exists( 'file2' )

        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    #print3( out )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'Traceback' ) ) == 0
    assert len( grep( out, 'RunJob: job1' ) ) == 1
    assert len( grep( out, 'RunJob: job2' ) ) == 1
    L = grep( out, 'JobDone:' )
    assert len( L ) == 2
    assert L[0].count( 'JobDone:' ) == 1 and L[1].count( 'JobDone:' ) == 1
    assert L[0].count( 'job1' ) == 1 or L[1].count( 'job1' ) == 1
    assert L[0].count( 'job1' ) == 0 or L[1].count( 'job1' ) == 0
    assert L[0].count( 'job2' ) == 1 or L[1].count( 'job2' ) == 1
    assert L[0].count( 'job2' ) == 0 or L[1].count( 'job2' ) == 0
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'job*.log' )
    assert len(fL) == 2
    assert fL[0].startswith( 'job1-' ) or fL[1].startswith( 'job1-' )
    assert fL[0].startswith( 'job2-' ) or fL[1].startswith( 'job2-' )


def workdir1():
    """
    specify the run directory
    """
    os.mkdir( 'wdir' )
    d = os.path.join( os.getcwd(), 'wdir' )
    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )
        jb = run_shell_job( 'wd', 'echo hello > afile.txt',
                            workdir='"""+d+"""',
                            poll_interval=2 )
        print3( 'exit =', jb.get( 'exit' ) )
        assert jb.get( 'exit' ) == 0
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    #print3( out )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'exit = 0' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'wd-*.log' )
    assert len(fL) == 1
    fn = os.path.join( d, 'afile.txt' )
    assert os.path.exists( fn )
    assert len( filegrep( fn, "hello" ) ) == 1


def jobcast1():
    """
    cast a Job instance to True/False
    """
    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )
        jb = run_shell_job( 'cast', 'echo hello > afile.txt',
                            poll_interval=2 )
        print3( 'exit =', jb.get( 'exit' ) )
        if jb:
            print3( "cast is True" )
        else:
            raise Exception( "cast should be True" )
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    #print3( out )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'exit = 0' ) ) == 1
    assert len( grep( out, 'cast is True' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'cast-*.log' )
    assert len(fL) == 1
    assert os.path.exists( 'afile.txt' )
    assert len( filegrep( 'afile.txt', "hello" ) ) == 1


def jobcast2():
    """
    cast a Job instance to True/False
    """
    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting' )
        jb = run_shell_job( 'cast', 'echo hello > afile.txt ; exit 1',
                            poll_interval=2 )
        print3( 'exit =', jb.get( 'exit' ) )
        if jb:
            raise Exception( "cast should be False" )
        else:
            print3( "cast is False" )
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    #print3( out )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'exit =' ) ) == 1
    assert len( grep( out, 'cast is False' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'cast-*.log' )
    assert len(fL) == 1
    assert os.path.exists( 'afile.txt' )
    assert len( filegrep( 'afile.txt', "hello" ) ) == 1


def remote1():
    """
    run a remote job
    """
    os.mkdir( 'rdir' )
    os.mkdir( 'ldir' )
    rd = os.path.abspath( 'rdir' )  # remote run directory
    ld = os.path.abspath( 'ldir' )  # local run and log directory

    sshprog,sshmach = get_ssh_pair()

    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        tprint( 'starting in', os.getcwd() )
        jb = run_shell_job( 'rjob', 'echo hello',
                            machine='"""+sshmach+"""',
                            sshexe='"""+sshprog+"""',
                            workdir='"""+rd+"""',
                            poll_interval=2 )
        tprint( 'exit =', jb.get( 'exit' ) )
        tprint( 'ending' )
        """ )

    jf = os.path.abspath( 'job.py' )
    os.chdir( ld )

    out = runout( localpy+' '+jf )
    #print3( out )
    #os.system( localpy+' '+jf )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'exit = 0' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( ld ), 'rjob-*.log' )
    assert len(fL) == 1
    lf = os.path.join( ld, fL[0] )

    fL = fnmatch.filter( os.listdir( rd ), 'rjob-*.log' )
    assert len(fL) == 1
    rf = os.path.join( rd, fL[0] )

    assert os.path.basename(lf) == os.path.basename(rf)
    assert filecmp.cmp( lf, rf, False )

    L = filegrep( lf, 'hello' )
    assert len(L) == 2
    assert L[1].strip() == 'hello'


def remote2():
    """
    remote job that fails
    """
    os.mkdir( 'rdir' )
    os.mkdir( 'ldir' )
    rd = os.path.abspath( 'rdir' )  # remote run directory
    ld = os.path.abspath( 'ldir' )  # local run and log directory

    sshprog,sshmach = get_ssh_pair()

    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        tprint( 'starting in', os.getcwd() )
        jb = run_shell_job( 'rjob', '/bad/program',
                            machine='"""+sshmach+"""',
                            sshexe='"""+sshprog+"""',
                            workdir='"""+rd+"""',
                            poll_interval=2 )
        tprint( 'exit =', jb.get( 'exit' ) )
        tprint( 'ending' )
        """ )

    jf = os.path.abspath( 'job.py' )
    os.chdir( ld )

    out = runout( localpy+' '+jf )
    #print3( out )
    #os.system( localpy+' '+jf )

    time.sleep(2)

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'exit =' ) ) == 1
    assert len( grep( out, 'exit = 0' ) ) == 0
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( ld ), 'rjob-*.log' )
    assert len(fL) == 1
    lf = os.path.join( ld, fL[0] )

    fL = fnmatch.filter( os.listdir( rd ), 'rjob-*.log' )
    assert len(fL) == 1
    rf = os.path.join( rd, fL[0] )

    assert os.path.basename(lf) == os.path.basename(rf)
    assert filecmp.cmp( lf, rf, False )


def remote3():
    """
    dual remote jobs
    """
    os.mkdir( 'rdir' )
    os.mkdir( 'ldir' )
    rd = os.path.abspath( 'rdir' )  # remote run directory
    ld = os.path.abspath( 'ldir' )  # local run and log directory

    sshprog,sshmach = get_ssh_pair()

    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        tprint( 'starting in', os.getcwd() )
        jid1 = run_shell_job_bg( 'rjob', 'sleep 1; echo hello',
                            machine='"""+sshmach+"""',
                            sshexe='"""+sshprog+"""',
                            workdir='"""+rd+"""',
                            poll_interval=2 )
        jid2 = run_shell_job_bg( 'rjob', 'sleep 4; echo world',
                            machine='"""+sshmach+"""',
                            sshexe='"""+sshprog+"""',
                            workdir='"""+rd+"""',
                            poll_interval=2 )
        jb = wait_job( jid1 )
        tprint( 'exit1 =', jb.get( 'exit' ) )
        jb = wait_job( jid2 )
        tprint( 'exit2 =', jb.get( 'exit' ) )
        tprint( 'ending' )
        """ )

    jf = os.path.abspath( 'job.py' )
    os.chdir( ld )

    out = runout( localpy+' '+jf )
    #print3( out )
    #os.system( localpy+' '+jf )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'exit1 = 0' ) ) == 1
    assert len( grep( out, 'exit2 = 0' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( ld ), 'rjob-*.log' )
    assert len(fL) == 2
    fL.sort()
    lf1,lf2 = os.path.join( ld, fL[0] ), os.path.join( ld, fL[1] )

    fL = fnmatch.filter( os.listdir( rd ), 'rjob-*.log' )
    assert len(fL) == 2
    fL.sort()
    rf1,rf2 = os.path.join( rd, fL[0] ), os.path.join( rd, fL[1] )

    assert os.path.basename(lf1) == os.path.basename(rf1)
    assert filecmp.cmp( lf1, rf1, False )
    assert os.path.basename(lf2) == os.path.basename(rf2)
    assert filecmp.cmp( lf2, rf2, False )
    
    L = filegrep( lf1, 'hello' )
    assert len(L) == 2
    assert L[1].strip() == 'hello'
    L = filegrep( lf2, 'world' )
    assert len(L) == 2
    assert L[1].strip() == 'world'


def timeout1():
    """
    timeout a local job
    """
    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting', time.time() )
        jb = run_shell_job( 'job', 'echo hello ; sleep 60 ; echo world',
                            timeout=5, poll_interval=2 )
        print3( 'exit =', jb.get( 'exit', 'unset' ), time.time() )
        assert jb.get( 'exit', 'unset' ) == None
        print3( 'exc =', jb.get( 'exc', 'unset' ), time.time() )
        print3( 'ending' )
        """ )

    out = runout( localpy+' job.py' )
    #print3( out )

    L = grep( out, 'starting' )
    assert len(L) == 1
    t0 = int( float( L[0].split()[-1].strip() ) )
    L = grep( out, 'exit = None' )
    assert len(L) == 1
    t1 = int( float( L[0].split()[-1].strip() ) )
    assert t1 - t0 < 10
    assert len( grep( out, 'exc = unset' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( '.' ), 'job-*.log' )
    assert len(fL) == 1
    assert len( filegrep( fL[0], 'hello' ) ) == 1
    assert len( filegrep( fL[0], 'world' ) ) == 0


def timeout2():
    """
    timeout a remote job
    """
    os.mkdir( 'rdir' )
    os.mkdir( 'ldir' )
    rd = os.path.abspath( 'rdir' )  # remote run directory
    ld = os.path.abspath( 'ldir' )  # local run and log directory

    sshprog,sshmach = get_ssh_pair()

    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        print3( 'starting', time.time() )
        jb = run_shell_job( 'job', 'echo hello ; sleep 60 ; echo world',
                            machine='"""+sshmach+"""',
                            sshexe='"""+sshprog+"""',
                            workdir='"""+rd+"""',
                            timeout=5, poll_interval=2 )
        print3( 'exit =', jb.get( 'exit', 'unset' ), time.time() )
        assert jb.get( 'exit', 'unset' ) == None
        print3( 'ending' )
        """ )

    jf = os.path.abspath( 'job.py' )
    os.chdir( ld )

    out = runout( localpy+' '+jf )
    #print3( out )

    L = grep( out, 'starting' )
    assert len(L) == 1
    t0 = int( float( L[0].split()[-1].strip() ) )
    L = grep( out, 'exit = None' )
    assert len(L) == 1
    t1 = int( float( L[0].split()[-1].strip() ) )
    assert t1 - t0 < 15
    L = grep( out, 'JobDone:' )
    assert len( L ) == 1
    assert L[0].count( 'exit=None' ) == 1
    assert L[0].count( 'exc=' ) == 1
    assert L[0].count( 'exc=[' ) == 0
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( ld ), 'job-*.log' )
    assert len(fL) == 1
    lf = os.path.join( ld, fL[0] )

    fL = fnmatch.filter( os.listdir( rd ), 'job-*.log' )
    assert len(fL) == 1
    rf = os.path.join( rd, fL[0] )

    assert os.path.basename(lf) == os.path.basename(rf)
    assert filecmp.cmp( lf, rf, False )
    
    L = filegrep( lf, 'hello' )
    assert len(L) == 2
    assert L[1].strip() == 'hello'
    # it should timeout before print "world"
    L = filegrep( lf, 'world' )
    assert len(L) == 1
    assert L[0].strip() != 'world'


def remotefail1():
    """
    failure to connect to remote machine
    """
    os.mkdir( 'rdir' )
    os.mkdir( 'ldir' )
    rd = os.path.abspath( 'rdir' )  # remote run directory
    ld = os.path.abspath( 'ldir' )  # local run and log directory

    sshprog,sshmach = get_ssh_pair( connect_failure=True )

    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        tprint( 'starting in', os.getcwd() )
        jb = run_shell_job( 'rjob', 'echo hello',
                            machine='"""+sshmach+"""',
                            sshexe='"""+sshprog+"""',
                            connection_attempts=2,
                            workdir='"""+rd+"""',
                            poll_interval=2 )
        tprint( 'exit =', jb.get( 'exit', 'unset' ) )
        tprint( 'exc =', jb.get( 'exc', 'unset' ) )
        tprint( 'ending' )
        """ )

    jf = os.path.abspath( 'job.py' )
    os.chdir( ld )

    out = runout( localpy+' '+jf )
    #print3( out )
    #os.system( localpy+' '+jf )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'exit = unset' ) ) == 1
    assert len( grep( out, 'exc = unset' ) ) == 0
    assert len( grep( out, re.escape('exc = [') ) ) == 1
    assert len( grep( out, 'Fake connection falure to sparky' ) ) > 0
    assert len( grep( out, 'Connection failed to .sparky' ) ) == 1
    assert len( grep( out, 'Could not connect to sparky' ) ) == 2
    assert len( grep( out, 'exc = .*Could not connect to sparky' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1

def remotefail2a():
    """
    first make sure the 'uptime' fakessh script works
    """
    os.mkdir( 'rdir' )
    os.mkdir( 'ldir' )
    rd = os.path.abspath( 'rdir' )  # remote run directory
    ld = os.path.abspath( 'ldir' )  # local run and log directory

    sshprog,sshmach = get_ssh_pair( uptime=30 )

    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        tprint( 'starting in', os.getcwd() )
        jb = run_shell_job( 'rjob', 'echo hello ; sleep 2 ; echo world',
                            machine='"""+sshmach+"""',
                            sshexe='"""+sshprog+"""',
                            workdir='"""+rd+"""',
                            poll_interval=2 )
        tprint( 'exit =', jb.get( 'exit', 'unset' ) )
        tprint( 'exc =', jb.get( 'exc', 'unset' ) )
        tprint( 'ending' )
        """ )

    jf = os.path.abspath( 'job.py' )
    os.chdir( ld )

    out = runout( localpy+' '+jf )
    #print3( out )
    #os.system( localpy+' '+jf )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'exit = 0' ) ) == 1
    assert len( grep( out, 'exc = unset' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1
    assert len( grep( out, 'Warning: exception monitoring jobid' ) ) == 0
    assert len( grep( out, 'Exception ignored; continuing to monitor' ) ) == 0
    
    fL = fnmatch.filter( os.listdir( ld ), 'rjob-*.log' )
    assert len(fL) == 1
    lf = os.path.join( ld, fL[0] )

    fL = fnmatch.filter( os.listdir( rd ), 'rjob-*.log' )
    assert len(fL) == 1
    rf = os.path.join( rd, fL[0] )

    assert os.path.basename(lf) == os.path.basename(rf)
    assert filecmp.cmp( lf, rf, False )
    
    L = filegrep( lf, 'hello' )
    assert len(L) == 2
    assert L[1].strip() == 'hello'
    L = filegrep( lf, 'world' )
    assert len(L) == 2
    assert L[1].strip() == 'world'

def remotefail2b():
    """
    then cause fakessh to die after 5 seconds
    """
    os.mkdir( 'rdir' )
    os.mkdir( 'ldir' )
    rd = os.path.abspath( 'rdir' )  # remote run directory
    ld = os.path.abspath( 'ldir' )  # local run and log directory

    sshprog,sshmach = get_ssh_pair( uptime=5 )

    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        tprint( 'starting in', os.getcwd() )
        jb = run_shell_job( 'rjob', 'echo hello ; sleep 10 ; echo world',
                            machine='"""+sshmach+"""',
                            sshexe='"""+sshprog+"""',
                            workdir='"""+rd+"""',
                            poll_interval=2,
                            exception_print_interval=3 )
        tprint( 'exit =', jb.get( 'exit', 'unset' ) )
        tprint( 'exc =', jb.get( 'exc', 'unset' ) )
        tprint( 'ending' )
        """ )

    jf = os.path.abspath( 'job.py' )
    os.chdir( ld )

    out = runout( localpy+' '+jf )
    #print3( out )
    #os.system( localpy+' '+jf )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'exit = 0' ) ) == 1
    assert len( grep( out, 'exc = unset' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1
    assert len( grep( out, 'Warning: exception monitoring jobid' ) ) == 1
    assert len( grep( out, 'Exception ignored; continuing to monitor' ) ) == 1

    fL = fnmatch.filter( os.listdir( ld ), 'rjob-*.log' )
    assert len(fL) == 1
    lf = os.path.join( ld, fL[0] )

    fL = fnmatch.filter( os.listdir( rd ), 'rjob-*.log' )
    assert len(fL) == 1
    rf = os.path.join( rd, fL[0] )

    assert os.path.basename(lf) == os.path.basename(rf)
    assert filecmp.cmp( lf, rf, False )
    
    L = filegrep( lf, 'hello' )
    assert len(L) == 2
    assert L[1].strip() == 'hello'
    L = filegrep( lf, 'world' )
    assert len(L) == 2
    assert L[1].strip() == 'world'


def update1():
    """
    exercise incremental log updating
    """
    os.mkdir( 'rdir' )
    os.mkdir( 'ldir' )
    rd = os.path.abspath( 'rdir' )  # remote run directory
    ld = os.path.abspath( 'ldir' )  # local run and log directory

    sshprog,sshmach = get_ssh_pair()

    scr = os.path.abspath( 'makeout' )
    writescript( scr, '#!/usr/bin/env python', """
        import os, sys, time
        def print3( *args ):
            sys.stdout.write( ' '.join( [ str(a) for a in args ] ) + os.linesep )
            sys.stdout.flush()
        print3( 'This is line one.'*100 )
        time.sleep(5)
        print3( 'Now line two.'*100 )
        time.sleep(5)
        print3( 'Three!'*100 )
        """ )

    writefile( 'job.py', """
        import os, sys
        sys.path.insert( 0, '"""+srcdir+"""' )
        from runjobs import *

        tprint( 'starting in', os.getcwd() )
        jb = run_shell_job( 'rjob', '"""+scr+"""',
                            machine='"""+sshmach+"""',
                            sshexe='"""+sshprog+"""',
                            workdir='"""+rd+"""',
                            poll_interval=2,
                            getlog_small_file_size=1,  # force updates
                            getlog_chunk_size=23 )
        tprint( 'exit =', jb.get( 'exit' ) )
        tprint( 'ending' )
        """ )

    jf = os.path.abspath( 'job.py' )
    os.chdir( ld )

    out = runout( localpy+' '+jf )
    #print3( out )
    #os.system( localpy+' '+jf )

    assert len( grep( out, 'starting' ) ) == 1
    assert len( grep( out, 'exit = 0' ) ) == 1
    assert len( grep( out, 'ending' ) ) == 1

    fL = fnmatch.filter( os.listdir( ld ), 'rjob-*.log' )
    assert len(fL) == 1
    lf = os.path.join( ld, fL[0] )

    fL = fnmatch.filter( os.listdir( rd ), 'rjob-*.log' )
    assert len(fL) == 1
    rf = os.path.join( rd, fL[0] )

    assert os.path.basename(lf) == os.path.basename(rf)
    assert filecmp.cmp( lf, rf, False )
    
    assert abs( os.path.getmtime(lf) - os.path.getmtime(rf) ) < 5
    m1 = stat.S_IMODE( os.stat(lf)[stat.ST_MODE] )
    m2 = stat.S_IMODE( os.stat(rf)[stat.ST_MODE] )
    assert m1 == m2


#######################################################################

def get_ssh_pair( connect_failure=False, uptime=None ):
    """
    Returns a pair ( ssh program, ssh machine ).
    """
    if use_real_ssh and connect_failure == False and uptime == None:
        sshprog = which( 'ssh' )
        import socket
        sshmach = socket.gethostname()
    
    elif uptime != None:
        # make the fake ssh session to die after 'uptime' seconds
        writescript( 'fakessh', "#!"+localpy+" -E", """
            import os, sys, getopt, time, subprocess, signal
            optL,argL = getopt.getopt( sys.argv[1:], 'xTv' )
            mach = argL.pop(0)  # remove the machine name
            time.sleep( 1 )
            p = subprocess.Popen( ['/bin/bash', '-c', ' '.join( argL )] )
            t0 = time.time()
            while time.time() - t0 < """+str(uptime)+""":
                x = p.poll()
                if x != None:
                    break
                time.sleep(1)
            if x == None:
                if hasattr( p, 'terminate' ):
                    p.terminate()
                else:
                    os.kill( p.pid, signal.SIGTERM )
                    x = p.wait()
                x = 1
            sys.exit( x )
            """ )
        sshprog = os.path.abspath( 'fakessh' )
        sshmach = 'sparky'

    else:
        writescript( 'fakessh', "#!"+localpy+" -E", """
            import os, sys, getopt, time
            optL,argL = getopt.getopt( sys.argv[1:], 'xTv' )
            mach = argL.pop(0)  # remove the machine name
            time.sleep( 1 )
            if """+repr(connect_failure)+""":
                sys.stderr.write( "Fake connection falure to "+mach+os.linesep )
                sys.exit(1)
            os.execl( '/bin/bash', '/bin/bash', '-c', ' '.join( argL ) )
            """ )
        sshprog = os.path.abspath( 'fakessh' )
        sshmach = 'sparky'

    return sshprog, sshmach


#######################################################################

main()
