#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST:

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
from os.path import abspath
import time
import shutil
import glob
import filecmp
import unittest

import trigtestutils as trigutil
import testutils as util
from testutils import print3

from gitinterface import GitInterfaceError, GitInterface
from gitinterface import set_environ
from gitinterface import copy_path_to_current_directory
from gitinterface import runcmd


class with_set_environ( unittest.TestCase ):

    def setUp(self):
        util.setup_test( cleanout=False )

    def test_setting_no_names_should_not_change_environ(self):
        ""
        orig = dict( os.environ )

        with set_environ():
            state = dict( os.environ )

        self.assertEqual( orig, os.environ )
        self.assertEqual( orig, state )

    def test_setting_a_new_name_should_get_set_then_unset(self):
        ""
        orig = dict( os.environ )
        assert 'MY_SPECIAL_NAME' not in os.environ

        with set_environ( MY_SPECIAL_NAME='my special value' ):
            state = dict( os.environ )

        self.assertEqual( orig, os.environ )
        assert state['MY_SPECIAL_NAME'] == 'my special value'

    def test_a_value_of_None_causes_an_unset(self):
        ""
        orig = dict( os.environ )
        os.environ['MY_SPECIAL_NAME'] = 'my special value'

        assert 'MY_SPECIAL_NAME' in os.environ

        with set_environ( MY_SPECIAL_NAME=None ):
            state = dict( os.environ )

        assert os.environ['MY_SPECIAL_NAME'] == 'my special value'
        assert 'MY_SPECIAL_NAME' not in state

        del os.environ['MY_SPECIAL_NAME']

    def test_unset_has_no_affect_if_not_already_defined(self):
        ""
        orig = dict( os.environ )
        assert 'MY_SPECIAL_NAME' not in os.environ

        with set_environ( MY_SPECIAL_NAME=None ):
            state = dict( os.environ )

        assert 'MY_SPECIAL_NAME' not in state
        self.assertEqual( orig, state )


class create_and_clone( unittest.TestCase ):

    def setUp(self):
        util.setup_test()

    def test_create_repository_in_existing_directory(self):
        ""
        git = GitInterface()
        git.create()

        time.sleep(1)
        assert os.path.exists( '.git/config' )

    def test_create_repository_in_a_new_directory(self):
        ""
        git = GitInterface()
        git.create( 'newrepo' )

        time.sleep(1)
        assert not os.path.exists( '.git' )
        assert os.path.exists( 'newrepo/.git/config' )

    def write_git_wrapper(self):
        ""
        touchfile = abspath( 'touchfile.txt' )
        util.writescript( 'mygit/gitwrapper', """
            #!"""+sys.executable+"""
            import os, sys, subprocess
            fp = open( '"""+touchfile+"""', 'w' )
            prox = os.environ.get( 'https_proxy', 'None' )
            fp.write( 'https_proxy=' + prox + os.linesep )
            prox = os.environ.get( 'HTTPS_PROXY', 'None' )
            fp.write( 'HTTPS_PROXY=' + prox + os.linesep )
            fp.close()
            x = subprocess.call( ' '.join( ['git']+sys.argv[1:] ), shell=True )
            assert x == 0
            """ )
        time.sleep(1)

    def test_specify_git_executable_to_use(self):
        ""
        self.write_git_wrapper()

        git = GitInterface( gitexe=abspath( 'mygit/gitwrapper' ) )
        git.create( 'newrepo' )

        time.sleep(1)
        assert os.path.exists( 'touchfile.txt' )
        assert os.path.exists( 'newrepo/.git/config' )

    def test_specify_https_proxy(self):
        ""
        self.write_git_wrapper()

        with set_environ( https_proxy=None, HTTPS_PROXY=None ):

            url = trigutil.create_local_bare_repository( 'subdir' )
            trigutil.push_file_to_repo( url, 'file.txt', 'file contents' )

            assert 'https_proxy' not in os.environ
            assert 'HTTPS_PROXY' not in os.environ

            git = GitInterface( gitexe=abspath( 'mygit/gitwrapper' ),
                                https_proxy='fakeurl://some/thing' )
            git.clone( url )
            git.currentBranch()

        assert len( util.grepfiles( 'https_proxy=fakeurl://some/thing',
                                    'touchfile.txt' ) ) == 1
        assert len( util.grepfiles( 'HTTPS_PROXY=fakeurl://some/thing',
                                    'touchfile.txt' ) ) == 1

    def test_create_bare_repository(self):
        ""
        git = GitInterface()
        git.create( 'newrepo.git', bare=True )

        time.sleep(1)
        lineL = util.grepfiles( 'bare', 'newrepo.git/config' )
        assert len(lineL) == 1 and 'true' in lineL[0].lower()

    def test_clone_a_local_repository(self):
        ""
        url = trigutil.create_local_bare_repository( 'subdir' )
        trigutil.push_file_to_repo( url, 'file.txt', 'file contents' )

        git = GitInterface( clone_from=url )
        time.sleep(1)

        assert len( util.grepfiles( 'example', 'example/.git/config' ) ) > 0
        assert len( util.grepfiles( 'file contents', 'example/file.txt' ) ) == 1

    def test_clone_master_branch_only(self):
        ""
        url = trigutil.create_bare_repo_with_topic_branch()

        # default clone first; a checkout of the branch should succeed
        git = GitInterface()
        git.clone( url )
        runcmd( 'git checkout topic', chdir='example' )

        shutil.rmtree( 'example' )
        time.sleep(1)

        # clone with master only; a checkout of the branch should fail
        git = GitInterface()
        git.clone( url, branch='master' )
        self.assertRaises( GitInterfaceError,
            runcmd, 'git checkout topic', chdir='example' )

    def test_clone_into_a_subdirectory(self):
        ""
        url = trigutil.create_bare_repo_with_topic_branch()

        git1 = GitInterface()
        git1.clone( url, directory='ex1' )

        git2 = GitInterface()
        git2.clone( url, 'ex2' )

        git3 = GitInterface()
        git3.clone( url, directory='ex3', branch='topic' )

        fL = glob.glob( 'ex*/.git/config' )
        fL.sort()
        assert fL == ['ex1/.git/config', 'ex2/.git/config', 'ex3/.git/config']

    def test_getting_root_directory_without_clone(self):
        ""
        url = trigutil.create_bare_repo_with_topic_branch()
        git1 = GitInterface()
        git1.clone( url, directory='ex1' )
        util.writefile( 'ex1/subdir/afile', 'my file' )
        git1.add( 'subdir' )
        git1.commit( 'add subdir' )
        git1.push()

        GitInterface( url )

        root = os.path.abspath( 'example' )

        git = GitInterface()

        os.chdir( 'example' )
        assert os.path.samefile( git.getRootPath(), root )

        os.chdir( 'subdir' )
        assert os.path.samefile( git.getRootPath(), root )

        os.chdir( '/' )
        self.assertRaises( GitInterfaceError, git.getRootPath )


class commit_and_push( unittest.TestCase ):

    def setUp(self):
        util.setup_test()

    def test_create_repo_and_commit_a_file(self):
        ""
        util.writefile( 'grepo/file.txt', "file contents" )
        time.sleep(1)

        git = GitInterface()
        git.create( 'grepo' )
        git.add( 'file.txt' )
        git.commit( 'first commit message' )

    def test_commit_and_push_a_new_file(self):
        ""
        url = trigutil.create_local_bare_repository( 'sdir', 'myrepo' )
        trigutil.push_file_to_repo( url, 'file.txt', 'file contents' )
        time.sleep(1)

        git = GitInterface( clone_from=url )
        util.writefile( 'myrepo/another.txt', 'another contents' )
        git.add( 'another.txt' )
        git.commit( 'adding file' )
        git.push()

        assert len( util.grepfiles( 'another', 'myrepo/another.txt' ) ) == 1

        shutil.rmtree( 'myrepo' )
        time.sleep(1)

        git = GitInterface( url )
        assert len( util.grepfiles( 'file', 'myrepo/file.txt' ) ) == 1
        assert len( util.grepfiles( 'another', 'myrepo/another.txt' ) ) == 1

    def test_add_commit_push_every_changed_file_in_a_directory(self):
        ""
        url = trigutil.create_bare_repo_with_topic_branch()

        git = GitInterface( url )

        util.writefile( 'example/adir/afile.txt', 'whatever' )
        git.add( 'adir/afile.txt' )
        git.commit( 'create directory' )
        git.push()

        util.writefile( 'example/adir/afile.txt', 'changed' )
        util.writefile( 'example/adir/newfile.txt', 'brand spanking new' )
        util.writefile( 'example/adir/deep/file.txt', 'further down' )
        time.sleep(1)

        git.add( 'adir' )
        git.commit( 'add everything under adir' )
        git.push()

        time.sleep(1)
        git2 = GitInterface()
        git2.clone( url, 'check' )
        assert os.path.isfile( 'check/adir/deep/file.txt' )
        assert util.readfile( 'check/adir/afile.txt' ).strip() == 'changed'


class branches( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

        self.url = trigutil.create_bare_repo_with_topic_branch()
        time.sleep(1)

    def test_listing_branches(self):
        ""
        os.mkdir( 'default' )
        os.mkdir( 'single' )
        time.sleep(1)

        git = GitInterface()
        assert git.listRemoteBranches( self.url ) == [ 'master', 'topic' ]
        self.assertRaises( GitInterfaceError, git.listRemoteBranches )

        os.chdir( 'default' )
        git = GitInterface( self.url )
        assert git.listBranches() == [ 'master' ]
        assert git.listBranches( remotes=True ) == [ 'master', 'topic' ]
        assert git.listRemoteBranches( self.url ) == [ 'master', 'topic' ]
        assert git.listRemoteBranches() == [ 'master', 'topic' ]

        os.chdir( '../single' )
        git = GitInterface()
        git.clone( self.url, branch='topic' )
        assert git.listBranches() == [ 'topic' ]
        # the fetch entry in .git/config limits the remote listing
        assert git.listBranches( remotes=True ) == [ 'topic' ]
        # but listRemoteBranches() is immune
        assert git.listRemoteBranches( self.url ) == [ 'master', 'topic' ]
        assert git.listRemoteBranches() == [ 'master', 'topic' ]

    def test_determine_current_branch(self):
        ""
        git = GitInterface( self.url )
        assert git.currentBranch() == 'master'

        git.checkoutBranch( 'topic' )
        assert git.currentBranch() == 'topic'

        git = GitInterface()
        os.chdir( 'example' )
        git.currentBranch() == 'topic'

    def test_getting_current_branch_fails_if_not_in_a_local_repository(self):
        ""
        git = GitInterface()
        self.assertRaises( GitInterfaceError, git.currentBranch )

    def test_current_branch_returns_None_if_in_detached_HEAD_state(self):
        ""
        trigutil.push_file_to_repo( self.url, 'file.txt', 'new contents' )

        git = GitInterface( self.url )
        trigutil.checkout_to_previous_sha1( git.getRootPath() )
        assert git.currentBranch() == None

    def test_current_branch_fails_if_done_right_after_git_init(self):
        ""
        os.mkdir( 'arepo' )
        time.sleep(1)

        os.chdir( 'arepo' )
        runcmd( 'git init' )

        git = GitInterface()
        self.assertRaises( GitInterfaceError, git.currentBranch )

    def test_clone_followed_by_a_new_branch_showing_up_on_remote(self):
        ""
        git = GitInterface( self.url )
        assert git.listBranches() == [ 'master' ]
        assert git.listBranches( remotes=True ) == [ 'master', 'topic' ]
        assert git.listRemoteBranches() == [ 'master', 'topic' ]

        trigutil.push_new_branch_with_file( self.url, 'newtopic',
                                            'file.txt', 'redo' )
        time.sleep(1)

        assert git.listBranches() == [ 'master' ]
        assert git.listBranches( remotes=True ) == [ 'master', 'topic' ]
        assert git.listRemoteBranches() == [ 'master', 'newtopic', 'topic' ]
        git.checkoutBranch( 'newtopic' )
        assert git.currentBranch() == 'newtopic'
        assert git.listBranches( remotes=True ) == [ 'master', 'newtopic', 'topic' ]
        assert git.listRemoteBranches() == [ 'master', 'newtopic', 'topic' ]

    def test_exception_if_checkout_branch_name_does_not_exist(self):
        ""
        git = GitInterface( self.url )
        assert git.listBranches() == [ 'master' ]
        git.checkoutBranch( 'topic' )
        self.assertRaises( GitInterfaceError, git.checkoutBranch, 'foobar' )

    def test_creating_a_branch(self):
        ""
        git = GitInterface( self.url )
        git.createRemoteBranch( 'nasa' )

        git = GitInterface()
        git.clone( self.url, 'check' )
        git.checkoutBranch( 'nasa' )
        assert util.readfile( 'check/file.txt' ).strip() == 'file contents'

    def create_a_branch_and_push_a_change(self, git):
        ""
        git.createRemoteBranch( 'nasa' )
        util.writefile( 'example/newfile.txt', 'new contents' )
        git.add( 'newfile.txt' )
        git.commit( 'add file to new branch' )
        git.push()

        git = GitInterface()
        git.clone( self.url, 'check' )
        git.checkoutBranch( 'nasa' )
        assert util.readfile( 'check/newfile.txt' ).strip() == 'new contents'

    def test_creating_a_branch_and_pushing_a_change(self):
        ""
        git = GitInterface( self.url )
        self.create_a_branch_and_push_a_change( git )

    def test_clone_specific_branch_then_create_a_branch_and_push(self):
        ""
        git = GitInterface()
        git.clone( self.url, branch='master' )
        self.create_a_branch_and_push_a_change( git )

    def test_create_branch_does_not_push_local_changes(self):
        ""
        git1 = GitInterface( self.url )
        util.writefile( 'example/file.txt', 'modified contents' )
        git1.add( 'file.txt' )
        git1.commit( 'modify file' )
        git1.createRemoteBranch( 'nasa' )

        git2 = GitInterface()
        git2.clone( self.url, 'check1' )
        git2.checkoutBranch( 'nasa' )
        assert util.readfile( 'check1/file.txt' ).strip() == 'file contents'

        git1.push()

        git2.pull()
        assert util.readfile( 'check1/file.txt' ).strip() == 'modified contents'

    def test_create_branch_within_a_single_branch_clone(self):
        ""
        git1 = GitInterface()
        git1.clone( self.url, branch='master' )
        git1.createRemoteBranch( 'nasa' )

        git2 = GitInterface()
        git2.clone( self.url, 'check1' )
        git2.checkoutBranch( 'nasa' )
        assert util.readfile( 'check1/file.txt' ).strip() == 'file contents'

        util.writefile( 'example/file.txt', 'modified contents' )
        git1.add( 'file.txt' )
        git1.commit( 'modify file' )
        git1.push()

        git2.pull()
        assert util.readfile( 'check1/file.txt' ).strip() == 'modified contents'

    def test_create_branch_that_already_exists_is_an_error(self):
        ""
        git = GitInterface( self.url )
        self.assertRaises( GitInterfaceError, git.createRemoteBranch, 'topic' )

    def test_create_branch_fails_if_current_branch_is_not_tracked(self):
        ""
        git = GitInterface( self.url )
        trigutil.create_local_branch( 'example', 'proximus' )
        assert git.currentBranch() == 'proximus'
        self.assertRaises( GitInterfaceError, git.createRemoteBranch, 'nasa' )

    def test_create_branch_of_same_name_as_current_branch_is_an_error(self):
        ""
        git = GitInterface( self.url )
        git.checkoutBranch( 'topic' )
        assert git.currentBranch() == 'topic'
        self.assertRaises( GitInterfaceError, git.createRemoteBranch, 'topic' )

    def test_create_branch_with_added_files_should_succeed(self):
        ""
        git = GitInterface( self.url )
        util.writefile( 'example/file.txt', 'modified contents' )
        git.add( 'file.txt' )
        git.createRemoteBranch( 'nasa' )

        git = GitInterface()
        git.clone( self.url, 'check' )
        git.checkoutBranch( 'nasa' )
        assert util.readfile( 'check/file.txt' ).strip() == 'file contents'

    def test_create_branch_with_modified_but_not_added_files_should_succeed(self):
        ""
        git = GitInterface( self.url )
        util.writefile( 'example/file.txt', 'modified contents' )
        git.createRemoteBranch( 'nasa' )

        git = GitInterface()
        git.clone( self.url, 'check' )
        git.checkoutBranch( 'nasa' )
        assert util.readfile( 'check/file.txt' ).strip() == 'file contents'

    def test_delete_remote_branch_while_on_master(self):
        ""
        git = GitInterface( self.url )
        assert 'topic' in git.listBranches( remotes=True )
        assert 'topic' in git.listRemoteBranches()
        git.deleteRemoteBranch( 'topic' )
        assert 'topic' not in git.listBranches( remotes=True )
        assert 'topic' not in git.listRemoteBranches()

        git = GitInterface()
        git.clone( self.url, 'ex2' )
        assert 'topic' not in git.listBranches( remotes=True )
        assert 'topic' not in git.listRemoteBranches()

    def test_delete_remote_branch_after_checking_it_out(self):
        ""
        git = GitInterface( self.url )
        git.checkoutBranch( 'topic' )
        git.checkoutBranch( 'master' )
        assert 'topic' in git.listBranches()
        assert 'topic' in git.listBranches( remotes=True )
        git.deleteRemoteBranch( 'topic' )
        assert 'topic' not in git.listBranches()
        assert 'topic' not in git.listBranches( remotes=True )
        assert 'topic' not in git.listRemoteBranches()

        git = GitInterface()
        git.clone( self.url, 'ex2' )
        assert 'topic' not in git.listBranches( remotes=True )
        assert 'topic' not in git.listRemoteBranches()

    def test_deleting_the_current_branch_is_an_error(self):
        ""
        git = GitInterface( self.url )
        git.checkoutBranch( 'topic' )
        self.assertRaises( GitInterfaceError, git.deleteRemoteBranch, 'topic' )


class pulling( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

        self.url = trigutil.create_bare_repo_with_topic_branch()
        time.sleep(1)

    def clone_twice_and_modify_and_push_file_txt(self):
        ""
        git1 = GitInterface()
        git1.clone( self.url, 'ex1' )

        git2 = GitInterface()
        git2.clone( self.url, 'ex2' )

        util.writefile( 'ex2/file.txt', 'modified contents' )
        git2.add( 'file.txt' )
        git2.commit( 'modify and push' )
        git2.push()

        return git1, git2

    def test_push_in_one_repo_and_pull_in_another(self):
        ""
        git1, git2 = self.clone_twice_and_modify_and_push_file_txt()

        # pull with no changes
        git1.pull()
        util.writefile( 'ex1/filetwo.txt', 'file two contents' )
        git1.add( 'filetwo.txt' )
        git1.commit( 'adding another file' )
        git1.push()

        time.sleep(1)
        assert util.readfile( 'ex1/file.txt' ).strip() == 'modified contents'

        # pull with unstaged changes
        util.writefile( 'ex2/something.txt', 'whatever' )
        git2.pull()
        git2.add( 'something.txt' )
        git2.commit( 'adding something' )
        git2.push()

        time.sleep(1)
        assert util.readfile( 'ex2/filetwo.txt' ).strip() == 'file two contents'

        # pull with committed changes
        util.writefile( 'ex1/filetwo.txt', 'for the third time!' )
        git1.add( 'filetwo.txt' )
        git1.commit( 'third change' )
        git1.pull()

        time.sleep(1)
        assert util.readfile( 'ex1/something.txt' ).strip() == 'whatever'

    def test_pull_will_fail_if_repo_is_currently_in_a_rebase_operation(self):
        ""
        git1, git2 = self.clone_twice_and_modify_and_push_file_txt()

        util.writefile( 'ex1/file.txt', 'also modified contents' )
        git1.add( 'file.txt' )
        git1.commit( 'this will conflict' )

        # let this fail due to a conflict
        x,out = runcmd( 'git pull', chdir='ex1', raise_on_error=False )
        assert x != 0

        # this should now fail because it is in the middle of a rebase operation
        self.assertRaises( GitInterfaceError, git1.pull )

    def test_the_repo_is_reset_after_a_pull_conflict(self):
        ""
        git1, git2 = self.clone_twice_and_modify_and_push_file_txt()

        util.writefile( 'ex1/file.txt', 'also modified contents' )
        git1.add( 'file.txt' )
        git1.commit( 'this will conflict' )

        self.assertRaises( GitInterfaceError, git1.pull )

        assert git1.currentBranch() == 'master'
        assert util.readfile( 'ex1/file.txt' ).strip() == 'also modified contents'


class orphan_branches( unittest.TestCase ):

    def setUp(self):
        ""
        util.setup_test()

    def test_copy_file_or_directory_to_current_directory(self):
        ""
        util.writefile( 'subdir/myfile.txt', 'hello my file' )
        src = os.path.abspath( 'subdir' )
        os.mkdir( 'destdir' ) ; dest = os.path.abspath( 'destdir' )
        util.writefile( 'subdir/adir/another.txt', 'what' )
        os.symlink( 'myfile.txt', 'subdir/linkfile' )
        time.sleep(1)

        cwd = os.getcwd()

        os.chdir( dest )
        f1 = copy_path_to_current_directory( src+'/adir' )
        f2 = copy_path_to_current_directory( src+'/myfile.txt' )
        f3 = copy_path_to_current_directory( src+'/linkfile' )

        time.sleep(1)

        assert util.readfile( 'adir/another.txt' ).strip() == 'what'
        assert f1 == 'adir'
        assert util.readfile( 'myfile.txt' ).strip() == 'hello my file'
        assert f2 == 'myfile.txt'
        assert os.path.islink( 'linkfile' )
        assert os.readlink( 'linkfile' ) == 'myfile.txt'
        assert f3 == 'linkfile'

    def test_create_orphan_branch(self):
        ""
        self.run_create_orphan_branch_test()

    def test_clone_master_only_then_create_orphan_branch(self):
        ""
        self.run_create_orphan_branch_test( 'master' )

    def run_create_orphan_branch_test(self, initial_branchname=None):
        ""
        url = trigutil.create_bare_repo_with_topic_branch()
        util.writefile( 'readme.txt', 'this is adam' )
        time.sleep(1)

        git = GitInterface()
        git.clone( url, 'ex', initial_branchname )
        git.createRemoteOrphanBranch( 'loner', 'start fresh', 'readme.txt' )

        assert git.currentBranch() == 'loner'
        assert 'loner' in git.listRemoteBranches()
        fL = glob.glob( 'ex/*' )
        assert len( fL ) == 1 and fL[0] == 'ex/readme.txt'

        git.checkoutBranch( 'master' )
        assert not os.path.exists( 'ex/readme.txt' )
        assert util.readfile( 'ex/file.txt' ).strip() == 'file contents'

        git2 = GitInterface()
        git2.clone( url, 'ex2', branch='loner' )
        fL = glob.glob( 'ex2/*' )
        assert len( fL ) == 1 and fL[0] == 'ex2/readme.txt'

    def test_orphan_branch_creation_errors(self):
        ""
        url = trigutil.create_bare_repo_with_topic_branch()
        trigutil.push_file_to_repo( url, 'file.txt', 'new contents' )

        util.writefile( 'readme.txt', 'this is adam' )
        time.sleep(1)

        git = GitInterface( url )
        trigutil.checkout_to_previous_sha1( git.getRootPath() )

        self.assertRaises( GitInterfaceError,
            git.createRemoteOrphanBranch, 'loner', 'start it', 'readme.txt' )

        git.clone( url, 'ex2' )
        assert git.currentBranch() == 'master'
        self.assertRaises( GitInterfaceError,
            git.createRemoteOrphanBranch, 'topic', 'start it', 'readme.txt' )


#######################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
