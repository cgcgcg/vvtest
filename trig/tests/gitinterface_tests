#!/usr/bin/env python

# Copyright 2018 National Technology & Engineering Solutions of Sandia, LLC
# (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.
# Government retains certain rights in this software.

#RUNTEST:

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
from os.path import abspath
import time
import shutil
import glob
import filecmp
import unittest

import trigtestutils as trigutil
import testutils as util
from testutils import print3

from gitinterface import GitInterfaceError, GitInterface
from gitinterface import set_environ, change_directory
from gitinterface import copy_path_to_current_directory
from gitinterface import runcmd
from gitinterface import safe_repository_mirror
from gitinterface import repository_url_match
from gitinterface import is_a_local_repository
from gitinterface import verify_repository_url
from gitinterface import repo_name_from_url


class with_set_environ( trigutil.trigTestCase ):

    def setUp(self):
        ""
        trigutil.trigTestCase.setUp( self, cleanout=False )

    def test_setting_no_names_should_not_change_environ(self):
        ""
        orig = dict( os.environ )

        with set_environ():
            state = dict( os.environ )

        self.assertEqual( orig, os.environ )
        self.assertEqual( orig, state )

    def test_setting_a_new_name_should_get_set_then_unset(self):
        ""
        orig = dict( os.environ )
        assert 'MY_SPECIAL_NAME' not in os.environ

        with set_environ( MY_SPECIAL_NAME='my special value' ):
            state = dict( os.environ )

        self.assertEqual( orig, os.environ )
        assert state['MY_SPECIAL_NAME'] == 'my special value'

    def test_a_value_of_None_causes_an_unset(self):
        ""
        orig = dict( os.environ )
        os.environ['MY_SPECIAL_NAME'] = 'my special value'

        assert 'MY_SPECIAL_NAME' in os.environ

        with set_environ( MY_SPECIAL_NAME=None ):
            state = dict( os.environ )

        assert os.environ['MY_SPECIAL_NAME'] == 'my special value'
        assert 'MY_SPECIAL_NAME' not in state

        del os.environ['MY_SPECIAL_NAME']

    def test_unset_has_no_affect_if_not_already_defined(self):
        ""
        orig = dict( os.environ )
        assert 'MY_SPECIAL_NAME' not in os.environ

        with set_environ( MY_SPECIAL_NAME=None ):
            state = dict( os.environ )

        assert 'MY_SPECIAL_NAME' not in state
        self.assertEqual( orig, state )


class create_and_clone( trigutil.trigTestCase ):

    def test_create_repository_in_existing_directory(self):
        ""
        git = GitInterface()
        git.create()

        time.sleep(1)
        assert os.path.exists( '.git/config' )

    def test_create_repository_in_a_new_directory(self):
        ""
        git = GitInterface()
        git.create( 'newrepo' )

        time.sleep(1)
        assert not os.path.exists( '.git' )
        assert os.path.exists( 'newrepo/.git/config' )

    def write_git_wrapper(self):
        ""
        touchfile = abspath( 'touchfile.txt' )
        util.writescript( 'mygit/gitwrapper', """
            #!"""+sys.executable+"""
            import os, sys, subprocess
            fp = open( '"""+touchfile+"""', 'w' )
            prox = os.environ.get( 'https_proxy', 'None' )
            fp.write( 'https_proxy=' + prox + os.linesep )
            prox = os.environ.get( 'HTTPS_PROXY', 'None' )
            fp.write( 'HTTPS_PROXY=' + prox + os.linesep )
            fp.close()
            x = subprocess.call( ' '.join( ['git']+sys.argv[1:] ), shell=True )
            assert x == 0
            """ )
        time.sleep(1)

    def test_specify_git_executable_to_use(self):
        ""
        self.write_git_wrapper()

        git = GitInterface( gitexe=abspath( 'mygit/gitwrapper' ) )
        git.create( 'newrepo' )

        time.sleep(1)
        assert os.path.exists( 'touchfile.txt' )
        assert os.path.exists( 'newrepo/.git/config' )

    def test_specify_https_proxy(self):
        ""
        self.write_git_wrapper()

        with set_environ( https_proxy=None, HTTPS_PROXY=None ):

            url = trigutil.create_local_bare_repository( 'example' )
            trigutil.push_file_to_repo( url, 'file.txt', 'file contents' )

            assert 'https_proxy' not in os.environ
            assert 'HTTPS_PROXY' not in os.environ

            git = GitInterface( gitexe=abspath( 'mygit/gitwrapper' ),
                                https_proxy='fakeurl://some/thing' )
            git.clone( url )
            git.currentBranch()

        assert len( util.grepfiles( 'https_proxy=fakeurl://some/thing',
                                    'touchfile.txt' ) ) == 1
        assert len( util.grepfiles( 'HTTPS_PROXY=fakeurl://some/thing',
                                    'touchfile.txt' ) ) == 1

    def test_create_bare_repository(self):
        ""
        git = GitInterface()
        git.create( 'newrepo.git', bare=True )
        assert git.isBare()

        time.sleep(1)
        lineL = util.grepfiles( 'bare', 'newrepo.git/config' )
        assert len(lineL) == 1 and 'true' in lineL[0].lower()

    def test_clone_a_local_repository(self):
        ""
        url = trigutil.create_local_bare_repository( 'example' )
        trigutil.push_file_to_repo( url, 'file.txt', 'file contents' )

        git = GitInterface( origin_url=url )
        time.sleep(1)

        assert not git.isBare()
        assert len( util.grepfiles( 'example', 'example/.git/config' ) ) > 0
        assert len( util.grepfiles( 'file contents', 'example/file.txt' ) ) == 1

    def test_setting_root_directory_in_constructor(self):
        ""
        os.mkdir( 'adir' )
        time.sleep(1)

        bare_url = trigutil.create_local_bare_repository( 'example' )
        trigutil.push_file_to_repo( bare_url, 'file.txt', 'file contents' )

        with change_directory( 'adir' ):
            GitInterface( bare_url )

        git2 = GitInterface( rootdir='adir/example' )
        assert not git2.isBare()
        assert git2.currentBranch() == 'master'

    def test_using_quiet_option_to_repress_clone_error_message(self):
        ""
        url = 'file://'+abspath('fakerepo')
        os.mkdir( 'curdir' )
        time.sleep(1)
        os.chdir( 'curdir' )

        git = GitInterface()

        redir = util.RedirectStdout( 'stdout.log', 'stderr.log' )
        try:
            git.clone( url, quiet=True )
        except GitInterfaceError:
            caught = True
        except:
            redir.close()
            raise
        redir.close()

        assert caught
        assert not util.readfile( 'stdout.log' ).strip()
        assert not util.readfile( 'stderr.log' ).strip()

    def test_clone_master_branch_only(self):
        ""
        url = trigutil.create_bare_repo_with_topic_branch( 'example' )

        # default clone first; a checkout of the branch should succeed
        git = GitInterface()
        git.clone( url )
        runcmd( 'git checkout topic', chdir='example' )

        shutil.rmtree( 'example' )
        time.sleep(1)

        # clone with master only; a checkout of the branch should fail
        git = GitInterface()
        git.clone( url, branch='master' )
        self.assertRaises( GitInterfaceError,
            runcmd, 'git checkout topic', chdir='example' )

    def test_clone_into_a_subdirectory(self):
        ""
        url = trigutil.create_bare_repo_with_topic_branch( 'example' )

        git1 = GitInterface()
        url1 = git1.clone( url, rootdir='ex1' )

        git2 = GitInterface( url, rootdir='ex2' )

        git3 = GitInterface()
        url3 = git3.clone( url, rootdir='ex3', branch='topic' )

        fL = glob.glob( 'ex*/.git/config' )
        fL.sort()
        assert fL == ['ex1/.git/config', 'ex2/.git/config', 'ex3/.git/config']

        git = GitInterface()
        assert len( git.listRemoteBranches( url1 ) ) > 0
        assert len( git.listRemoteBranches( url3 ) ) > 0

    def test_getting_root_directory_without_clone(self):
        ""
        url = trigutil.create_bare_repo_with_topic_branch( 'example' )
        git1 = GitInterface( url, rootdir='ex1' )
        util.writefile( 'ex1/subdir/afile', 'my file' )
        git1.add( 'subdir' )
        git1.commit( 'add subdir' )
        git1.push()

        GitInterface( url )

        root = os.path.abspath( 'example' )

        git = GitInterface()

        os.chdir( 'example' )
        assert os.path.samefile( git.getRootDir(), root )

        os.chdir( 'subdir' )
        assert os.path.samefile( git.getRootDir(), root )

        os.chdir( '/' )
        self.assertRaises( GitInterfaceError, git.getRootDir )

    def test_a_bare_clone_can_be_cloned(self):
        ""
        os.mkdir( 'baredir' )
        time.sleep(1)

        url = trigutil.create_bare_repo_with_topic_branch( 'example' )

        bare_url = self.make_bare_clone_in_subdirectory( url, 'baredir' )
        assert os.path.isdir( 'baredir/example.git' )
        assert not os.path.exists( 'baredir/example.git/.git' )

        git = GitInterface( bare_url )
        assert util.readfile( 'example/file.txt' ).strip() == 'file contents'

    def make_bare_clone_in_subdirectory(self, origin_url, subdir):
        ""
        git_bare = GitInterface()

        with change_directory( subdir ):
            git_bare.clone( origin_url, bare=True )

        return 'file://'+git_bare.getRootDir()

    def test_a_bare_clone_into_a_specified_directory(self):
        ""
        url = trigutil.create_bare_repo_with_topic_branch( 'example' )

        git_bare = GitInterface()
        git_bare.clone( url, rootdir='bare_clone_subdir', bare=True )
        assert os.path.isdir( 'bare_clone_subdir' )
        assert not os.path.exists( 'bare_clone_subdir/.git' )
        bare_url = 'file://'+git_bare.getRootDir()

        git = GitInterface( bare_url, rootdir='checkrepo' )
        assert util.readfile( 'checkrepo/file.txt' ).strip() == 'file contents'

    def test_can_push_to_a_bare_clone(self):
        ""
        os.mkdir( 'baredir' )
        time.sleep(1)

        url = trigutil.create_bare_repo_with_topic_branch( 'example' )

        bare_url = self.make_bare_clone_in_subdirectory( url, 'baredir' )

        git = GitInterface( bare_url )
        assert 'baredir' in git.getRemoteURL()
        util.writefile( 'example/file.txt', "yep ;)" )
        git.add( 'file.txt' )
        git.commit( 'cool message' )
        git.push()

        git2 = GitInterface( bare_url, rootdir='checkrepo' )
        assert util.readfile( 'checkrepo/file.txt' ).strip() == 'yep ;)'

    def test_can_push_from_a_bare_clone(self):
        ""
        orig_url = trigutil.create_bare_repo_with_topic_branch( 'example' )

        bare_git = GitInterface()
        bare_git.clone( orig_url, rootdir='bareclone', bare=True )
        bare_url = 'file://'+bare_git.getRootDir()

        git = GitInterface( bare_url, rootdir='pushclone' )
        util.writefile( 'pushclone/file.txt', "make a mod" )
        git.add( 'file.txt' )
        git.commit( 'a msg' )
        git.push()

        bare_git.push()

        GitInterface( orig_url, rootdir='checkrepo' )
        assert util.readfile( 'checkrepo/file.txt' ).strip() == 'make a mod'

    def test_a_bare_clone_gets_all_branches_and_tags(self):
        ""
        orig_url = trigutil.create_bare_repo_with_topic_branch( 'example', tag='atag' )

        bare_git = GitInterface()
        bare_git.clone( orig_url, rootdir='bareclone', bare=True )
        bare_url = 'file://'+bare_git.getRootDir()

        branchL = bare_git.listBranches()
        assert branchL == [ 'master', 'topic' ]

        tagL = bare_git.listTags()
        assert tagL == [ 'atag' ]

    def test_can_push_all_branches_from_a_bare_clone(self):
        ""
        orig_url = trigutil.create_bare_repo_with_topic_branch( 'example' )

        bare_git = GitInterface()
        bare_git.clone( orig_url, rootdir='bareclone', bare=True )
        bare_url = 'file://'+bare_git.getRootDir()

        trigutil.push_new_branch_with_file( bare_url, 'whatever',
                                            'file2.md', 'some content' )

        bare_git.push( all_branches=True )

        git2 = GitInterface( orig_url, rootdir='checkrepo' )
        git2.checkoutBranch( 'whatever' )
        assert util.readfile( 'checkrepo/file2.md' ).strip() == 'some content'
        git2.checkoutBranch( 'topic' )
        assert not os.path.exists( 'checkrepo/file2.md' )
        assert os.path.exists( 'checkrepo/file.txt' )

    def test_can_push_all_tags_from_a_bare_clone(self):
        ""
        orig_url = trigutil.create_bare_repo_with_topic_branch( 'example', tag='atag' )

        bare_git = GitInterface()
        bare_git.clone( orig_url, rootdir='bareclone', bare=True )
        bare_url = 'file://'+bare_git.getRootDir()

        trigutil.push_file_to_repo( bare_url, 'newfile.txt', 'new junk' )
        trigutil.push_tag_to_repo( bare_url, 'sosad' )

        bare_git.push( all_tags=True )

        git2 = GitInterface( orig_url, rootdir='checkrepo' )
        tagL = git2.listTags()
        assert tagL == [ 'atag', 'sosad' ]

    def test_pushing_to_a_different_repository(self):
        ""
        orig_url = trigutil.create_bare_repo_with_topic_branch( 'example' )

        bare_git = GitInterface()
        bare_git.clone( orig_url, rootdir='bareclone', bare=True )
        bare_url = 'file://'+bare_git.getRootDir()

        git = GitInterface( bare_url, rootdir='workclone' )
        util.writefile( 'workclone/file.txt', 'modify this guy' )
        git.add( 'file.txt' )
        git.commit( 'a mod' )

        git.push( repository=orig_url )

        GitInterface( orig_url, rootdir='checkclone' )
        assert util.readfile( 'checkclone/file.txt' ).strip() == 'modify this guy'

        GitInterface( bare_url, rootdir='checktwo' )
        assert util.readfile( 'checktwo/file.txt' ).strip() == 'file contents'

        git.createRemoteBranch( 'newbranch' )
        util.writefile( 'workclone/file.txt', 'branch mod' )
        git.add( 'file.txt' )
        git.commit( 'b mod' )

        git.push( all_branches=True, repository=orig_url )

        chkit = GitInterface( orig_url, rootdir='checkclone2' )
        chkit.checkoutBranch( 'newbranch' )
        assert util.readfile( 'checkclone2/file.txt' ).strip() == 'branch mod'

    def test_verbose_prints_git_command_and_output(self):
        ""
        orig_url = trigutil.create_bare_repo_with_topic_branch( 'example' )

        git,out,err = util.call_capture_output( GitInterface,
                                                orig_url, verbose=True )
        out += err
        print3( out )
        assert 'clone' in out and 'example' in out

        rtn,out,err = util.call_capture_output( git.checkoutBranch, 'topic' )
        out += err
        print3( out )
        assert 'checkout' in out and 'topic' in out

        rtn,out,err = util.call_capture_output( git.currentBranch )
        out += err
        print3( out )
        assert rtn == 'topic'
        assert 'branch' in out and 'topic' in out


class commit_and_push( trigutil.trigTestCase ):

    def test_create_repo_and_commit_a_file(self):
        ""
        util.writefile( 'grepo/file.txt', "file contents" )
        time.sleep(1)

        git = GitInterface()
        git.create( 'grepo' )
        git.add( 'file.txt' )
        git.commit( 'first commit message' )

    def test_commit_and_push_a_new_file(self):
        ""
        url = trigutil.create_local_bare_repository( 'myrepo' )
        trigutil.push_file_to_repo( url, 'file.txt', 'file contents' )
        time.sleep(1)

        git = GitInterface( origin_url=url )
        util.writefile( 'myrepo/another.txt', 'another contents' )
        git.add( 'another.txt' )
        git.commit( 'adding file' )
        git.push()

        assert len( util.grepfiles( 'another', 'myrepo/another.txt' ) ) == 1

        shutil.rmtree( 'myrepo' )
        time.sleep(1)

        git = GitInterface( url )
        assert len( util.grepfiles( 'file', 'myrepo/file.txt' ) ) == 1
        assert len( util.grepfiles( 'another', 'myrepo/another.txt' ) ) == 1

    def test_add_commit_push_every_changed_file_in_a_directory(self):
        ""
        url = trigutil.create_bare_repo_with_topic_branch( 'example' )

        git = GitInterface( url )

        util.writefile( 'example/adir/afile.txt', 'whatever' )
        git.add( 'adir/afile.txt' )
        git.commit( 'create directory' )
        git.push()

        util.writefile( 'example/adir/afile.txt', 'changed' )
        util.writefile( 'example/adir/newfile.txt', 'brand spanking new' )
        util.writefile( 'example/adir/deep/file.txt', 'further down' )
        time.sleep(1)

        git.add( 'adir' )
        git.commit( 'add everything under adir' )
        git.push()

        time.sleep(1)
        git2 = GitInterface( url, 'check' )
        assert os.path.isfile( 'check/adir/deep/file.txt' )
        assert util.readfile( 'check/adir/afile.txt' ).strip() == 'changed'


class branches( trigutil.trigTestCase ):

    def setUp(self):
        ""
        trigutil.trigTestCase.setUp( self )

        self.url = trigutil.create_bare_repo_with_topic_branch( 'example' )
        time.sleep(1)

    def test_listing_branches(self):
        ""
        os.mkdir( 'default' )
        os.mkdir( 'single' )
        time.sleep(1)

        git = GitInterface()
        assert git.listRemoteBranches( self.url ) == [ 'master', 'topic' ]
        self.assertRaises( GitInterfaceError, git.listRemoteBranches )

        os.chdir( 'default' )
        git = GitInterface( self.url )
        assert git.listBranches() == [ 'master' ]
        assert git.listBranches( remotes=True ) == [ 'master', 'topic' ]
        assert git.listRemoteBranches( self.url ) == [ 'master', 'topic' ]
        assert git.listRemoteBranches() == [ 'master', 'topic' ]

        os.chdir( '../single' )
        git = GitInterface()
        git.clone( self.url, branch='topic' )
        assert git.listBranches() == [ 'topic' ]
        # the fetch entry in .git/config limits the remote listing
        assert git.listBranches( remotes=True ) == [ 'topic' ]
        # but listRemoteBranches() is immune
        assert git.listRemoteBranches( self.url ) == [ 'master', 'topic' ]
        assert git.listRemoteBranches() == [ 'master', 'topic' ]

    def test_determine_current_branch(self):
        ""
        git = GitInterface( self.url )
        assert git.currentBranch() == 'master'

        git.checkoutBranch( 'topic' )
        assert git.currentBranch() == 'topic'

        git = GitInterface()
        os.chdir( 'example' )
        git.currentBranch() == 'topic'

    def test_getting_current_branch_fails_if_not_in_a_local_repository(self):
        ""
        git = GitInterface()
        self.assertRaises( GitInterfaceError, git.currentBranch )

    def test_current_branch_returns_None_if_in_detached_HEAD_state(self):
        ""
        trigutil.push_file_to_repo( self.url, 'file.txt', 'new contents' )

        git = GitInterface( self.url )
        trigutil.checkout_to_previous_sha1( git.getRootDir() )
        assert git.currentBranch() == None

    def test_current_branch_fails_if_done_right_after_git_init(self):
        ""
        os.mkdir( 'arepo' )
        time.sleep(1)

        os.chdir( 'arepo' )
        runcmd( 'git init' )

        git = GitInterface()
        self.assertRaises( GitInterfaceError, git.currentBranch )

    def test_a_push_fails_if_not_on_a_branch(self):
        ""
        trigutil.push_file_to_repo( self.url, 'file.txt', 'new contents' )

        git = GitInterface( self.url )
        trigutil.checkout_to_previous_sha1( git.getRootDir() )
        assert git.currentBranch() == None
        self.assertRaises( GitInterfaceError, git.push )

    def test_clone_followed_by_a_new_branch_showing_up_on_remote(self):
        ""
        git = GitInterface( self.url )
        assert git.listBranches() == [ 'master' ]
        assert git.listBranches( remotes=True ) == [ 'master', 'topic' ]
        assert git.listRemoteBranches() == [ 'master', 'topic' ]

        trigutil.push_new_branch_with_file( self.url, 'newtopic',
                                            'file.txt', 'redo' )
        time.sleep(1)

        assert git.listBranches() == [ 'master' ]
        assert git.listBranches( remotes=True ) == [ 'master', 'topic' ]
        assert git.listRemoteBranches() == [ 'master', 'newtopic', 'topic' ]
        git.checkoutBranch( 'newtopic' )
        assert git.currentBranch() == 'newtopic'
        assert git.listBranches( remotes=True ) == [ 'master', 'newtopic', 'topic' ]
        assert git.listRemoteBranches() == [ 'master', 'newtopic', 'topic' ]

    def test_exception_if_checkout_branch_name_does_not_exist(self):
        ""
        git = GitInterface( self.url )
        assert git.listBranches() == [ 'master' ]
        git.checkoutBranch( 'topic' )
        self.assertRaises( GitInterfaceError, git.checkoutBranch, 'foobar' )

    def test_creating_a_local_branch(self):
        ""
        git = GitInterface( self.url )
        git.createBranch( 'justme' )
        assert git.currentBranch() == 'justme'

        util.writefile( 'example/file.txt', 'branch contents' )
        git.add( 'file.txt' )
        git.commit( 'mod to file on branch' )
        git.checkoutBranch( 'master' )

        git2 = GitInterface( 'example', 'checkrepo' )
        assert 'justme' not in git2.listBranches()
        assert 'justme' in git2.listRemoteBranches()
        git2.checkoutBranch( 'justme' )
        assert util.readfile( 'checkrepo/file.txt' ).strip() == 'branch contents'

    def test_create_local_branch_fails_if_branch_already_exists(self):
        ""
        git = GitInterface( self.url )
        git.checkoutBranch( 'topic' )
        git.checkoutBranch( 'master' )

        self.assertRaises( GitInterfaceError, git.createBranch, 'topic' )
        assert git.currentBranch() == 'master'

    def test_creating_a_remote_branch(self):
        ""
        git = GitInterface( self.url )
        git.createRemoteBranch( 'nasa' )

        git = GitInterface( self.url, 'check' )
        git.checkoutBranch( 'nasa' )
        assert util.readfile( 'check/file.txt' ).strip() == 'file contents'

    def create_a_remote_branch_and_push_a_change(self, git):
        ""
        git.createRemoteBranch( 'nasa' )
        util.writefile( 'example/newfile.txt', 'new contents' )
        git.add( 'newfile.txt' )
        git.commit( 'add file to new branch' )
        git.push()

        git = GitInterface( self.url, 'check' )
        git.checkoutBranch( 'nasa' )
        assert util.readfile( 'check/newfile.txt' ).strip() == 'new contents'

    def test_creating_a_remote_branch_and_pushing_a_change(self):
        ""
        git = GitInterface( self.url )
        self.create_a_remote_branch_and_push_a_change( git )

    def test_clone_specific_branch_then_create_a_remote_branch_and_push(self):
        ""
        git = GitInterface()
        git.clone( self.url, branch='master' )
        self.create_a_remote_branch_and_push_a_change( git )

    def test_create_remote_branch_does_not_push_local_changes(self):
        ""
        git1 = GitInterface( self.url )
        util.writefile( 'example/file.txt', 'modified contents' )
        git1.add( 'file.txt' )
        git1.commit( 'modify file' )
        git1.createRemoteBranch( 'nasa' )

        git2 = GitInterface( self.url, 'check1' )
        git2.checkoutBranch( 'nasa' )
        assert util.readfile( 'check1/file.txt' ).strip() == 'file contents'

        git1.push()

        git2.pull()
        assert util.readfile( 'check1/file.txt' ).strip() == 'modified contents'

    def test_create_remote_branch_within_a_single_branch_clone(self):
        ""
        git1 = GitInterface()
        git1.clone( self.url, branch='master' )
        git1.createRemoteBranch( 'nasa' )

        git2 = GitInterface( self.url, 'check1' )
        git2.checkoutBranch( 'nasa' )
        assert util.readfile( 'check1/file.txt' ).strip() == 'file contents'

        util.writefile( 'example/file.txt', 'modified contents' )
        git1.add( 'file.txt' )
        git1.commit( 'modify file' )
        git1.push()

        git2.pull()
        assert util.readfile( 'check1/file.txt' ).strip() == 'modified contents'

    def test_create_remote_branch_that_already_exists_is_an_error(self):
        ""
        git = GitInterface( self.url )
        self.assertRaises( GitInterfaceError, git.createRemoteBranch, 'topic' )

    def test_create_remote_branch_fails_if_current_branch_is_not_tracked(self):
        ""
        git = GitInterface( self.url )
        trigutil.create_local_branch( 'example', 'proximus' )
        assert git.currentBranch() == 'proximus'
        self.assertRaises( GitInterfaceError, git.createRemoteBranch, 'nasa' )

    def test_create_remote_branch_of_same_name_as_current_branch_is_an_error(self):
        ""
        git = GitInterface( self.url )
        git.checkoutBranch( 'topic' )
        assert git.currentBranch() == 'topic'
        self.assertRaises( GitInterfaceError, git.createRemoteBranch, 'topic' )

    def test_create_remote_branch_with_added_files_should_succeed(self):
        ""
        git = GitInterface( self.url )
        util.writefile( 'example/file.txt', 'modified contents' )
        git.add( 'file.txt' )
        git.createRemoteBranch( 'nasa' )

        git = GitInterface( self.url, 'check' )
        git.checkoutBranch( 'nasa' )
        assert util.readfile( 'check/file.txt' ).strip() == 'file contents'

    def test_create_remote_branch_with_modified_but_not_added_files_should_succeed(self):
        ""
        git = GitInterface( self.url )
        util.writefile( 'example/file.txt', 'modified contents' )
        git.createRemoteBranch( 'nasa' )

        git = GitInterface( self.url, 'check' )
        git.checkoutBranch( 'nasa' )
        assert util.readfile( 'check/file.txt' ).strip() == 'file contents'

    def test_delete_remote_branch_while_on_master(self):
        ""
        git = GitInterface( self.url )
        assert 'topic' in git.listBranches( remotes=True )
        assert 'topic' in git.listRemoteBranches()
        git.deleteRemoteBranch( 'topic' )
        assert 'topic' not in git.listBranches( remotes=True )
        assert 'topic' not in git.listRemoteBranches()

        git = GitInterface( self.url, 'ex2' )
        assert 'topic' not in git.listBranches( remotes=True )
        assert 'topic' not in git.listRemoteBranches()

    def test_delete_remote_branch_after_checking_it_out(self):
        ""
        git = GitInterface( self.url )
        git.checkoutBranch( 'topic' )
        git.checkoutBranch( 'master' )
        assert 'topic' in git.listBranches()
        assert 'topic' in git.listBranches( remotes=True )
        git.deleteRemoteBranch( 'topic' )
        assert 'topic' not in git.listBranches()
        assert 'topic' not in git.listBranches( remotes=True )
        assert 'topic' not in git.listRemoteBranches()

        git = GitInterface( self.url, 'ex2' )
        assert 'topic' not in git.listBranches( remotes=True )
        assert 'topic' not in git.listRemoteBranches()

    def test_deleting_the_current_branch_is_an_error(self):
        ""
        git = GitInterface( self.url )
        git.checkoutBranch( 'topic' )
        self.assertRaises( GitInterfaceError, git.deleteRemoteBranch, 'topic' )


class pulling( trigutil.trigTestCase ):

    def setUp(self):
        ""
        trigutil.trigTestCase.setUp( self )

        self.url = trigutil.create_bare_repo_with_topic_branch( 'example' )
        time.sleep(1)

    def clone_twice_and_modify_and_push_file_txt(self):
        ""
        git1 = GitInterface( self.url, 'ex1' )
        git2 = GitInterface( self.url, 'ex2' )

        util.writefile( 'ex2/file.txt', 'modified contents' )
        git2.add( 'file.txt' )
        git2.commit( 'modify and push' )
        git2.push()

        return git1, git2

    def test_push_in_one_repo_and_pull_in_another(self):
        ""
        git1, git2 = self.clone_twice_and_modify_and_push_file_txt()

        # pull with no changes
        git1.pull()
        util.writefile( 'ex1/filetwo.txt', 'file two contents' )
        git1.add( 'filetwo.txt' )
        git1.commit( 'adding another file' )
        git1.push()

        time.sleep(1)
        assert util.readfile( 'ex1/file.txt' ).strip() == 'modified contents'

        # pull with unstaged changes
        util.writefile( 'ex2/something.txt', 'whatever' )
        git2.pull()
        git2.add( 'something.txt' )
        git2.commit( 'adding something' )
        git2.push()

        time.sleep(1)
        assert util.readfile( 'ex2/filetwo.txt' ).strip() == 'file two contents'

        # pull with committed changes
        util.writefile( 'ex1/filetwo.txt', 'for the third time!' )
        git1.add( 'filetwo.txt' )
        git1.commit( 'third change' )
        git1.pull()

        time.sleep(1)
        assert util.readfile( 'ex1/something.txt' ).strip() == 'whatever'

    def test_pull_will_fail_if_repo_is_currently_in_a_rebase_operation(self):
        ""
        git1, git2 = self.clone_twice_and_modify_and_push_file_txt()

        util.writefile( 'ex1/file.txt', 'also modified contents' )
        git1.add( 'file.txt' )
        git1.commit( 'this will conflict' )

        # let this fail due to a conflict
        x,out = runcmd( 'git pull', chdir='ex1', raise_on_error=False )
        assert x != 0

        # this should now fail because it is in the middle of a rebase operation
        self.assertRaises( GitInterfaceError, git1.pull )

    def test_the_repo_is_reset_after_a_pull_conflict(self):
        ""
        git1, git2 = self.clone_twice_and_modify_and_push_file_txt()

        util.writefile( 'ex1/file.txt', 'also modified contents' )
        git1.add( 'file.txt' )
        git1.commit( 'this will conflict' )

        self.assertRaises( GitInterfaceError, git1.pull )

        assert git1.currentBranch() == 'master'
        assert util.readfile( 'ex1/file.txt' ).strip() == 'also modified contents'


class orphan_branches( trigutil.trigTestCase ):

    def test_copy_file_or_directory_to_current_directory(self):
        ""
        util.writefile( 'subdir/myfile.txt', 'hello my file' )
        src = os.path.abspath( 'subdir' )
        os.mkdir( 'destdir' ) ; dest = os.path.abspath( 'destdir' )
        util.writefile( 'subdir/adir/another.txt', 'what' )
        os.symlink( 'myfile.txt', 'subdir/linkfile' )
        time.sleep(1)

        cwd = os.getcwd()

        os.chdir( dest )
        f1 = copy_path_to_current_directory( src+'/adir' )
        f2 = copy_path_to_current_directory( src+'/myfile.txt' )
        f3 = copy_path_to_current_directory( src+'/linkfile' )

        time.sleep(1)

        assert util.readfile( 'adir/another.txt' ).strip() == 'what'
        assert f1 == 'adir'
        assert util.readfile( 'myfile.txt' ).strip() == 'hello my file'
        assert f2 == 'myfile.txt'
        assert os.path.islink( 'linkfile' )
        assert os.readlink( 'linkfile' ) == 'myfile.txt'
        assert f3 == 'linkfile'

    def test_create_orphan_branch(self):
        ""
        self.run_create_orphan_branch_test()

    def test_clone_master_only_then_create_orphan_branch(self):
        ""
        self.run_create_orphan_branch_test( 'master' )

    def run_create_orphan_branch_test(self, initial_branchname=None):
        ""
        url = trigutil.create_bare_repo_with_topic_branch( 'example' )
        util.writefile( 'readme.txt', 'this is adam' )
        time.sleep(1)

        git = GitInterface()
        git.clone( url, 'ex', initial_branchname )
        git.createRemoteOrphanBranch( 'loner', 'start fresh', 'readme.txt' )

        assert git.currentBranch() == 'loner'
        assert 'loner' in git.listRemoteBranches()
        fL = glob.glob( 'ex/*' )
        assert len( fL ) == 1 and fL[0] == 'ex/readme.txt'

        git.checkoutBranch( 'master' )
        assert not os.path.exists( 'ex/readme.txt' )
        assert util.readfile( 'ex/file.txt' ).strip() == 'file contents'

        git2 = GitInterface()
        git2.clone( url, 'ex2', branch='loner' )
        fL = glob.glob( 'ex2/*' )
        assert len( fL ) == 1 and fL[0] == 'ex2/readme.txt'

    def test_orphan_branch_creation_errors(self):
        ""
        url = trigutil.create_bare_repo_with_topic_branch( 'example' )
        trigutil.push_file_to_repo( url, 'file.txt', 'new contents' )

        util.writefile( 'readme.txt', 'this is adam' )
        time.sleep(1)

        git = GitInterface( url )
        trigutil.checkout_to_previous_sha1( git.getRootDir() )

        self.assertRaises( GitInterfaceError,
            git.createRemoteOrphanBranch, 'loner', 'start it', 'readme.txt' )

        git.clone( url, 'ex2' )
        assert git.currentBranch() == 'master'
        self.assertRaises( GitInterfaceError,
            git.createRemoteOrphanBranch, 'topic', 'start it', 'readme.txt' )


class mirroring_repositories( trigutil.trigTestCase ):

    def test_copy_one_repo_to_a_second_empty_repo(self):
        ""
        src_url = trigutil.create_local_bare_repository( 'foobar', 'src' )
        trigutil.push_file_to_repo( src_url, 'file.txt', 'file contents' )

        cpy_url = trigutil.create_local_bare_repository( 'example', 'cpy' )

        safe_repository_mirror( src_url, cpy_url, verbose=True )

        time.sleep(1)
        git = GitInterface( cpy_url )
        assert util.readfile( 'example/file.txt' ).strip() == 'file contents'
        assert git.currentBranch() == 'master'

    def test_update_a_second_repo(self):
        ""
        src_url = trigutil.create_local_bare_repository( 'example' )
        trigutil.push_file_to_repo( src_url, 'file.txt', 'file contents' )

        git1 = GitInterface()
        cpy_url = git1.clone( src_url, rootdir='cpy', bare=True )

        trigutil.push_file_to_repo( src_url, 'file.txt', 'new contents' )

        safe_repository_mirror( src_url, cpy_url )

        time.sleep(1)
        git2 = GitInterface( cpy_url, rootdir='checkclone' )
        assert util.readfile( 'checkclone/file.txt' ).strip() == 'new contents'

    def test_that_branches_and_tags_are_copied(self):
        ""
        src_url = trigutil.create_bare_repo_with_topic_branch( 'example',
                                                               subdir='srcrepo',
                                                               tag='FANCYTAG' )

        cpy_url = trigutil.create_local_bare_repository( 'cpyrepo' )

        safe_repository_mirror( src_url, cpy_url )

        time.sleep(1)
        git = GitInterface()
        git.clone( cpy_url, rootdir='checkclone1', bare=True )
        assert git.listBranches() == ['master', 'topic']
        assert git.listTags() == ['FANCYTAG']

        trigutil.push_new_branch_with_file( src_url, 'coolbranch',
                                            'file.txt', 'cool contents' )
        trigutil.push_tag_to_repo( src_url, 'COOLTAG' )

        safe_repository_mirror( src_url, cpy_url )

        time.sleep(1)
        git = GitInterface()
        git.clone( cpy_url, rootdir='checkclone2', bare=True )
        assert git.listBranches() == ['coolbranch', 'master', 'topic']
        assert git.listTags() == ['COOLTAG', 'FANCYTAG']

    def test_update_a_second_repo_using_an_existing_working_repo(self):
        ""
        src_url = trigutil.create_bare_repo_with_topic_branch( 'example',
                                                               subdir='srcrepo',
                                                               tag='FANCYTAG' )

        cpy_url = trigutil.create_local_bare_repository( 'cpyrepo' )

        git = GitInterface()
        git.clone( src_url, rootdir='wrkclone', bare=True )
        wrkdir = git.getRootDir()

        # make work clone out-of-date
        trigutil.push_file_to_repo( src_url, 'file.txt', 'my contents' )
        trigutil.push_new_branch_with_file( src_url, 'coolbranch',
                                            'file.txt', 'cool contents' )
        trigutil.push_tag_to_repo( src_url, 'NEWTAG' )

        safe_repository_mirror( src_url, cpy_url, work_clone=wrkdir )

        time.sleep(1)
        git = GitInterface( cpy_url, rootdir='checkclone' )
        assert git.listRemoteBranches() == ['coolbranch', 'master', 'topic']
        assert git.listTags() == ['FANCYTAG', 'NEWTAG']
        assert util.readfile( 'checkclone/file.txt' ).strip() == 'my contents'

    def test_using_an_existing_working_non_bare_repo_is_an_error(self):
        ""
        src_url = trigutil.create_bare_repo_with_topic_branch( 'example',
                                                               subdir='srcrepo',
                                                               tag='FANCYTAG' )

        cpy_url = trigutil.create_local_bare_repository( 'cpyrepo' )

        git = GitInterface( src_url, rootdir='wrkclone' )
        wrkdir = git.getRootDir()

        self.assertRaises( GitInterfaceError,
                safe_repository_mirror, src_url, cpy_url, work_clone=wrkdir )

    def test_the_work_dir_will_be_created_if_it_doesnt_exist(self):
        ""
        src_url = trigutil.create_bare_repo_with_topic_branch( 'example',
                                                               subdir='srcrepo',
                                                               tag='FANCYTAG' )

        cpy_url = trigutil.create_local_bare_repository( 'cpyrepo' )

        wrkdir = 'workclone'
        safe_repository_mirror( src_url, cpy_url, work_clone=wrkdir )

        git = GitInterface( rootdir=wrkdir )
        assert git.isBare()

    def test_an_update_fails_if_history_would_be_changed(self):
        ""
        src_url = trigutil.create_bare_repo_with_topic_branch( 'example',
                                                               subdir='srcrepo',
                                                               tag='FANCYTAG' )

        cpy_url = trigutil.create_local_bare_repository( 'cpyrepo' )

        safe_repository_mirror( src_url, cpy_url )

        trigutil.push_file_to_repo( cpy_url, 'file.txt', 'careful...' )

        self.assertRaises( GitInterfaceError,
                safe_repository_mirror, src_url, cpy_url )


class misc_functions( trigutil.trigTestCase ):

    def test_repo_name_from_url(self):
        ""
        assert repo_name_from_url( 'foo/bar.git' ) == 'bar'
        assert repo_name_from_url( 'foo/bar' ) == 'bar'
        assert repo_name_from_url( 'foo/bar.git/' ) == 'bar'
        assert repo_name_from_url( 'foo/bar/' ) == 'bar'

    def test_function_repository_url_match(self):
        ""
        os.makedirs( 'subdir/deep' )
        os.mkdir( 'sub:dir' )
        url = trigutil.create_bare_repo_with_topic_branch( 'cool', 'barerepo' )
        GitInterface( url )
        GitInterface( url, 'mrdir/.mrgit' )
        git = GitInterface()
        git.clone( url, 'bare_mrdir/.mrgit.git', bare=True )
        time.sleep(1)

        assert repository_url_match( 'file:///foo/bar' )
        assert repository_url_match( 'http://host.xx/path' )
        assert repository_url_match( 'https://host.xx/path' )
        assert repository_url_match( 'ssh://host.xx/path' )
        assert repository_url_match( 'git://host.xx/path' )
        assert repository_url_match( 'ftp://host.xx/path' )
        assert repository_url_match( 'ftps://host.xx/path' )

        assert repository_url_match( 'sub:dir' )
        assert not repository_url_match( './sub:dir' )
        assert repository_url_match( 'host.xx:path/to/repo.git' )
        assert repository_url_match( 'usrname@host.xx:/path/to/repo.git' )

        assert not repository_url_match( 'barerepo/cool.git' )
        assert not repository_url_match( abspath( 'barerepo/cool.git' ) )
        assert not repository_url_match( 'cool' )
        assert not repository_url_match( abspath( 'cool' ) )
        assert not repository_url_match( 'subdir' )
        assert not repository_url_match( 'subdir/deep' )

        assert not os.path.exists( 'mrdir/.git' )
        assert not os.path.exists( 'mrdir/config' )
        assert not repository_url_match( 'mrdir' )
        assert not os.path.exists( 'bare_mrdir/.git' )
        assert not os.path.exists( 'bare_mrdir/config' )
        assert not repository_url_match( 'bare_mrdir' )

    def test_function_is_a_local_repository(self):
        ""
        url = trigutil.create_bare_repo_with_topic_branch( 'cool', 'barerepo' )
        GitInterface( url )
        time.sleep(1)

        assert not is_a_local_repository( 'barerepo' )
        assert is_a_local_repository( 'barerepo/cool.git' )
        assert is_a_local_repository( abspath( 'barerepo/cool.git' ) )
        assert is_a_local_repository( 'barerepo/cool' )
        assert is_a_local_repository( abspath( 'barerepo/cool' ) )

        assert is_a_local_repository( 'cool' )
        assert is_a_local_repository( abspath( 'cool' ) )

    def test_function_verify_repository_url(self):
        ""
        url = trigutil.create_bare_repo_with_topic_branch( 'cool', 'barerepo' )
        git = GitInterface()
        git.clone( url, rootdir='dir1/coolclone' )
        git.clone( url, rootdir='dir2/bareclone.git', bare=True )
        time.sleep(1)

        assert os.path.isdir( 'dir1/coolclone' )
        assert os.path.isdir( 'dir2/bareclone.git' )

        pre = 'file://'+os.getcwd()

        assert not verify_repository_url( 'barerepo' )
        assert not verify_repository_url( pre+'/barerepo' )
        assert not verify_repository_url( 'dir1' )
        assert not verify_repository_url( pre+'/dir1' )
        assert not verify_repository_url( 'dir2' )
        assert not verify_repository_url( pre+'/dir2' )

        assert verify_repository_url( 'dir1/coolclone' )
        assert verify_repository_url( os.path.abspath('dir1/coolclone') )
        assert verify_repository_url( 'dir2/bareclone' )
        assert verify_repository_url( os.path.abspath('dir2/bareclone') )

        assert verify_repository_url( pre+'/dir1/coolclone' )
        assert verify_repository_url( pre+'/dir2/bareclone.git' )
        assert verify_repository_url( pre+'/dir2/bareclone' )


#######################################################################

util.run_test_cases( sys.argv, sys.modules[__name__] )
