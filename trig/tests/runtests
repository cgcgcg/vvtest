#!/usr/bin/env python

import sys
sys.dont_write_bytecode = True
sys.excepthook = sys.__excepthook__
import os
import getopt
import subprocess
import time


help_string = """
NAME
    runtests - run the unit tests contained in this directory

SYNOPSIS
    1.  runtests { -h | --help }
    2.  runtests [OPTIONS] [ testname ... ]

DESCRIPTION
    Runs the unit test scripts in a unique subdirectory name of the current
working directory.  Without any arguments, all the test scripts are run.

OPTIONS
    -h, --help  : this help
    -j <int>    : max concurrent tests (default is one)
    -s          : pass -s to the unit tests that take the option (use real ssh)
    -p          : run each unit test using a list of python versions
    -r          : for tests that accept a remote python version (option -r),
                  iterate on a list of python versions and execute with -r
"""


#
# This is a manual list of all the test scripts; each entry is a tuple
#
#   ( script base name, -s is accepted, -r is accepted )
#
# where "-s is accepted" should be True if the test script accepts a -s
# argument.  Similarly for "-r is accepted".
#
testlist = [ \
    ( 'nulltest', False, False ),
    ( 'remote',   True,  True  ),
    ( 'runcmd',   True,  False ),
    ( 'runjob',   True,  False ),
    ( 'trigs',    False, False ),
    ( 'perms',    False, False ),
    ( 'filesync', True,  False ),
]


# list of pythons to iterate over
# TODO: figure out a way to generalize the listing mechanism
pyL = [ '/home/rrdrake/bin/Linux/py244/bin/python',
        '/home/rrdrake/bin/Linux/py255/bin/python',
        '/home/rrdrake/bin/Linux/py266/bin/python',
        '/home/rrdrake/bin/Linux/py273/bin/python',
        '/home/rrdrake/bin/Linux/py301/bin/python',
        '/home/rrdrake/bin/Linux/py313/bin/python',
        '/home/rrdrake/bin/Linux/py325/bin/python',
        '/home/rrdrake/bin/Linux/py335/bin/python',
        '/home/rrdrake/bin/Linux/py343/bin/python',
        '/home/rrdrake/bin/Linux/py353/bin/python' ]


###########################################################################

def main():

    optL,argL = getopt.getopt( sys.argv[1:], 'hsprj:', longopts=['help'] )

    iterpy = False
    realssh = False
    remotepy = False
    numconcurrent = 1

    for n,v in optL:
        if n == '-h' or n == '--help':
            print3( help_string )
            return
        elif n == '-s':
            realssh = True  # pass -s to test scripts
        elif n == '-p':
            iterpy = True  # iterate python versions
        elif n == '-r':
            remotepy = True  # iterate remote python versions
        elif n == '-j':
            numconcurrent = int( v )
            assert numconcurrent >= 1

    prependPATH( os.path.normpath( os.path.join( mydir, '..' ) ) )

    tdir = makeTestDir()
    print3( 'cd '+tdir )
    os.chdir(tdir)

    # collect the test commands to be run
    cmdD = {}
    for tname,sopt,popt in testlist:

        if len(argL) == 0 or tname in argL:

            tst = os.path.join( mydir, tname )

            if sopt and realssh:
                tst += ' -s'

            if iterpy:
                # iterate python versions on the local (script) launch
                for i in range(len(pyL)):
                    py = pyL[i]
                    if popt and remotepy:
                        # also iterate python versions on the remote side
                        for j in range(len(pyL)):
                            rpy = pyL[j]
                            cmd = py + ' ' + tst + ' -r ' + rpy
                            tid = tname+'_p'+str(i)+'_r'+str(j)
                            cmdD[tid] = cmd
                    else:
                        cmd = py + ' ' + tst
                        tid = tname+'_p'+str(i)
                        cmdD[tid] = cmd

            elif popt and remotepy:
                # iterate python versions only on the remote side
                for j in range(len(pyL)):
                    rpy = pyL[j]
                    cmd = sys.executable + ' ' + tst + ' -r ' + rpy
                    tid = tname+'_r'+str(j)
                    cmdD[tid] = cmd

            else:
                cmd = sys.executable + ' ' + tst
                tid = tname
                cmdD[tid] = cmd

    cwd = os.getcwd()
    jobD = {}
    for tid,cmd in cmdD.items():

        # start job only if number of concurrent jobs is not exceeded
        while True:
            if poll_jobs( jobD ) < numconcurrent:
                break
            time.sleep(1)

        jb = Job( cwd, tid, cmd )
        jobD[tid] = jb

    # wait on all jobs
    while True:
        if poll_jobs( jobD ) == 0:
            break
        time.sleep(1)

    # print results
    nf = 0
    for tid,jb in jobD.items():
        if jb.x != 0:
            print3( "FAIL:", tid+':', jb.cmd )
            nf += 1
    if nf == 0:
        print3( "ALL TESTS PASSED" )


###########################################################################

class Job:

    def __init__(self, cwd, testid, cmd):
        assert os.path.isabs( cwd )
        self.cmd = cmd
        os.chdir(cwd)
        rdir = testid + '_dir'
        os.mkdir( rdir )
        os.chdir( rdir )
        os.environ['TOOLSET_RUNDIR'] = os.path.join( cwd, rdir )
        log = os.path.join( cwd, testid+'.out' )
        self.logfp = open( log, 'w' )
        print3( "RUN: " + cmd )
        self.proc = subprocess.Popen( cmd, shell=True,
                        stdout=self.logfp.fileno(), stderr=subprocess.STDOUT )
        os.chdir(cwd)

    def poll(self):
        """
        Checks on the sub process.  If done, returns exit status, else None.
        """
        if self.proc == None:
            return self.x
        x = self.proc.poll()
        if x != None:
            self.x = x
            self.proc = None
        return x


def poll_jobs( jobD ):
    """
    Polls each job and returns the number of jobs still running.
    """
    nr = 0
    for testid,jb in jobD.items():
        x = jb.poll()
        if x == None:
            nr += 1
    return nr


def makeTestDir():
    """
    Creates and returns a unique absolute directory path under the current
    working directory.
    """
    pid = os.getpid()
    dname = "testdir." + str(pid)
    if os.path.exists(dname):
        # add additional numbers to make a unique name
        for n in range(100):
            if not os.path.exists( dname + '.' + str(n) ):
                dname = dname + '.' + str(n)
                break

    os.mkdir(dname)

    return os.path.abspath(dname)


def prependPATH(d):
    """
    Add the given directory to PATH.
    """
    if 'PATH' in os.environ:
        if os.environ['PATH']:
            os.environ['PATH'] = d + ':' + os.environ['PATH']
        else:
            os.environ['PATH'] = d
    else:
        os.environ['PATH'] = d


def print3( *args ):
    """
    Python 2 & 3 compatible print function.
    """
    s = ' '.join( [ str(x) for x in args ] )
    sys.stdout.write( s + '\n' )
    sys.stdout.flush()


###########################################################################

mydir = os.path.abspath( sys.path[0] )

main()
